/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
 # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__IncompleteArrayField" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __IncompleteArrayField < T > { } extern "C" { # [ link_name = "\u{1}_Z13__assert_fail" ] pub fn __assert_fail ( __assertion : * const :: std :: os :: raw :: c_char , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_uint , __function : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z20__assert_perror_fail" ] pub fn __assert_perror_fail ( __errnum : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_uint , __function : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z8__assert" ] pub fn __assert ( __assertion : * const :: std :: os :: raw :: c_char , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_int ) ; } pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub const _ISupper : _bindgen_ty_1 = 256 ; pub const _ISlower : _bindgen_ty_1 = 512 ; pub const _ISalpha : _bindgen_ty_1 = 1024 ; pub const _ISdigit : _bindgen_ty_1 = 2048 ; pub const _ISxdigit : _bindgen_ty_1 = 4096 ; pub const _ISspace : _bindgen_ty_1 = 8192 ; pub const _ISprint : _bindgen_ty_1 = 16384 ; pub const _ISgraph : _bindgen_ty_1 = 32768 ; pub const _ISblank : _bindgen_ty_1 = 1 ; pub const _IScntrl : _bindgen_ty_1 = 2 ; pub const _ISpunct : _bindgen_ty_1 = 4 ; pub const _ISalnum : _bindgen_ty_1 = 8 ; pub type _bindgen_ty_1 = u32 ; extern "C" { # [ link_name = "\u{1}_Z13__ctype_b_loc" ] pub fn __ctype_b_loc ( ) -> * mut * const :: std :: os :: raw :: c_ushort ; } extern "C" { # [ link_name = "\u{1}_Z19__ctype_tolower_loc" ] pub fn __ctype_tolower_loc ( ) -> * mut * const __int32_t ; } extern "C" { # [ link_name = "\u{1}_Z19__ctype_toupper_loc" ] pub fn __ctype_toupper_loc ( ) -> * mut * const __int32_t ; } extern "C" { # [ link_name = "\u{1}_Z7isalnum" ] pub fn isalnum ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isalpha" ] pub fn isalpha ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7iscntrl" ] pub fn iscntrl ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isdigit" ] pub fn isdigit ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7islower" ] pub fn islower ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isgraph" ] pub fn isgraph ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isprint" ] pub fn isprint ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ispunct" ] pub fn ispunct ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isspace" ] pub fn isspace ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isupper" ] pub fn isupper ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8isxdigit" ] pub fn isxdigit ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tolower" ] pub fn tolower ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7toupper" ] pub fn toupper ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isblank" ] pub fn isblank ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isascii" ] pub fn isascii ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7toascii" ] pub fn toascii ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_toupper" ] pub fn _toupper ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_tolower" ] pub fn _tolower ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; } impl Default for __locale_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { # [ link_name = "\u{1}_Z9isalnum_l" ] pub fn isalnum_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isalpha_l" ] pub fn isalpha_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9iscntrl_l" ] pub fn iscntrl_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isdigit_l" ] pub fn isdigit_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9islower_l" ] pub fn islower_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isgraph_l" ] pub fn isgraph_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isprint_l" ] pub fn isprint_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9ispunct_l" ] pub fn ispunct_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isspace_l" ] pub fn isspace_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isupper_l" ] pub fn isupper_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10isxdigit_l" ] pub fn isxdigit_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isblank_l" ] pub fn isblank_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__tolower_l" ] pub fn __tolower_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tolower_l" ] pub fn tolower_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__toupper_l" ] pub fn __toupper_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9toupper_l" ] pub fn toupper_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16__errno_location" ] pub fn __errno_location ( ) -> * mut :: std :: os :: raw :: c_int ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = :: std :: os :: raw :: c_long ; pub type uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __gwchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_imaxdiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imaxdiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imaxdiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imaxdiv_t ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z7imaxabs" ] pub fn imaxabs ( __n : intmax_t ) -> intmax_t ; } extern "C" { # [ link_name = "\u{1}_Z7imaxdiv" ] pub fn imaxdiv ( __numer : intmax_t , __denom : intmax_t ) -> imaxdiv_t ; } extern "C" { # [ link_name = "\u{1}_Z9strtoimax" ] pub fn strtoimax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { # [ link_name = "\u{1}_Z9strtoumax" ] pub fn strtoumax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } extern "C" { # [ link_name = "\u{1}_Z9wcstoimax" ] pub fn wcstoimax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { # [ link_name = "\u{1}_Z9wcstoumax" ] pub fn wcstoumax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; } pub type FILE = _IO_FILE ; pub type __FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; } impl Default for __mbstate_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; } impl Default for __mbstate_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; } impl Default for _G_fpos_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; } impl Default for _G_fpos64_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; } impl Default for _IO_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; } impl Default for _IO_FILE { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { # [ link_name = "\u{1}_Z11__underflow" ] pub fn __underflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7__uflow" ] pub fn __uflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10__overflow" ] pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_getc" ] pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_putc" ] pub fn _IO_putc ( __c : :: std :: os :: raw :: c_int , __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_feof" ] pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10_IO_ferror" ] pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16_IO_peekc_locked" ] pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13_IO_flockfile" ] pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z15_IO_funlockfile" ] pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z16_IO_ftrylockfile" ] pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11_IO_vfscanf" ] pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12_IO_vfprintf" ] pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_padn" ] pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z9_IO_sgetn" ] pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z11_IO_seekoff" ] pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { # [ link_name = "\u{1}_Z11_IO_seekpos" ] pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { # [ link_name = "\u{1}_Z20_IO_free_backup_area" ] pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { # [ link_name = "\u{1}_Z6remove" ] pub fn remove ( __filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6rename" ] pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8renameat" ] pub fn renameat ( __oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tmpfile" ] pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6tmpnam" ] pub fn tmpnam ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8tmpnam_r" ] pub fn tmpnam_r ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7tempnam" ] pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6fclose" ] pub fn fclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fflush" ] pub fn fflush ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15fflush_unlocked" ] pub fn fflush_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fopen" ] pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z7freopen" ] pub fn freopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6fdopen" ] pub fn fdopen ( __fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z8fmemopen" ] pub fn fmemopen ( __s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z14open_memstream" ] pub fn open_memstream ( __bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6setbuf" ] pub fn setbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z7setvbuf" ] pub fn setvbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9setbuffer" ] pub fn setbuffer ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z10setlinebuf" ] pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z7fprintf" ] pub fn fprintf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6printf" ] pub fn printf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7sprintf" ] pub fn sprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8vfprintf" ] pub fn vfprintf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vprintf" ] pub fn vprintf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8vsprintf" ] pub fn vsprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8snprintf" ] pub fn snprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9vsnprintf" ] pub fn vsnprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8vdprintf" ] pub fn vdprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7dprintf" ] pub fn dprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fscanf" ] pub fn fscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5scanf" ] pub fn scanf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6sscanf" ] pub fn sscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_fscanf" ] pub fn fscanf1 ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_scanf" ] pub fn scanf1 ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_sscanf" ] pub fn sscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vfscanf" ] pub fn vfscanf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6vscanf" ] pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vsscanf" ] pub fn vsscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vfscanf" ] pub fn vfscanf1 ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vscanf" ] pub fn vscanf1 ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vsscanf" ] pub fn vsscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fgetc" ] pub fn fgetc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4getc" ] pub fn getc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7getchar" ] pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getc_unlocked" ] pub fn getc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16getchar_unlocked" ] pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14fgetc_unlocked" ] pub fn fgetc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fputc" ] pub fn fputc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4putc" ] pub fn putc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7putchar" ] pub fn putchar ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14fputc_unlocked" ] pub fn fputc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13putc_unlocked" ] pub fn putc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16putchar_unlocked" ] pub fn putchar_unlocked ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4getw" ] pub fn getw ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4putw" ] pub fn putw ( __w : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fgets" ] pub fn fgets ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z10__getdelim" ] pub fn __getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z8getdelim" ] pub fn getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z7getline" ] pub fn getline ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z5fputs" ] pub fn fputs ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4puts" ] pub fn puts ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6ungetc" ] pub fn ungetc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fread" ] pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6fwrite" ] pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z14fread_unlocked" ] pub fn fread_unlocked ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z15fwrite_unlocked" ] pub fn fwrite_unlocked ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z5fseek" ] pub fn fseek ( __stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5ftell" ] pub fn ftell ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z6rewind" ] pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z6fseeko" ] pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6ftello" ] pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { # [ link_name = "\u{1}_Z7fgetpos" ] pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7fsetpos" ] pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8clearerr" ] pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z4feof" ] pub fn feof ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6ferror" ] pub fn ferror ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17clearerr_unlocked" ] pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z13feof_unlocked" ] pub fn feof_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15ferror_unlocked" ] pub fn ferror_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6perror" ] pub fn perror ( __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z6fileno" ] pub fn fileno ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15fileno_unlocked" ] pub fn fileno_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5popen" ] pub fn popen ( __command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6pclose" ] pub fn pclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ctermid" ] pub fn ctermid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9flockfile" ] pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z12ftrylockfile" ] pub fn ftrylockfile ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11funlockfile" ] pub fn funlockfile ( __stream : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union wait { pub w_status : :: std :: os :: raw :: c_int , pub __wait_terminated : wait__bindgen_ty_1 , pub __wait_stopped : wait__bindgen_ty_2 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct wait__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; } impl wait__bindgen_ty_1 { # [ inline ] pub fn __w_termsig ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set___w_termsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn __w_coredump ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___w_coredump ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __w_retcode ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_retcode ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __w_termsig : :: std :: os :: raw :: c_uint , __w_coredump : :: std :: os :: raw :: c_uint , __w_retcode : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let __w_termsig : u32 = unsafe { :: std :: mem :: transmute ( __w_termsig ) } ; __w_termsig as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let __w_coredump : u32 = unsafe { :: std :: mem :: transmute ( __w_coredump ) } ; __w_coredump as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let __w_retcode : u32 = unsafe { :: std :: mem :: transmute ( __w_retcode ) } ; __w_retcode as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct wait__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; } impl wait__bindgen_ty_2 { # [ inline ] pub fn __w_stopval ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_stopval ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn __w_stopsig ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_stopsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __w_stopval : :: std :: os :: raw :: c_uint , __w_stopsig : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let __w_stopval : u32 = unsafe { :: std :: mem :: transmute ( __w_stopval ) } ; __w_stopval as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let __w_stopsig : u32 = unsafe { :: std :: mem :: transmute ( __w_stopsig ) } ; __w_stopsig as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_wait ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait ) ) ) ; } impl Default for wait { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __WAIT_STATUS { pub __uptr : * mut wait , pub __iptr : * mut :: std :: os :: raw :: c_int , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout___WAIT_STATUS ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __WAIT_STATUS > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __WAIT_STATUS ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __WAIT_STATUS > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __WAIT_STATUS ) ) ) ; } impl Default for __WAIT_STATUS { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z22__ctype_get_mb_cur_max" ] pub fn __ctype_get_mb_cur_max ( ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z4atof" ] pub fn atof ( __nptr : * const :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z4atoi" ] pub fn atoi ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4atol" ] pub fn atol ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z5atoll" ] pub fn atoll ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z6strtod" ] pub fn strtod ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z6strtof" ] pub fn strtof ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f32 ; } extern "C" { # [ link_name = "\u{1}_Z7strtold" ] pub fn strtold ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z6strtol" ] pub fn strtol ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7strtoul" ] pub fn strtoul ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { # [ link_name = "\u{1}_Z6strtoq" ] pub fn strtoq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z7strtouq" ] pub fn strtouq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { # [ link_name = "\u{1}_Z7strtoll" ] pub fn strtoll ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z8strtoull" ] pub fn strtoull ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { # [ link_name = "\u{1}_Z4l64a" ] pub fn l64a ( __n : :: std :: os :: raw :: c_long ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z4a64l" ] pub fn a64l ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type time_t = __time_t ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) ) ; } pub type fd_mask = __fd_mask ; extern "C" { # [ link_name = "\u{1}_Z6select" ] pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7pselect" ] pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13gnu_dev_major" ] pub fn gnu_dev_major ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z13gnu_dev_minor" ] pub fn gnu_dev_minor ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z15gnu_dev_makedev" ] pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_ulonglong ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; } impl Default for pthread_attr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; } impl Default for __pthread_internal_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : pthread_mutex_t___pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_mutex_t___pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; } impl Default for pthread_mutex_t___pthread_mutex_s { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; } impl Default for pthread_mutex_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; } impl Default for pthread_mutexattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : pthread_cond_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_cond_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __futex : :: std :: os :: raw :: c_uint , pub __total_seq : :: std :: os :: raw :: c_ulonglong , pub __wakeup_seq : :: std :: os :: raw :: c_ulonglong , pub __woken_seq : :: std :: os :: raw :: c_ulonglong , pub __mutex : * mut :: std :: os :: raw :: c_void , pub __nwaiters : :: std :: os :: raw :: c_uint , pub __broadcast_seq : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; } impl Default for pthread_cond_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; } impl Default for pthread_cond_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; } impl Default for pthread_condattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : pthread_rwlock_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct pthread_rwlock_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __nr_readers : :: std :: os :: raw :: c_uint , pub __readers_wakeup : :: std :: os :: raw :: c_uint , pub __writer_wakeup : :: std :: os :: raw :: c_uint , pub __nr_readers_queued : :: std :: os :: raw :: c_uint , pub __nr_writers_queued : :: std :: os :: raw :: c_uint , pub __writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __pad1 : :: std :: os :: raw :: c_ulong , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; } impl Default for pthread_rwlock_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; } impl Default for pthread_rwlockattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; } impl Default for pthread_barrier_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; } impl Default for pthread_barrierattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z6random" ] pub fn random ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7srandom" ] pub fn srandom ( __seed : :: std :: os :: raw :: c_uint ) ; } extern "C" { # [ link_name = "\u{1}_Z9initstate" ] pub fn initstate ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8setstate" ] pub fn setstate ( __statebuf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [ test ] fn bindgen_test_layout_random_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < random_data > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( random_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < random_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( random_data ) ) ) ; } impl Default for random_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z8random_r" ] pub fn random_r ( __buf : * mut random_data , __result : * mut i32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9srandom_r" ] pub fn srandom_r ( __seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11initstate_r" ] pub fn initstate_r ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10setstate_r" ] pub fn setstate_r ( __statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4rand" ] pub fn rand ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5srand" ] pub fn srand ( __seed : :: std :: os :: raw :: c_uint ) ; } extern "C" { # [ link_name = "\u{1}_Z6rand_r" ] pub fn rand_r ( __seed : * mut :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7drand48" ] pub fn drand48 ( ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z7erand48" ] pub fn erand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z7lrand48" ] pub fn lrand48 ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7nrand48" ] pub fn nrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7mrand48" ] pub fn mrand48 ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7jrand48" ] pub fn jrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7srand48" ] pub fn srand48 ( __seedval : :: std :: os :: raw :: c_long ) ; } extern "C" { # [ link_name = "\u{1}_Z6seed48" ] pub fn seed48 ( __seed16v : * mut :: std :: os :: raw :: c_ushort ) -> * mut :: std :: os :: raw :: c_ushort ; } extern "C" { # [ link_name = "\u{1}_Z7lcong48" ] pub fn lcong48 ( __param : * mut :: std :: os :: raw :: c_ushort ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct drand48_data { pub __x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __old_x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_drand48_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < drand48_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( drand48_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < drand48_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( drand48_data ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z9drand48_r" ] pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9erand48_r" ] pub fn erand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9lrand48_r" ] pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9nrand48_r" ] pub fn nrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9mrand48_r" ] pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9jrand48_r" ] pub fn jrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9srand48_r" ] pub fn srand48_r ( __seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8seed48_r" ] pub fn seed48_r ( __seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9lcong48_r" ] pub fn lcong48_r ( __param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6malloc" ] pub fn malloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6calloc" ] pub fn calloc ( __nmemb : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7realloc" ] pub fn realloc ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z4free" ] pub fn free ( __ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}_Z5cfree" ] pub fn cfree ( __ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}_Z6alloca" ] pub fn alloca ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6valloc" ] pub fn valloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z14posix_memalign" ] pub fn posix_memalign ( __memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13aligned_alloc" ] pub fn aligned_alloc ( __alignment : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z5abort" ] pub fn abort ( ) ; } extern "C" { # [ link_name = "\u{1}_Z6atexit" ] pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13at_quick_exit" ] pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7on_exit" ] pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void ) > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4exit" ] pub fn exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10quick_exit" ] pub fn quick_exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z5_Exit" ] pub fn _Exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z6getenv" ] pub fn getenv ( __name : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6putenv" ] pub fn putenv ( __string : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setenv" ] pub fn setenv ( __name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8unsetenv" ] pub fn unsetenv ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8clearenv" ] pub fn clearenv ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6mktemp" ] pub fn mktemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7mkstemp" ] pub fn mkstemp ( __template : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mkstemps" ] pub fn mkstemps ( __template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mkdtemp" ] pub fn mkdtemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6system" ] pub fn system ( __command : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8realpath" ] pub fn realpath ( __name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { # [ link_name = "\u{1}_Z7bsearch" ] pub fn bsearch ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z5qsort" ] pub fn qsort ( __base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) ; } extern "C" { # [ link_name = "\u{1}_Z3abs" ] pub fn abs ( __x : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4labs" ] pub fn labs ( __x : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z5llabs" ] pub fn llabs ( __x : :: std :: os :: raw :: c_longlong ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z3div" ] pub fn div ( __numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int ) -> div_t ; } extern "C" { # [ link_name = "\u{1}_Z4ldiv" ] pub fn ldiv ( __numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long ) -> ldiv_t ; } extern "C" { # [ link_name = "\u{1}_Z5lldiv" ] pub fn lldiv ( __numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong ) -> lldiv_t ; } extern "C" { # [ link_name = "\u{1}_Z4ecvt" ] pub fn ecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z4fcvt" ] pub fn fcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z4gcvt" ] pub fn gcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5qecvt" ] pub fn qecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5qfcvt" ] pub fn qfcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5qgcvt" ] pub fn qgcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6ecvt_r" ] pub fn ecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fcvt_r" ] pub fn fcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7qecvt_r" ] pub fn qecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7qfcvt_r" ] pub fn qfcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5mblen" ] pub fn mblen ( __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6mbtowc" ] pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6wctomb" ] pub fn wctomb ( __s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mbstowcs" ] pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z8wcstombs" ] pub fn wcstombs ( __s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z7rpmatch" ] pub fn rpmatch ( __response : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9getsubopt" ] pub fn getsubopt ( __optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * mut :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10getloadavg" ] pub fn getloadavg ( __loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6memcpy" ] pub fn memcpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7memmove" ] pub fn memmove ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7memccpy" ] pub fn memccpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6memset" ] pub fn memset ( __s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6memcmp" ] pub fn memcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6memchr" ] pub fn memchr ( __s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6strcpy" ] pub fn strcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strncpy" ] pub fn strncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strcat" ] pub fn strcat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strncat" ] pub fn strncat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strcmp" ] pub fn strcmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7strncmp" ] pub fn strncmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7strcoll" ] pub fn strcoll ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7strxfrm" ] pub fn strxfrm ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z9strcoll_l" ] pub fn strcoll_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9strxfrm_l" ] pub fn strxfrm_l ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : __locale_t ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6strdup" ] pub fn strdup ( __s : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strndup" ] pub fn strndup ( __string : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strchr" ] pub fn strchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strrchr" ] pub fn strrchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strcspn" ] pub fn strcspn ( __s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6strspn" ] pub fn strspn ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z7strpbrk" ] pub fn strpbrk ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strstr" ] pub fn strstr ( __haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strtok" ] pub fn strtok ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z10__strtok_r" ] pub fn __strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8strtok_r" ] pub fn strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strlen" ] pub fn strlen ( __s : * const :: std :: os :: raw :: c_char ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z7strnlen" ] pub fn strnlen ( __string : * const :: std :: os :: raw :: c_char , __maxlen : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z8strerror" ] pub fn strerror ( __errnum : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__xpg_strerror_r" ] pub fn strerror_r ( __errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10strerror_l" ] pub fn strerror_l ( __errnum : :: std :: os :: raw :: c_int , __l : __locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7__bzero" ] pub fn __bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z5bcopy" ] pub fn bcopy ( __src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z5bzero" ] pub fn bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z4bcmp" ] pub fn bcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5index" ] pub fn index ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6rindex" ] pub fn rindex ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z3ffs" ] pub fn ffs ( __i : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10strcasecmp" ] pub fn strcasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11strncasecmp" ] pub fn strncasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6strsep" ] pub fn strsep ( __stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9strsignal" ] pub fn strsignal ( __sig : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8__stpcpy" ] pub fn __stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6stpcpy" ] pub fn stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9__stpncpy" ] pub fn __stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7stpncpy" ] pub fn stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tm { pub tm_sec : :: std :: os :: raw :: c_int , pub tm_min : :: std :: os :: raw :: c_int , pub tm_hour : :: std :: os :: raw :: c_int , pub tm_mday : :: std :: os :: raw :: c_int , pub tm_mon : :: std :: os :: raw :: c_int , pub tm_year : :: std :: os :: raw :: c_int , pub tm_wday : :: std :: os :: raw :: c_int , pub tm_yday : :: std :: os :: raw :: c_int , pub tm_isdst : :: std :: os :: raw :: c_int , pub tm_gmtoff : :: std :: os :: raw :: c_long , pub tm_zone : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_tm ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tm > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( tm ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tm > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( tm ) ) ) ; } impl Default for tm { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } # [ test ] fn bindgen_test_layout_itimerspec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < itimerspec > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( itimerspec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < itimerspec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( itimerspec ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z5clock" ] pub fn clock ( ) -> clock_t ; } extern "C" { # [ link_name = "\u{1}_Z4time" ] pub fn time ( __timer : * mut time_t ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z8difftime" ] pub fn difftime ( __time1 : time_t , __time0 : time_t ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z6mktime" ] pub fn mktime ( __tp : * mut tm ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z8strftime" ] pub fn strftime ( __s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z10strftime_l" ] pub fn strftime_l ( __s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm , __loc : __locale_t ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6gmtime" ] pub fn gmtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z9localtime" ] pub fn localtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z8gmtime_r" ] pub fn gmtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z11localtime_r" ] pub fn localtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z7asctime" ] pub fn asctime ( __tp : * const tm ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5ctime" ] pub fn ctime ( __timer : * const time_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9asctime_r" ] pub fn asctime_r ( __tp : * const tm , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7ctime_r" ] pub fn ctime_r ( __timer : * const time_t , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5tzset" ] pub fn tzset ( ) ; } extern "C" { # [ link_name = "\u{1}_Z5stime" ] pub fn stime ( __when : * const time_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6timegm" ] pub fn timegm ( __tp : * mut tm ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z9timelocal" ] pub fn timelocal ( __tp : * mut tm ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z6dysize" ] pub fn dysize ( __year : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9nanosleep" ] pub fn nanosleep ( __requested_time : * const timespec , __remaining : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12clock_getres" ] pub fn clock_getres ( __clock_id : clockid_t , __res : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13clock_gettime" ] pub fn clock_gettime ( __clock_id : clockid_t , __tp : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13clock_settime" ] pub fn clock_settime ( __clock_id : clockid_t , __tp : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15clock_nanosleep" ] pub fn clock_nanosleep ( __clock_id : clockid_t , __flags : :: std :: os :: raw :: c_int , __req : * const timespec , __rem : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19clock_getcpuclockid" ] pub fn clock_getcpuclockid ( __pid : pid_t , __clock_id : * mut clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12timer_create" ] pub fn timer_create ( __clock_id : clockid_t , __evp : * mut sigevent , __timerid : * mut timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12timer_delete" ] pub fn timer_delete ( __timerid : timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13timer_settime" ] pub fn timer_settime ( __timerid : timer_t , __flags : :: std :: os :: raw :: c_int , __value : * const itimerspec , __ovalue : * mut itimerspec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13timer_gettime" ] pub fn timer_gettime ( __timerid : timer_t , __value : * mut itimerspec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16timer_getoverrun" ] pub fn timer_getoverrun ( __timerid : timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12timespec_get" ] pub fn timespec_get ( __ts : * mut timespec , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iovec { pub iov_base : * mut :: std :: os :: raw :: c_void , pub iov_len : usize , } # [ test ] fn bindgen_test_layout_iovec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < iovec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( iovec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < iovec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( iovec ) ) ) ; } impl Default for iovec { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z5readv" ] pub fn readv ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6writev" ] pub fn writev ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6preadv" ] pub fn preadv ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int , __offset : __off_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z7pwritev" ] pub fn pwritev ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int , __offset : __off_t ) -> isize ; } pub type socklen_t = __socklen_t ; pub const __socket_type_SOCK_STREAM : __socket_type = 1 ; pub const __socket_type_SOCK_DGRAM : __socket_type = 2 ; pub const __socket_type_SOCK_RAW : __socket_type = 3 ; pub const __socket_type_SOCK_RDM : __socket_type = 4 ; pub const __socket_type_SOCK_SEQPACKET : __socket_type = 5 ; pub const __socket_type_SOCK_DCCP : __socket_type = 6 ; pub const __socket_type_SOCK_PACKET : __socket_type = 10 ; pub const __socket_type_SOCK_CLOEXEC : __socket_type = 524288 ; pub const __socket_type_SOCK_NONBLOCK : __socket_type = 2048 ; pub type __socket_type = u32 ; pub type sa_family_t = :: std :: os :: raw :: c_ushort ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr { pub sa_family : sa_family_t , pub sa_data : [ :: std :: os :: raw :: c_char ; 14usize ] , } # [ test ] fn bindgen_test_layout_sockaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sockaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( sockaddr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_storage { pub ss_family : sa_family_t , pub __ss_padding : [ :: std :: os :: raw :: c_char ; 118usize ] , pub __ss_align : :: std :: os :: raw :: c_ulong , } # [ test ] fn bindgen_test_layout_sockaddr_storage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_storage > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( sockaddr_storage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_storage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_storage ) ) ) ; } impl Default for sockaddr_storage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const MSG_OOB : _bindgen_ty_2 = 1 ; pub const MSG_PEEK : _bindgen_ty_2 = 2 ; pub const MSG_DONTROUTE : _bindgen_ty_2 = 4 ; pub const MSG_CTRUNC : _bindgen_ty_2 = 8 ; pub const MSG_PROXY : _bindgen_ty_2 = 16 ; pub const MSG_TRUNC : _bindgen_ty_2 = 32 ; pub const MSG_DONTWAIT : _bindgen_ty_2 = 64 ; pub const MSG_EOR : _bindgen_ty_2 = 128 ; pub const MSG_WAITALL : _bindgen_ty_2 = 256 ; pub const MSG_FIN : _bindgen_ty_2 = 512 ; pub const MSG_SYN : _bindgen_ty_2 = 1024 ; pub const MSG_CONFIRM : _bindgen_ty_2 = 2048 ; pub const MSG_RST : _bindgen_ty_2 = 4096 ; pub const MSG_ERRQUEUE : _bindgen_ty_2 = 8192 ; pub const MSG_NOSIGNAL : _bindgen_ty_2 = 16384 ; pub const MSG_MORE : _bindgen_ty_2 = 32768 ; pub const MSG_WAITFORONE : _bindgen_ty_2 = 65536 ; pub const MSG_FASTOPEN : _bindgen_ty_2 = 536870912 ; pub const MSG_CMSG_CLOEXEC : _bindgen_ty_2 = 1073741824 ; pub type _bindgen_ty_2 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct msghdr { pub msg_name : * mut :: std :: os :: raw :: c_void , pub msg_namelen : socklen_t , pub msg_iov : * mut iovec , pub msg_iovlen : usize , pub msg_control : * mut :: std :: os :: raw :: c_void , pub msg_controllen : usize , pub msg_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_msghdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < msghdr > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( msghdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < msghdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( msghdr ) ) ) ; } impl Default for msghdr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct cmsghdr { pub cmsg_len : usize , pub cmsg_level : :: std :: os :: raw :: c_int , pub cmsg_type : :: std :: os :: raw :: c_int , pub __cmsg_data : __IncompleteArrayField < :: std :: os :: raw :: c_uchar > , } # [ test ] fn bindgen_test_layout_cmsghdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < cmsghdr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( cmsghdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < cmsghdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( cmsghdr ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z13__cmsg_nxthdr" ] pub fn __cmsg_nxthdr ( __mhdr : * mut msghdr , __cmsg : * mut cmsghdr ) -> * mut cmsghdr ; } pub const SCM_RIGHTS : _bindgen_ty_3 = 1 ; pub type _bindgen_ty_3 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct linger { pub l_onoff : :: std :: os :: raw :: c_int , pub l_linger : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_linger ( ) { assert_eq ! ( :: std :: mem :: size_of :: < linger > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( linger ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < linger > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( linger ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct osockaddr { pub sa_family : :: std :: os :: raw :: c_ushort , pub sa_data : [ :: std :: os :: raw :: c_uchar ; 14usize ] , } # [ test ] fn bindgen_test_layout_osockaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < osockaddr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( osockaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < osockaddr > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( osockaddr ) ) ) ; } pub const SHUT_RD : _bindgen_ty_4 = 0 ; pub const SHUT_WR : _bindgen_ty_4 = 1 ; pub const SHUT_RDWR : _bindgen_ty_4 = 2 ; pub type _bindgen_ty_4 = u32 ; extern "C" { # [ link_name = "\u{1}_Z6socket" ] pub fn socket ( __domain : :: std :: os :: raw :: c_int , __type : :: std :: os :: raw :: c_int , __protocol : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10socketpair" ] pub fn socketpair ( __domain : :: std :: os :: raw :: c_int , __type : :: std :: os :: raw :: c_int , __protocol : :: std :: os :: raw :: c_int , __fds : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4bind" ] pub fn bind ( __fd : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getsockname" ] pub fn getsockname ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7connect" ] pub fn connect ( __fd : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getpeername" ] pub fn getpeername ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4send" ] pub fn send ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z4recv" ] pub fn recv ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6sendto" ] pub fn sendto ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __addr_len : socklen_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z8recvfrom" ] pub fn recvfrom ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z7sendmsg" ] pub fn sendmsg ( __fd : :: std :: os :: raw :: c_int , __message : * const msghdr , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z7recvmsg" ] pub fn recvmsg ( __fd : :: std :: os :: raw :: c_int , __message : * mut msghdr , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z10getsockopt" ] pub fn getsockopt ( __fd : :: std :: os :: raw :: c_int , __level : :: std :: os :: raw :: c_int , __optname : :: std :: os :: raw :: c_int , __optval : * mut :: std :: os :: raw :: c_void , __optlen : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10setsockopt" ] pub fn setsockopt ( __fd : :: std :: os :: raw :: c_int , __level : :: std :: os :: raw :: c_int , __optname : :: std :: os :: raw :: c_int , __optval : * const :: std :: os :: raw :: c_void , __optlen : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6listen" ] pub fn listen ( __fd : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6accept" ] pub fn accept ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8shutdown" ] pub fn shutdown ( __fd : :: std :: os :: raw :: c_int , __how : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sockatmark" ] pub fn sockatmark ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8isfdtype" ] pub fn isfdtype ( __fd : :: std :: os :: raw :: c_int , __fdtype : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type in_addr_t = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_addr { pub s_addr : in_addr_t , } # [ test ] fn bindgen_test_layout_in_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in_addr > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( in_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in_addr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ip_opts { pub ip_dst : in_addr , pub ip_opts : [ :: std :: os :: raw :: c_char ; 40usize ] , } # [ test ] fn bindgen_test_layout_ip_opts ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_opts > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( ip_opts ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_opts > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_opts ) ) ) ; } impl Default for ip_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreqn { pub imr_multiaddr : in_addr , pub imr_address : in_addr , pub imr_ifindex : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ip_mreqn ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreqn > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ip_mreqn ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreqn > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreqn ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_pktinfo { pub ipi_ifindex : :: std :: os :: raw :: c_int , pub ipi_spec_dst : in_addr , pub ipi_addr : in_addr , } # [ test ] fn bindgen_test_layout_in_pktinfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in_pktinfo > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( in_pktinfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in_pktinfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in_pktinfo ) ) ) ; } pub const IPPROTO_IP : _bindgen_ty_5 = 0 ; pub const IPPROTO_ICMP : _bindgen_ty_5 = 1 ; pub const IPPROTO_IGMP : _bindgen_ty_5 = 2 ; pub const IPPROTO_IPIP : _bindgen_ty_5 = 4 ; pub const IPPROTO_TCP : _bindgen_ty_5 = 6 ; pub const IPPROTO_EGP : _bindgen_ty_5 = 8 ; pub const IPPROTO_PUP : _bindgen_ty_5 = 12 ; pub const IPPROTO_UDP : _bindgen_ty_5 = 17 ; pub const IPPROTO_IDP : _bindgen_ty_5 = 22 ; pub const IPPROTO_TP : _bindgen_ty_5 = 29 ; pub const IPPROTO_DCCP : _bindgen_ty_5 = 33 ; pub const IPPROTO_IPV6 : _bindgen_ty_5 = 41 ; pub const IPPROTO_RSVP : _bindgen_ty_5 = 46 ; pub const IPPROTO_GRE : _bindgen_ty_5 = 47 ; pub const IPPROTO_ESP : _bindgen_ty_5 = 50 ; pub const IPPROTO_AH : _bindgen_ty_5 = 51 ; pub const IPPROTO_MTP : _bindgen_ty_5 = 92 ; pub const IPPROTO_BEETPH : _bindgen_ty_5 = 94 ; pub const IPPROTO_ENCAP : _bindgen_ty_5 = 98 ; pub const IPPROTO_PIM : _bindgen_ty_5 = 103 ; pub const IPPROTO_COMP : _bindgen_ty_5 = 108 ; pub const IPPROTO_SCTP : _bindgen_ty_5 = 132 ; pub const IPPROTO_UDPLITE : _bindgen_ty_5 = 136 ; pub const IPPROTO_RAW : _bindgen_ty_5 = 255 ; pub const IPPROTO_MAX : _bindgen_ty_5 = 256 ; pub type _bindgen_ty_5 = u32 ; pub const IPPROTO_HOPOPTS : _bindgen_ty_6 = 0 ; pub const IPPROTO_ROUTING : _bindgen_ty_6 = 43 ; pub const IPPROTO_FRAGMENT : _bindgen_ty_6 = 44 ; pub const IPPROTO_ICMPV6 : _bindgen_ty_6 = 58 ; pub const IPPROTO_NONE : _bindgen_ty_6 = 59 ; pub const IPPROTO_DSTOPTS : _bindgen_ty_6 = 60 ; pub const IPPROTO_MH : _bindgen_ty_6 = 135 ; pub type _bindgen_ty_6 = u32 ; pub type in_port_t = u16 ; pub const IPPORT_ECHO : _bindgen_ty_7 = 7 ; pub const IPPORT_DISCARD : _bindgen_ty_7 = 9 ; pub const IPPORT_SYSTAT : _bindgen_ty_7 = 11 ; pub const IPPORT_DAYTIME : _bindgen_ty_7 = 13 ; pub const IPPORT_NETSTAT : _bindgen_ty_7 = 15 ; pub const IPPORT_FTP : _bindgen_ty_7 = 21 ; pub const IPPORT_TELNET : _bindgen_ty_7 = 23 ; pub const IPPORT_SMTP : _bindgen_ty_7 = 25 ; pub const IPPORT_TIMESERVER : _bindgen_ty_7 = 37 ; pub const IPPORT_NAMESERVER : _bindgen_ty_7 = 42 ; pub const IPPORT_WHOIS : _bindgen_ty_7 = 43 ; pub const IPPORT_MTP : _bindgen_ty_7 = 57 ; pub const IPPORT_TFTP : _bindgen_ty_7 = 69 ; pub const IPPORT_RJE : _bindgen_ty_7 = 77 ; pub const IPPORT_FINGER : _bindgen_ty_7 = 79 ; pub const IPPORT_TTYLINK : _bindgen_ty_7 = 87 ; pub const IPPORT_SUPDUP : _bindgen_ty_7 = 95 ; pub const IPPORT_EXECSERVER : _bindgen_ty_7 = 512 ; pub const IPPORT_LOGINSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_CMDSERVER : _bindgen_ty_7 = 514 ; pub const IPPORT_EFSSERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_BIFFUDP : _bindgen_ty_7 = 512 ; pub const IPPORT_WHOSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_ROUTESERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_RESERVED : _bindgen_ty_7 = 1024 ; pub const IPPORT_USERRESERVED : _bindgen_ty_7 = 5000 ; pub type _bindgen_ty_7 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct in6_addr { pub __in6_u : in6_addr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union in6_addr__bindgen_ty_1 { pub __u6_addr8 : [ u8 ; 16usize ] , pub __u6_addr16 : [ u16 ; 8usize ] , pub __u6_addr32 : [ u32 ; 4usize ] , _bindgen_union_align : [ u32 ; 4usize ] , } # [ test ] fn bindgen_test_layout_in6_addr__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in6_addr__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in6_addr__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ) ) ; } impl Default for in6_addr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_in6_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in6_addr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( in6_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in6_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in6_addr ) ) ) ; } impl Default for in6_addr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr_in { pub sin_family : sa_family_t , pub sin_port : in_port_t , pub sin_addr : in_addr , pub sin_zero : [ :: std :: os :: raw :: c_uchar ; 8usize ] , } # [ test ] fn bindgen_test_layout_sockaddr_in ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_in > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sockaddr_in ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_in > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_in ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_in6 { pub sin6_family : sa_family_t , pub sin6_port : in_port_t , pub sin6_flowinfo : u32 , pub sin6_addr : in6_addr , pub sin6_scope_id : u32 , } # [ test ] fn bindgen_test_layout_sockaddr_in6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_in6 > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( sockaddr_in6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_in6 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_in6 ) ) ) ; } impl Default for sockaddr_in6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , } # [ test ] fn bindgen_test_layout_ip_mreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreq > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ip_mreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreq > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreq ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq_source { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , pub imr_sourceaddr : in_addr , } # [ test ] fn bindgen_test_layout_ip_mreq_source ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreq_source > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ip_mreq_source ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreq_source > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreq_source ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ipv6_mreq { pub ipv6mr_multiaddr : in6_addr , pub ipv6mr_interface : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_ipv6_mreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ipv6_mreq > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ipv6_mreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ipv6_mreq > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ipv6_mreq ) ) ) ; } impl Default for ipv6_mreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_req { pub gr_interface : u32 , pub gr_group : sockaddr_storage , } # [ test ] fn bindgen_test_layout_group_req ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_req > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( group_req ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_req > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_req ) ) ) ; } impl Default for group_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_source_req { pub gsr_interface : u32 , pub gsr_group : sockaddr_storage , pub gsr_source : sockaddr_storage , } # [ test ] fn bindgen_test_layout_group_source_req ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_source_req > ( ) , 264usize , concat ! ( "Size of: " , stringify ! ( group_source_req ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_source_req > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_source_req ) ) ) ; } impl Default for group_source_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_msfilter { pub imsf_multiaddr : in_addr , pub imsf_interface : in_addr , pub imsf_fmode : u32 , pub imsf_numsrc : u32 , pub imsf_slist : [ in_addr ; 1usize ] , } # [ test ] fn bindgen_test_layout_ip_msfilter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_msfilter > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ip_msfilter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_msfilter > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_msfilter ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_filter { pub gf_interface : u32 , pub gf_group : sockaddr_storage , pub gf_fmode : u32 , pub gf_numsrc : u32 , pub gf_slist : [ sockaddr_storage ; 1usize ] , } # [ test ] fn bindgen_test_layout_group_filter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_filter > ( ) , 272usize , concat ! ( "Size of: " , stringify ! ( group_filter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_filter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_filter ) ) ) ; } impl Default for group_filter { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z5ntohl" ] pub fn ntohl ( __netlong : u32 ) -> u32 ; } extern "C" { # [ link_name = "\u{1}_Z5ntohs" ] pub fn ntohs ( __netshort : u16 ) -> u16 ; } extern "C" { # [ link_name = "\u{1}_Z5htonl" ] pub fn htonl ( __hostlong : u32 ) -> u32 ; } extern "C" { # [ link_name = "\u{1}_Z5htons" ] pub fn htons ( __hostshort : u16 ) -> u16 ; } extern "C" { # [ link_name = "\u{1}_Z12bindresvport" ] pub fn bindresvport ( __sockfd : :: std :: os :: raw :: c_int , __sock_in : * mut sockaddr_in ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13bindresvport6" ] pub fn bindresvport6 ( __sockfd : :: std :: os :: raw :: c_int , __sock_in : * mut sockaddr_in6 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9inet_addr" ] pub fn inet_addr ( __cp : * const :: std :: os :: raw :: c_char ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z10inet_lnaof" ] pub fn inet_lnaof ( __in : in_addr ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z13inet_makeaddr" ] pub fn inet_makeaddr ( __net : in_addr_t , __host : in_addr_t ) -> in_addr ; } extern "C" { # [ link_name = "\u{1}_Z10inet_netof" ] pub fn inet_netof ( __in : in_addr ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z12inet_network" ] pub fn inet_network ( __cp : * const :: std :: os :: raw :: c_char ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z9inet_ntoa" ] pub fn inet_ntoa ( __in : in_addr ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9inet_pton" ] pub fn inet_pton ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9inet_ntop" ] pub fn inet_ntop ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __len : socklen_t ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9inet_aton" ] pub fn inet_aton ( __cp : * const :: std :: os :: raw :: c_char , __inp : * mut in_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9inet_neta" ] pub fn inet_neta ( __net : in_addr_t , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z13inet_net_ntop" ] pub fn inet_net_ntop ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_void , __bits : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z13inet_net_pton" ] pub fn inet_net_pton ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14inet_nsap_addr" ] pub fn inet_nsap_addr ( __cp : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_uchar , __len : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z14inet_nsap_ntoa" ] pub fn inet_nsap_ntoa ( __len : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_uchar , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct dirent { pub d_ino : __ino_t , pub d_off : __off_t , pub d_reclen : :: std :: os :: raw :: c_ushort , pub d_type : :: std :: os :: raw :: c_uchar , pub d_name : [ :: std :: os :: raw :: c_char ; 256usize ] , } # [ test ] fn bindgen_test_layout_dirent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < dirent > ( ) , 280usize , concat ! ( "Size of: " , stringify ! ( dirent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < dirent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( dirent ) ) ) ; } impl Default for dirent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const DT_UNKNOWN : _bindgen_ty_8 = 0 ; pub const DT_FIFO : _bindgen_ty_8 = 1 ; pub const DT_CHR : _bindgen_ty_8 = 2 ; pub const DT_DIR : _bindgen_ty_8 = 4 ; pub const DT_BLK : _bindgen_ty_8 = 6 ; pub const DT_REG : _bindgen_ty_8 = 8 ; pub const DT_LNK : _bindgen_ty_8 = 10 ; pub const DT_SOCK : _bindgen_ty_8 = 12 ; pub const DT_WHT : _bindgen_ty_8 = 14 ; pub type _bindgen_ty_8 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __dirstream { _unused : [ u8 ; 0 ] , } pub type DIR = __dirstream ; extern "C" { # [ link_name = "\u{1}_Z7opendir" ] pub fn opendir ( __name : * const :: std :: os :: raw :: c_char ) -> * mut DIR ; } extern "C" { # [ link_name = "\u{1}_Z9fdopendir" ] pub fn fdopendir ( __fd : :: std :: os :: raw :: c_int ) -> * mut DIR ; } extern "C" { # [ link_name = "\u{1}_Z8closedir" ] pub fn closedir ( __dirp : * mut DIR ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7readdir" ] pub fn readdir ( __dirp : * mut DIR ) -> * mut dirent ; } extern "C" { # [ link_name = "\u{1}_Z9readdir_r" ] pub fn readdir_r ( __dirp : * mut DIR , __entry : * mut dirent , __result : * mut * mut dirent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9rewinddir" ] pub fn rewinddir ( __dirp : * mut DIR ) ; } extern "C" { # [ link_name = "\u{1}_Z7seekdir" ] pub fn seekdir ( __dirp : * mut DIR , __pos : :: std :: os :: raw :: c_long ) ; } extern "C" { # [ link_name = "\u{1}_Z7telldir" ] pub fn telldir ( __dirp : * mut DIR ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z5dirfd" ] pub fn dirfd ( __dirp : * mut DIR ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7scandir" ] pub fn scandir ( __dir : * const :: std :: os :: raw :: c_char , __namelist : * mut * mut * mut dirent , __selector : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const dirent ) -> :: std :: os :: raw :: c_int > , __cmp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut * const dirent , arg2 : * mut * const dirent ) -> :: std :: os :: raw :: c_int > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9alphasort" ] pub fn alphasort ( __e1 : * mut * const dirent , __e2 : * mut * const dirent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getdirentries" ] pub fn getdirentries ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize , __basep : * mut __off_t ) -> __ssize_t ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct flock { pub l_type : :: std :: os :: raw :: c_short , pub l_whence : :: std :: os :: raw :: c_short , pub l_start : __off_t , pub l_len : __off_t , pub l_pid : __pid_t , } # [ test ] fn bindgen_test_layout_flock ( ) { assert_eq ! ( :: std :: mem :: size_of :: < flock > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( flock ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < flock > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( flock ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct stat { pub st_dev : __dev_t , pub st_ino : __ino_t , pub st_nlink : __nlink_t , pub st_mode : __mode_t , pub st_uid : __uid_t , pub st_gid : __gid_t , pub __pad0 : :: std :: os :: raw :: c_int , pub st_rdev : __dev_t , pub st_size : __off_t , pub st_blksize : __blksize_t , pub st_blocks : __blkcnt_t , pub st_atim : timespec , pub st_mtim : timespec , pub st_ctim : timespec , pub __unused : [ __syscall_slong_t ; 3usize ] , } # [ test ] fn bindgen_test_layout_stat ( ) { assert_eq ! ( :: std :: mem :: size_of :: < stat > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( stat ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < stat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( stat ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z5fcntl" ] pub fn fcntl ( __fd : :: std :: os :: raw :: c_int , __cmd : :: std :: os :: raw :: c_int , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4open" ] pub fn open ( __file : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6openat" ] pub fn openat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5creat" ] pub fn creat ( __file : * const :: std :: os :: raw :: c_char , __mode : mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5lockf" ] pub fn lockf ( __fd : :: std :: os :: raw :: c_int , __cmd : :: std :: os :: raw :: c_int , __len : off_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13posix_fadvise" ] pub fn posix_fadvise ( __fd : :: std :: os :: raw :: c_int , __offset : off_t , __len : off_t , __advise : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15posix_fallocate" ] pub fn posix_fallocate ( __fd : :: std :: os :: raw :: c_int , __offset : off_t , __len : off_t ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddrs { pub ifa_next : * mut ifaddrs , pub ifa_name : * mut :: std :: os :: raw :: c_char , pub ifa_flags : :: std :: os :: raw :: c_uint , pub ifa_addr : * mut sockaddr , pub ifa_netmask : * mut sockaddr , pub ifa_ifu : ifaddrs__bindgen_ty_1 , pub ifa_data : * mut :: std :: os :: raw :: c_void , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddrs__bindgen_ty_1 { pub ifu_broadaddr : * mut sockaddr , pub ifu_dstaddr : * mut sockaddr , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_ifaddrs__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddrs__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ifaddrs__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddrs__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifaddrs__bindgen_ty_1 ) ) ) ; } impl Default for ifaddrs__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifaddrs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddrs > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( ifaddrs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddrs > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifaddrs ) ) ) ; } impl Default for ifaddrs { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z10getifaddrs" ] pub fn getifaddrs ( __ifap : * mut * mut ifaddrs ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11freeifaddrs" ] pub fn freeifaddrs ( __ifa : * mut ifaddrs ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rpcent { pub r_name : * mut :: std :: os :: raw :: c_char , pub r_aliases : * mut * mut :: std :: os :: raw :: c_char , pub r_number : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_rpcent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rpcent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( rpcent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rpcent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rpcent ) ) ) ; } impl Default for rpcent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z9setrpcent" ] pub fn setrpcent ( __stayopen : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z9endrpcent" ] pub fn endrpcent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z12getrpcbyname" ] pub fn getrpcbyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut rpcent ; } extern "C" { # [ link_name = "\u{1}_Z14getrpcbynumber" ] pub fn getrpcbynumber ( __number : :: std :: os :: raw :: c_int ) -> * mut rpcent ; } extern "C" { # [ link_name = "\u{1}_Z9getrpcent" ] pub fn getrpcent ( ) -> * mut rpcent ; } extern "C" { # [ link_name = "\u{1}_Z14getrpcbyname_r" ] pub fn getrpcbyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut rpcent , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16getrpcbynumber_r" ] pub fn getrpcbynumber_r ( __number : :: std :: os :: raw :: c_int , __result_buf : * mut rpcent , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getrpcent_r" ] pub fn getrpcent_r ( __result_buf : * mut rpcent , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct netent { pub n_name : * mut :: std :: os :: raw :: c_char , pub n_aliases : * mut * mut :: std :: os :: raw :: c_char , pub n_addrtype : :: std :: os :: raw :: c_int , pub n_net : u32 , } # [ test ] fn bindgen_test_layout_netent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < netent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( netent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < netent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( netent ) ) ) ; } impl Default for netent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z18__h_errno_location" ] pub fn __h_errno_location ( ) -> * mut :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6herror" ] pub fn herror ( __str : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z9hstrerror" ] pub fn hstrerror ( __err_num : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hostent { pub h_name : * mut :: std :: os :: raw :: c_char , pub h_aliases : * mut * mut :: std :: os :: raw :: c_char , pub h_addrtype : :: std :: os :: raw :: c_int , pub h_length : :: std :: os :: raw :: c_int , pub h_addr_list : * mut * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_hostent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < hostent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( hostent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < hostent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( hostent ) ) ) ; } impl Default for hostent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z10sethostent" ] pub fn sethostent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10endhostent" ] pub fn endhostent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z10gethostent" ] pub fn gethostent ( ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z13gethostbyaddr" ] pub fn gethostbyaddr ( __addr : * const :: std :: os :: raw :: c_void , __len : __socklen_t , __type : :: std :: os :: raw :: c_int ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z13gethostbyname" ] pub fn gethostbyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z14gethostbyname2" ] pub fn gethostbyname2 ( __name : * const :: std :: os :: raw :: c_char , __af : :: std :: os :: raw :: c_int ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z12gethostent_r" ] pub fn gethostent_r ( __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15gethostbyaddr_r" ] pub fn gethostbyaddr_r ( __addr : * const :: std :: os :: raw :: c_void , __len : __socklen_t , __type : :: std :: os :: raw :: c_int , __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15gethostbyname_r" ] pub fn gethostbyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16gethostbyname2_r" ] pub fn gethostbyname2_r ( __name : * const :: std :: os :: raw :: c_char , __af : :: std :: os :: raw :: c_int , __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9setnetent" ] pub fn setnetent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z9endnetent" ] pub fn endnetent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z9getnetent" ] pub fn getnetent ( ) -> * mut netent ; } extern "C" { # [ link_name = "\u{1}_Z12getnetbyaddr" ] pub fn getnetbyaddr ( __net : u32 , __type : :: std :: os :: raw :: c_int ) -> * mut netent ; } extern "C" { # [ link_name = "\u{1}_Z12getnetbyname" ] pub fn getnetbyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut netent ; } extern "C" { # [ link_name = "\u{1}_Z11getnetent_r" ] pub fn getnetent_r ( __result_buf : * mut netent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14getnetbyaddr_r" ] pub fn getnetbyaddr_r ( __net : u32 , __type : :: std :: os :: raw :: c_int , __result_buf : * mut netent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14getnetbyname_r" ] pub fn getnetbyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut netent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct servent { pub s_name : * mut :: std :: os :: raw :: c_char , pub s_aliases : * mut * mut :: std :: os :: raw :: c_char , pub s_port : :: std :: os :: raw :: c_int , pub s_proto : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_servent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < servent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( servent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < servent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( servent ) ) ) ; } impl Default for servent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z10setservent" ] pub fn setservent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10endservent" ] pub fn endservent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z10getservent" ] pub fn getservent ( ) -> * mut servent ; } extern "C" { # [ link_name = "\u{1}_Z13getservbyname" ] pub fn getservbyname ( __name : * const :: std :: os :: raw :: c_char , __proto : * const :: std :: os :: raw :: c_char ) -> * mut servent ; } extern "C" { # [ link_name = "\u{1}_Z13getservbyport" ] pub fn getservbyport ( __port : :: std :: os :: raw :: c_int , __proto : * const :: std :: os :: raw :: c_char ) -> * mut servent ; } extern "C" { # [ link_name = "\u{1}_Z12getservent_r" ] pub fn getservent_r ( __result_buf : * mut servent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut servent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15getservbyname_r" ] pub fn getservbyname_r ( __name : * const :: std :: os :: raw :: c_char , __proto : * const :: std :: os :: raw :: c_char , __result_buf : * mut servent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut servent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15getservbyport_r" ] pub fn getservbyport_r ( __port : :: std :: os :: raw :: c_int , __proto : * const :: std :: os :: raw :: c_char , __result_buf : * mut servent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut servent ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct protoent { pub p_name : * mut :: std :: os :: raw :: c_char , pub p_aliases : * mut * mut :: std :: os :: raw :: c_char , pub p_proto : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_protoent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < protoent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( protoent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < protoent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( protoent ) ) ) ; } impl Default for protoent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z11setprotoent" ] pub fn setprotoent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z11endprotoent" ] pub fn endprotoent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z11getprotoent" ] pub fn getprotoent ( ) -> * mut protoent ; } extern "C" { # [ link_name = "\u{1}_Z14getprotobyname" ] pub fn getprotobyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut protoent ; } extern "C" { # [ link_name = "\u{1}_Z16getprotobynumber" ] pub fn getprotobynumber ( __proto : :: std :: os :: raw :: c_int ) -> * mut protoent ; } extern "C" { # [ link_name = "\u{1}_Z13getprotoent_r" ] pub fn getprotoent_r ( __result_buf : * mut protoent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16getprotobyname_r" ] pub fn getprotobyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut protoent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18getprotobynumber_r" ] pub fn getprotobynumber_r ( __proto : :: std :: os :: raw :: c_int , __result_buf : * mut protoent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11setnetgrent" ] pub fn setnetgrent ( __netgroup : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11endnetgrent" ] pub fn endnetgrent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z11getnetgrent" ] pub fn getnetgrent ( __hostp : * mut * mut :: std :: os :: raw :: c_char , __userp : * mut * mut :: std :: os :: raw :: c_char , __domainp : * mut * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7innetgr" ] pub fn innetgr ( __netgroup : * const :: std :: os :: raw :: c_char , __host : * const :: std :: os :: raw :: c_char , __user : * const :: std :: os :: raw :: c_char , __domain : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getnetgrent_r" ] pub fn getnetgrent_r ( __hostp : * mut * mut :: std :: os :: raw :: c_char , __userp : * mut * mut :: std :: os :: raw :: c_char , __domainp : * mut * mut :: std :: os :: raw :: c_char , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4rcmd" ] pub fn rcmd ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_ushort , __locuser : * const :: std :: os :: raw :: c_char , __remuser : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7rcmd_af" ] pub fn rcmd_af ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_ushort , __locuser : * const :: std :: os :: raw :: c_char , __remuser : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5rexec" ] pub fn rexec ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __pass : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8rexec_af" ] pub fn rexec_af ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __pass : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ruserok" ] pub fn ruserok ( __rhost : * const :: std :: os :: raw :: c_char , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10ruserok_af" ] pub fn ruserok_af ( __rhost : * const :: std :: os :: raw :: c_char , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8iruserok" ] pub fn iruserok ( __raddr : u32 , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11iruserok_af" ] pub fn iruserok_af ( __raddr : * const :: std :: os :: raw :: c_void , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9rresvport" ] pub fn rresvport ( __alport : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12rresvport_af" ] pub fn rresvport_af ( __alport : * mut :: std :: os :: raw :: c_int , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct addrinfo { pub ai_flags : :: std :: os :: raw :: c_int , pub ai_family : :: std :: os :: raw :: c_int , pub ai_socktype : :: std :: os :: raw :: c_int , pub ai_protocol : :: std :: os :: raw :: c_int , pub ai_addrlen : socklen_t , pub ai_addr : * mut sockaddr , pub ai_canonname : * mut :: std :: os :: raw :: c_char , pub ai_next : * mut addrinfo , } # [ test ] fn bindgen_test_layout_addrinfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < addrinfo > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( addrinfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < addrinfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( addrinfo ) ) ) ; } impl Default for addrinfo { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z11getaddrinfo" ] pub fn getaddrinfo ( __name : * const :: std :: os :: raw :: c_char , __service : * const :: std :: os :: raw :: c_char , __req : * const addrinfo , __pai : * mut * mut addrinfo ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12freeaddrinfo" ] pub fn freeaddrinfo ( __ai : * mut addrinfo ) ; } extern "C" { # [ link_name = "\u{1}_Z12gai_strerror" ] pub fn gai_strerror ( __ecode : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z11getnameinfo" ] pub fn getnameinfo ( __sa : * const sockaddr , __salen : socklen_t , __host : * mut :: std :: os :: raw :: c_char , __hostlen : socklen_t , __serv : * mut :: std :: os :: raw :: c_char , __servlen : socklen_t , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type nfds_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct pollfd { pub fd : :: std :: os :: raw :: c_int , pub events : :: std :: os :: raw :: c_short , pub revents : :: std :: os :: raw :: c_short , } # [ test ] fn bindgen_test_layout_pollfd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pollfd > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pollfd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pollfd > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pollfd ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z4poll" ] pub fn poll ( __fds : * mut pollfd , __nfds : nfds_t , __timeout : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sched_param { pub __sched_priority : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sched_param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sched_param > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( sched_param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sched_param > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sched_param ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __sched_param { pub __sched_priority : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___sched_param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sched_param > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __sched_param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sched_param > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __sched_param ) ) ) ; } pub type __cpu_mask = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct cpu_set_t { pub __bits : [ __cpu_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_cpu_set_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < cpu_set_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( cpu_set_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < cpu_set_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( cpu_set_t ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z16__sched_cpucount" ] pub fn __sched_cpucount ( __setsize : usize , __setp : * const cpu_set_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16__sched_cpualloc" ] pub fn __sched_cpualloc ( __count : usize ) -> * mut cpu_set_t ; } extern "C" { # [ link_name = "\u{1}_Z15__sched_cpufree" ] pub fn __sched_cpufree ( __set : * mut cpu_set_t ) ; } extern "C" { # [ link_name = "\u{1}_Z14sched_setparam" ] pub fn sched_setparam ( __pid : __pid_t , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14sched_getparam" ] pub fn sched_getparam ( __pid : __pid_t , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18sched_setscheduler" ] pub fn sched_setscheduler ( __pid : __pid_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18sched_getscheduler" ] pub fn sched_getscheduler ( __pid : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sched_yield" ] pub fn sched_yield ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22sched_get_priority_max" ] pub fn sched_get_priority_max ( __algorithm : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22sched_get_priority_min" ] pub fn sched_get_priority_min ( __algorithm : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21sched_rr_get_interval" ] pub fn sched_rr_get_interval ( __pid : __pid_t , __t : * mut timespec ) -> :: std :: os :: raw :: c_int ; } pub type __jmp_buf = [ :: std :: os :: raw :: c_long ; 8usize ] ; pub const PTHREAD_CREATE_JOINABLE : _bindgen_ty_9 = 0 ; pub const PTHREAD_CREATE_DETACHED : _bindgen_ty_9 = 1 ; pub type _bindgen_ty_9 = u32 ; pub const PTHREAD_MUTEX_TIMED_NP : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE_NP : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK_NP : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_ADAPTIVE_NP : _bindgen_ty_10 = 3 ; pub const PTHREAD_MUTEX_NORMAL : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_DEFAULT : _bindgen_ty_10 = 0 ; pub type _bindgen_ty_10 = u32 ; pub const PTHREAD_MUTEX_STALLED : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_STALLED_NP : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_ROBUST : _bindgen_ty_11 = 1 ; pub const PTHREAD_MUTEX_ROBUST_NP : _bindgen_ty_11 = 1 ; pub type _bindgen_ty_11 = u32 ; pub const PTHREAD_PRIO_NONE : _bindgen_ty_12 = 0 ; pub const PTHREAD_PRIO_INHERIT : _bindgen_ty_12 = 1 ; pub const PTHREAD_PRIO_PROTECT : _bindgen_ty_12 = 2 ; pub type _bindgen_ty_12 = u32 ; pub const PTHREAD_RWLOCK_PREFER_READER_NP : _bindgen_ty_13 = 0 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NP : _bindgen_ty_13 = 1 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : _bindgen_ty_13 = 2 ; pub const PTHREAD_RWLOCK_DEFAULT_NP : _bindgen_ty_13 = 0 ; pub type _bindgen_ty_13 = u32 ; pub const PTHREAD_INHERIT_SCHED : _bindgen_ty_14 = 0 ; pub const PTHREAD_EXPLICIT_SCHED : _bindgen_ty_14 = 1 ; pub type _bindgen_ty_14 = u32 ; pub const PTHREAD_SCOPE_SYSTEM : _bindgen_ty_15 = 0 ; pub const PTHREAD_SCOPE_PROCESS : _bindgen_ty_15 = 1 ; pub type _bindgen_ty_15 = u32 ; pub const PTHREAD_PROCESS_PRIVATE : _bindgen_ty_16 = 0 ; pub const PTHREAD_PROCESS_SHARED : _bindgen_ty_16 = 1 ; pub type _bindgen_ty_16 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _pthread_cleanup_buffer { pub __routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __arg : * mut :: std :: os :: raw :: c_void , pub __canceltype : :: std :: os :: raw :: c_int , pub __prev : * mut _pthread_cleanup_buffer , } # [ test ] fn bindgen_test_layout__pthread_cleanup_buffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _pthread_cleanup_buffer > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _pthread_cleanup_buffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ) ) ; } impl Default for _pthread_cleanup_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const PTHREAD_CANCEL_ENABLE : _bindgen_ty_17 = 0 ; pub const PTHREAD_CANCEL_DISABLE : _bindgen_ty_17 = 1 ; pub type _bindgen_ty_17 = u32 ; pub const PTHREAD_CANCEL_DEFERRED : _bindgen_ty_18 = 0 ; pub const PTHREAD_CANCEL_ASYNCHRONOUS : _bindgen_ty_18 = 1 ; pub type _bindgen_ty_18 = u32 ; extern "C" { # [ link_name = "\u{1}_Z14pthread_create" ] pub fn pthread_create ( __newthread : * mut pthread_t , __attr : * const pthread_attr_t , __start_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_exit" ] pub fn pthread_exit ( __retval : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_join" ] pub fn pthread_join ( __th : pthread_t , __thread_return : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14pthread_detach" ] pub fn pthread_detach ( __th : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_self" ] pub fn pthread_self ( ) -> pthread_t ; } extern "C" { # [ link_name = "\u{1}_Z13pthread_equal" ] pub fn pthread_equal ( __thread1 : pthread_t , __thread2 : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_attr_init" ] pub fn pthread_attr_init ( __attr : * mut pthread_attr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_attr_destroy" ] pub fn pthread_attr_destroy ( __attr : * mut pthread_attr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_getdetachstate" ] pub fn pthread_attr_getdetachstate ( __attr : * const pthread_attr_t , __detachstate : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_setdetachstate" ] pub fn pthread_attr_setdetachstate ( __attr : * mut pthread_attr_t , __detachstate : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_getguardsize" ] pub fn pthread_attr_getguardsize ( __attr : * const pthread_attr_t , __guardsize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_setguardsize" ] pub fn pthread_attr_setguardsize ( __attr : * mut pthread_attr_t , __guardsize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_attr_getschedparam" ] pub fn pthread_attr_getschedparam ( __attr : * const pthread_attr_t , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_attr_setschedparam" ] pub fn pthread_attr_setschedparam ( __attr : * mut pthread_attr_t , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_getschedpolicy" ] pub fn pthread_attr_getschedpolicy ( __attr : * const pthread_attr_t , __policy : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_setschedpolicy" ] pub fn pthread_attr_setschedpolicy ( __attr : * mut pthread_attr_t , __policy : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_attr_getinheritsched" ] pub fn pthread_attr_getinheritsched ( __attr : * const pthread_attr_t , __inherit : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_attr_setinheritsched" ] pub fn pthread_attr_setinheritsched ( __attr : * mut pthread_attr_t , __inherit : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_getscope" ] pub fn pthread_attr_getscope ( __attr : * const pthread_attr_t , __scope : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_setscope" ] pub fn pthread_attr_setscope ( __attr : * mut pthread_attr_t , __scope : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_getstackaddr" ] pub fn pthread_attr_getstackaddr ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_setstackaddr" ] pub fn pthread_attr_setstackaddr ( __attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_getstacksize" ] pub fn pthread_attr_getstacksize ( __attr : * const pthread_attr_t , __stacksize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_setstacksize" ] pub fn pthread_attr_setstacksize ( __attr : * mut pthread_attr_t , __stacksize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_getstack" ] pub fn pthread_attr_getstack ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void , __stacksize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_setstack" ] pub fn pthread_attr_setstack ( __attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void , __stacksize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_setschedparam" ] pub fn pthread_setschedparam ( __target_thread : pthread_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_getschedparam" ] pub fn pthread_getschedparam ( __target_thread : pthread_t , __policy : * mut :: std :: os :: raw :: c_int , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_setschedprio" ] pub fn pthread_setschedprio ( __target_thread : pthread_t , __prio : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_once" ] pub fn pthread_once ( __once_control : * mut pthread_once_t , __init_routine : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_setcancelstate" ] pub fn pthread_setcancelstate ( __state : :: std :: os :: raw :: c_int , __oldstate : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_setcanceltype" ] pub fn pthread_setcanceltype ( __type : :: std :: os :: raw :: c_int , __oldtype : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14pthread_cancel" ] pub fn pthread_cancel ( __th : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_testcancel" ] pub fn pthread_testcancel ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_unwind_buf_t { pub __cancel_jmp_buf : [ __pthread_unwind_buf_t__bindgen_ty_1 ; 1usize ] , pub __pad : [ * mut :: std :: os :: raw :: c_void ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_unwind_buf_t__bindgen_ty_1 { pub __cancel_jmp_buf : __jmp_buf , pub __mask_was_saved : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_unwind_buf_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_unwind_buf_t > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_unwind_buf_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ) ) ; } impl Default for __pthread_unwind_buf_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cleanup_frame { pub __cancel_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __cancel_arg : * mut :: std :: os :: raw :: c_void , pub __do_it : :: std :: os :: raw :: c_int , pub __cancel_type : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___pthread_cleanup_frame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cleanup_frame > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __pthread_cleanup_frame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cleanup_frame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ) ) ; } impl Default for __pthread_cleanup_frame { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z25__pthread_register_cancel" ] pub fn __pthread_register_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { # [ link_name = "\u{1}_Z27__pthread_unregister_cancel" ] pub fn __pthread_unregister_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { # [ link_name = "\u{1}_Z21__pthread_unwind_next" ] pub fn __pthread_unwind_next ( __buf : * mut __pthread_unwind_buf_t ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __jmp_buf_tag { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_Z11__sigsetjmp" ] pub fn __sigsetjmp ( __env : * mut __jmp_buf_tag , __savemask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_mutex_init" ] pub fn pthread_mutex_init ( __mutex : * mut pthread_mutex_t , __mutexattr : * const pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_mutex_destroy" ] pub fn pthread_mutex_destroy ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_mutex_trylock" ] pub fn pthread_mutex_trylock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_mutex_lock" ] pub fn pthread_mutex_lock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23pthread_mutex_timedlock" ] pub fn pthread_mutex_timedlock ( __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_mutex_unlock" ] pub fn pthread_mutex_unlock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutex_getprioceiling" ] pub fn pthread_mutex_getprioceiling ( __mutex : * const pthread_mutex_t , __prioceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutex_setprioceiling" ] pub fn pthread_mutex_setprioceiling ( __mutex : * mut pthread_mutex_t , __prioceiling : :: std :: os :: raw :: c_int , __old_ceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_mutex_consistent" ] pub fn pthread_mutex_consistent ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_mutexattr_init" ] pub fn pthread_mutexattr_init ( __attr : * mut pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_mutexattr_destroy" ] pub fn pthread_mutexattr_destroy ( __attr : * mut pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutexattr_getpshared" ] pub fn pthread_mutexattr_getpshared ( __attr : * const pthread_mutexattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutexattr_setpshared" ] pub fn pthread_mutexattr_setpshared ( __attr : * mut pthread_mutexattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_mutexattr_gettype" ] pub fn pthread_mutexattr_gettype ( __attr : * const pthread_mutexattr_t , __kind : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_mutexattr_settype" ] pub fn pthread_mutexattr_settype ( __attr : * mut pthread_mutexattr_t , __kind : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_mutexattr_getprotocol" ] pub fn pthread_mutexattr_getprotocol ( __attr : * const pthread_mutexattr_t , __protocol : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_mutexattr_setprotocol" ] pub fn pthread_mutexattr_setprotocol ( __attr : * mut pthread_mutexattr_t , __protocol : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z32pthread_mutexattr_getprioceiling" ] pub fn pthread_mutexattr_getprioceiling ( __attr : * const pthread_mutexattr_t , __prioceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z32pthread_mutexattr_setprioceiling" ] pub fn pthread_mutexattr_setprioceiling ( __attr : * mut pthread_mutexattr_t , __prioceiling : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_mutexattr_getrobust" ] pub fn pthread_mutexattr_getrobust ( __attr : * const pthread_mutexattr_t , __robustness : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_mutexattr_setrobust" ] pub fn pthread_mutexattr_setrobust ( __attr : * mut pthread_mutexattr_t , __robustness : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_rwlock_init" ] pub fn pthread_rwlock_init ( __rwlock : * mut pthread_rwlock_t , __attr : * const pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_rwlock_destroy" ] pub fn pthread_rwlock_destroy ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_rwlock_rdlock" ] pub fn pthread_rwlock_rdlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_rwlock_tryrdlock" ] pub fn pthread_rwlock_tryrdlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_rwlock_timedrdlock" ] pub fn pthread_rwlock_timedrdlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_rwlock_wrlock" ] pub fn pthread_rwlock_wrlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_rwlock_trywrlock" ] pub fn pthread_rwlock_trywrlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_rwlock_timedwrlock" ] pub fn pthread_rwlock_timedwrlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_rwlock_unlock" ] pub fn pthread_rwlock_unlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23pthread_rwlockattr_init" ] pub fn pthread_rwlockattr_init ( __attr : * mut pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_rwlockattr_destroy" ] pub fn pthread_rwlockattr_destroy ( __attr : * mut pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_getpshared" ] pub fn pthread_rwlockattr_getpshared ( __attr : * const pthread_rwlockattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_setpshared" ] pub fn pthread_rwlockattr_setpshared ( __attr : * mut pthread_rwlockattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_getkind_np" ] pub fn pthread_rwlockattr_getkind_np ( __attr : * const pthread_rwlockattr_t , __pref : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_setkind_np" ] pub fn pthread_rwlockattr_setkind_np ( __attr : * mut pthread_rwlockattr_t , __pref : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_cond_init" ] pub fn pthread_cond_init ( __cond : * mut pthread_cond_t , __cond_attr : * const pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_cond_destroy" ] pub fn pthread_cond_destroy ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_cond_signal" ] pub fn pthread_cond_signal ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_cond_broadcast" ] pub fn pthread_cond_broadcast ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_cond_wait" ] pub fn pthread_cond_wait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_cond_timedwait" ] pub fn pthread_cond_timedwait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_condattr_init" ] pub fn pthread_condattr_init ( __attr : * mut pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_condattr_destroy" ] pub fn pthread_condattr_destroy ( __attr : * mut pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_condattr_getpshared" ] pub fn pthread_condattr_getpshared ( __attr : * const pthread_condattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_condattr_setpshared" ] pub fn pthread_condattr_setpshared ( __attr : * mut pthread_condattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_condattr_getclock" ] pub fn pthread_condattr_getclock ( __attr : * const pthread_condattr_t , __clock_id : * mut __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_condattr_setclock" ] pub fn pthread_condattr_setclock ( __attr : * mut pthread_condattr_t , __clock_id : __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_spin_init" ] pub fn pthread_spin_init ( __lock : * mut pthread_spinlock_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_spin_destroy" ] pub fn pthread_spin_destroy ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_spin_lock" ] pub fn pthread_spin_lock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_spin_trylock" ] pub fn pthread_spin_trylock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_spin_unlock" ] pub fn pthread_spin_unlock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_barrier_init" ] pub fn pthread_barrier_init ( __barrier : * mut pthread_barrier_t , __attr : * const pthread_barrierattr_t , __count : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23pthread_barrier_destroy" ] pub fn pthread_barrier_destroy ( __barrier : * mut pthread_barrier_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_barrier_wait" ] pub fn pthread_barrier_wait ( __barrier : * mut pthread_barrier_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_barrierattr_init" ] pub fn pthread_barrierattr_init ( __attr : * mut pthread_barrierattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_barrierattr_destroy" ] pub fn pthread_barrierattr_destroy ( __attr : * mut pthread_barrierattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z30pthread_barrierattr_getpshared" ] pub fn pthread_barrierattr_getpshared ( __attr : * const pthread_barrierattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z30pthread_barrierattr_setpshared" ] pub fn pthread_barrierattr_setpshared ( __attr : * mut pthread_barrierattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_key_create" ] pub fn pthread_key_create ( __key : * mut pthread_key_t , __destr_function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_key_delete" ] pub fn pthread_key_delete ( __key : pthread_key_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_getspecific" ] pub fn pthread_getspecific ( __key : pthread_key_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_setspecific" ] pub fn pthread_setspecific ( __key : pthread_key_t , __pointer : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_getcpuclockid" ] pub fn pthread_getcpuclockid ( __thread_id : pthread_t , __clock_id : * mut __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14pthread_atfork" ] pub fn pthread_atfork ( __prepare : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __parent : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __child : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sem_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_sem_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sem_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( sem_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sem_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sem_t ) ) ) ; } impl Default for sem_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z8sem_init" ] pub fn sem_init ( __sem : * mut sem_t , __pshared : :: std :: os :: raw :: c_int , __value : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sem_destroy" ] pub fn sem_destroy ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sem_open" ] pub fn sem_open ( __name : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , ... ) -> * mut sem_t ; } extern "C" { # [ link_name = "\u{1}_Z9sem_close" ] pub fn sem_close ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sem_unlink" ] pub fn sem_unlink ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sem_wait" ] pub fn sem_wait ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13sem_timedwait" ] pub fn sem_timedwait ( __sem : * mut sem_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sem_trywait" ] pub fn sem_trywait ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sem_post" ] pub fn sem_post ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12sem_getvalue" ] pub fn sem_getvalue ( __sem : * mut sem_t , __sval : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13__sigismember" ] pub fn __sigismember ( arg1 : * const __sigset_t , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__sigaddset" ] pub fn __sigaddset ( arg1 : * mut __sigset_t , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__sigdelset" ] pub fn __sigdelset ( arg1 : * mut __sigset_t , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type sig_atomic_t = __sig_atomic_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigval { pub sival_int : :: std :: os :: raw :: c_int , pub sival_ptr : * mut :: std :: os :: raw :: c_void , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigval > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigval ) ) ) ; } impl Default for sigval { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type sigval_t = sigval ; pub type __sigchld_clock_t = __clock_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t { pub si_signo : :: std :: os :: raw :: c_int , pub si_errno : :: std :: os :: raw :: c_int , pub si_code : :: std :: os :: raw :: c_int , pub _sifields : siginfo_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1 { pub _pad : [ :: std :: os :: raw :: c_int ; 28usize ] , pub _kill : siginfo_t__bindgen_ty_1__bindgen_ty_1 , pub _timer : siginfo_t__bindgen_ty_1__bindgen_ty_2 , pub _rt : siginfo_t__bindgen_ty_1__bindgen_ty_3 , pub _sigchld : siginfo_t__bindgen_ty_1__bindgen_ty_4 , pub _sigfault : siginfo_t__bindgen_ty_1__bindgen_ty_5 , pub _sigpoll : siginfo_t__bindgen_ty_1__bindgen_ty_6 , pub _sigsys : siginfo_t__bindgen_ty_1__bindgen_ty_7 , _bindgen_union_align : [ u64 ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid : __pid_t , pub si_uid : __uid_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid : :: std :: os :: raw :: c_int , pub si_overrun : :: std :: os :: raw :: c_int , pub si_sigval : sigval_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_sigval : sigval_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_status : :: std :: os :: raw :: c_int , pub si_utime : __sigchld_clock_t , pub si_stime : __sigchld_clock_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band : :: std :: os :: raw :: c_long , pub si_fd : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr : * mut :: std :: os :: raw :: c_void , pub _syscall : :: std :: os :: raw :: c_int , pub _arch : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1 > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_siginfo_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( siginfo_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t ) ) ) ; } impl Default for siginfo_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const SI_ASYNCNL : _bindgen_ty_19 = -60 ; pub const SI_TKILL : _bindgen_ty_19 = -6 ; pub const SI_SIGIO : _bindgen_ty_19 = -5 ; pub const SI_ASYNCIO : _bindgen_ty_19 = -4 ; pub const SI_MESGQ : _bindgen_ty_19 = -3 ; pub const SI_TIMER : _bindgen_ty_19 = -2 ; pub const SI_QUEUE : _bindgen_ty_19 = -1 ; pub const SI_USER : _bindgen_ty_19 = 0 ; pub const SI_KERNEL : _bindgen_ty_19 = 128 ; pub type _bindgen_ty_19 = i32 ; pub const ILL_ILLOPC : _bindgen_ty_20 = 1 ; pub const ILL_ILLOPN : _bindgen_ty_20 = 2 ; pub const ILL_ILLADR : _bindgen_ty_20 = 3 ; pub const ILL_ILLTRP : _bindgen_ty_20 = 4 ; pub const ILL_PRVOPC : _bindgen_ty_20 = 5 ; pub const ILL_PRVREG : _bindgen_ty_20 = 6 ; pub const ILL_COPROC : _bindgen_ty_20 = 7 ; pub const ILL_BADSTK : _bindgen_ty_20 = 8 ; pub type _bindgen_ty_20 = u32 ; pub const FPE_INTDIV : _bindgen_ty_21 = 1 ; pub const FPE_INTOVF : _bindgen_ty_21 = 2 ; pub const FPE_FLTDIV : _bindgen_ty_21 = 3 ; pub const FPE_FLTOVF : _bindgen_ty_21 = 4 ; pub const FPE_FLTUND : _bindgen_ty_21 = 5 ; pub const FPE_FLTRES : _bindgen_ty_21 = 6 ; pub const FPE_FLTINV : _bindgen_ty_21 = 7 ; pub const FPE_FLTSUB : _bindgen_ty_21 = 8 ; pub type _bindgen_ty_21 = u32 ; pub const SEGV_MAPERR : _bindgen_ty_22 = 1 ; pub const SEGV_ACCERR : _bindgen_ty_22 = 2 ; pub type _bindgen_ty_22 = u32 ; pub const BUS_ADRALN : _bindgen_ty_23 = 1 ; pub const BUS_ADRERR : _bindgen_ty_23 = 2 ; pub const BUS_OBJERR : _bindgen_ty_23 = 3 ; pub type _bindgen_ty_23 = u32 ; pub const TRAP_BRKPT : _bindgen_ty_24 = 1 ; pub const TRAP_TRACE : _bindgen_ty_24 = 2 ; pub type _bindgen_ty_24 = u32 ; pub const CLD_EXITED : _bindgen_ty_25 = 1 ; pub const CLD_KILLED : _bindgen_ty_25 = 2 ; pub const CLD_DUMPED : _bindgen_ty_25 = 3 ; pub const CLD_TRAPPED : _bindgen_ty_25 = 4 ; pub const CLD_STOPPED : _bindgen_ty_25 = 5 ; pub const CLD_CONTINUED : _bindgen_ty_25 = 6 ; pub type _bindgen_ty_25 = u32 ; pub const POLL_IN : _bindgen_ty_26 = 1 ; pub const POLL_OUT : _bindgen_ty_26 = 2 ; pub const POLL_MSG : _bindgen_ty_26 = 3 ; pub const POLL_ERR : _bindgen_ty_26 = 4 ; pub const POLL_PRI : _bindgen_ty_26 = 5 ; pub const POLL_HUP : _bindgen_ty_26 = 6 ; pub type _bindgen_ty_26 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigevent { pub sigev_value : sigval_t , pub sigev_signo : :: std :: os :: raw :: c_int , pub sigev_notify : :: std :: os :: raw :: c_int , pub _sigev_un : sigevent__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigevent__bindgen_ty_1 { pub _pad : [ :: std :: os :: raw :: c_int ; 12usize ] , pub _tid : __pid_t , pub _sigev_thread : sigevent__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : sigval_t ) > , pub _attribute : * mut pthread_attr_t , } # [ test ] fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigevent__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ) ) ; } impl Default for sigevent__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigevent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( sigevent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent ) ) ) ; } impl Default for sigevent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type sigevent_t = sigevent ; pub const SIGEV_SIGNAL : _bindgen_ty_27 = 0 ; pub const SIGEV_NONE : _bindgen_ty_27 = 1 ; pub const SIGEV_THREAD : _bindgen_ty_27 = 2 ; pub const SIGEV_THREAD_ID : _bindgen_ty_27 = 4 ; pub type _bindgen_ty_27 = u32 ; pub type __sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > ; extern "C" { # [ link_name = "\u{1}_Z13__sysv_signal" ] pub fn __sysv_signal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { # [ link_name = "\u{1}_Z6signal" ] pub fn signal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { # [ link_name = "\u{1}_Z4kill" ] pub fn kill ( __pid : __pid_t , __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6killpg" ] pub fn killpg ( __pgrp : __pid_t , __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5raise" ] pub fn raise ( __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ssignal" ] pub fn ssignal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { # [ link_name = "\u{1}_Z7gsignal" ] pub fn gsignal ( __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7psignal" ] pub fn psignal ( __sig : :: std :: os :: raw :: c_int , __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z8psiginfo" ] pub fn psiginfo ( __pinfo : * const siginfo_t , __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z10__sigpause" ] pub fn __sigpause ( __sig_or_mask : :: std :: os :: raw :: c_int , __is_sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sigblock" ] pub fn sigblock ( __mask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigsetmask" ] pub fn sigsetmask ( __mask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10siggetmask" ] pub fn siggetmask ( ) -> :: std :: os :: raw :: c_int ; } pub type sig_t = __sighandler_t ; extern "C" { # [ link_name = "\u{1}_Z11sigemptyset" ] pub fn sigemptyset ( __set : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigfillset" ] pub fn sigfillset ( __set : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sigaddset" ] pub fn sigaddset ( __set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sigdelset" ] pub fn sigdelset ( __set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sigismember" ] pub fn sigismember ( __set : * const sigset_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigaction { pub __sigaction_handler : sigaction__bindgen_ty_1 , pub sa_mask : __sigset_t , pub sa_flags : :: std :: os :: raw :: c_int , pub sa_restorer : :: std :: option :: Option < unsafe extern "C" fn ( ) > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigaction__bindgen_ty_1 { pub sa_handler : __sighandler_t , pub sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut siginfo_t , arg3 : * mut :: std :: os :: raw :: c_void ) > , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigaction__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ) ) ; } impl Default for sigaction__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigaction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( sigaction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction ) ) ) ; } impl Default for sigaction { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z11sigprocmask" ] pub fn sigprocmask ( __how : :: std :: os :: raw :: c_int , __set : * const sigset_t , __oset : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigsuspend" ] pub fn sigsuspend ( __set : * const sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sigaction" ] pub fn sigaction ( __sig : :: std :: os :: raw :: c_int , __act : * const sigaction , __oact : * mut sigaction ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigpending" ] pub fn sigpending ( __set : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7sigwait" ] pub fn sigwait ( __set : * const sigset_t , __sig : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sigwaitinfo" ] pub fn sigwaitinfo ( __set : * const sigset_t , __info : * mut siginfo_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12sigtimedwait" ] pub fn sigtimedwait ( __set : * const sigset_t , __info : * mut siginfo_t , __timeout : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sigqueue" ] pub fn sigqueue ( __pid : __pid_t , __sig : :: std :: os :: raw :: c_int , __val : sigval ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigvec { pub sv_handler : __sighandler_t , pub sv_mask : :: std :: os :: raw :: c_int , pub sv_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigvec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigvec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigvec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigvec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigvec ) ) ) ; } impl Default for sigvec { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z6sigvec" ] pub fn sigvec ( __sig : :: std :: os :: raw :: c_int , __vec : * const sigvec , __ovec : * mut sigvec ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpx_sw_bytes { pub magic1 : __uint32_t , pub extended_size : __uint32_t , pub xstate_bv : __uint64_t , pub xstate_size : __uint32_t , pub padding : [ __uint32_t ; 7usize ] , } # [ test ] fn bindgen_test_layout__fpx_sw_bytes ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpx_sw_bytes > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _fpx_sw_bytes ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpx_sw_bytes > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _fpx_sw_bytes ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout__fpreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpreg > ( ) , 10usize , concat ! ( "Size of: " , stringify ! ( _fpreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _fpreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpxreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , pub padding : [ :: std :: os :: raw :: c_ushort ; 3usize ] , } # [ test ] fn bindgen_test_layout__fpxreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpxreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _fpxreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpxreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _fpxreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ test ] fn bindgen_test_layout__xmmreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmmreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _xmmreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmmreg > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _xmmreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _fpxreg ; 8usize ] , pub _xmm : [ _xmmreg ; 16usize ] , pub padding : [ __uint32_t ; 24usize ] , } # [ test ] fn bindgen_test_layout__fpstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpstate > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( _fpstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _fpstate ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigcontext { pub r8 : __uint64_t , pub r9 : __uint64_t , pub r10 : __uint64_t , pub r11 : __uint64_t , pub r12 : __uint64_t , pub r13 : __uint64_t , pub r14 : __uint64_t , pub r15 : __uint64_t , pub rdi : __uint64_t , pub rsi : __uint64_t , pub rbp : __uint64_t , pub rbx : __uint64_t , pub rdx : __uint64_t , pub rax : __uint64_t , pub rcx : __uint64_t , pub rsp : __uint64_t , pub rip : __uint64_t , pub eflags : __uint64_t , pub cs : :: std :: os :: raw :: c_ushort , pub gs : :: std :: os :: raw :: c_ushort , pub fs : :: std :: os :: raw :: c_ushort , pub __pad0 : :: std :: os :: raw :: c_ushort , pub err : __uint64_t , pub trapno : __uint64_t , pub oldmask : __uint64_t , pub cr2 : __uint64_t , pub __bindgen_anon_1 : sigcontext__bindgen_ty_1 , pub __reserved1 : [ __uint64_t ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigcontext__bindgen_ty_1 { pub fpstate : * mut _fpstate , pub __fpstate_word : __uint64_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigcontext__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigcontext__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigcontext__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ) ) ; } impl Default for sigcontext__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigcontext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigcontext > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( sigcontext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigcontext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigcontext ) ) ) ; } impl Default for sigcontext { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xsave_hdr { pub xstate_bv : __uint64_t , pub reserved1 : [ __uint64_t ; 2usize ] , pub reserved2 : [ __uint64_t ; 5usize ] , } # [ test ] fn bindgen_test_layout__xsave_hdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xsave_hdr > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( _xsave_hdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xsave_hdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xsave_hdr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _ymmh_state { pub ymmh_space : [ __uint32_t ; 64usize ] , } # [ test ] fn bindgen_test_layout__ymmh_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _ymmh_state > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( _ymmh_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _ymmh_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _ymmh_state ) ) ) ; } impl Default for _ymmh_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _xstate { pub fpstate : _fpstate , pub xstate_hdr : _xsave_hdr , pub ymmh : _ymmh_state , } # [ test ] fn bindgen_test_layout__xstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xstate > ( ) , 832usize , concat ! ( "Size of: " , stringify ! ( _xstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xstate ) ) ) ; } impl Default for _xstate { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z9sigreturn" ] pub fn sigreturn ( __scp : * mut sigcontext ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12siginterrupt" ] pub fn siginterrupt ( __sig : :: std :: os :: raw :: c_int , __interrupt : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_onstack : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigstack > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigstack ) ) ) ; } impl Default for sigstack { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const SS_ONSTACK : _bindgen_ty_28 = 1 ; pub const SS_DISABLE : _bindgen_ty_28 = 2 ; pub type _bindgen_ty_28 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigaltstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_flags : :: std :: os :: raw :: c_int , pub ss_size : usize , } # [ test ] fn bindgen_test_layout_sigaltstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaltstack > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( sigaltstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaltstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaltstack ) ) ) ; } impl Default for sigaltstack { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type stack_t = sigaltstack ; pub type greg_t = :: std :: os :: raw :: c_longlong ; pub type gregset_t = [ greg_t ; 23usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpxreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , pub padding : [ :: std :: os :: raw :: c_ushort ; 3usize ] , } # [ test ] fn bindgen_test_layout__libc_fpxreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_fpxreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _libc_fpxreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_fpxreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _libc_fpxreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ test ] fn bindgen_test_layout__libc_xmmreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_xmmreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _libc_xmmreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_xmmreg > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _libc_xmmreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _libc_fpxreg ; 8usize ] , pub _xmm : [ _libc_xmmreg ; 16usize ] , pub padding : [ __uint32_t ; 24usize ] , } # [ test ] fn bindgen_test_layout__libc_fpstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_fpstate > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( _libc_fpstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_fpstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _libc_fpstate ) ) ) ; } pub type fpregset_t = * mut _libc_fpstate ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mcontext_t { pub gregs : gregset_t , pub fpregs : fpregset_t , pub __reserved1 : [ :: std :: os :: raw :: c_ulonglong ; 8usize ] , } # [ test ] fn bindgen_test_layout_mcontext_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mcontext_t > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( mcontext_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mcontext_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( mcontext_t ) ) ) ; } impl Default for mcontext_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ucontext { pub uc_flags : :: std :: os :: raw :: c_ulong , pub uc_link : * mut ucontext , pub uc_stack : stack_t , pub uc_mcontext : mcontext_t , pub uc_sigmask : __sigset_t , pub __fpregs_mem : _libc_fpstate , } # [ test ] fn bindgen_test_layout_ucontext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ucontext > ( ) , 936usize , concat ! ( "Size of: " , stringify ! ( ucontext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ucontext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ucontext ) ) ) ; } impl Default for ucontext { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type ucontext_t = ucontext ; extern "C" { # [ link_name = "\u{1}_Z8sigstack" ] pub fn sigstack ( __ss : * mut sigstack , __oss : * mut sigstack ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sigaltstack" ] pub fn sigaltstack ( __ss : * const sigaltstack , __oss : * mut sigaltstack ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15pthread_sigmask" ] pub fn pthread_sigmask ( __how : :: std :: os :: raw :: c_int , __newmask : * const __sigset_t , __oldmask : * mut __sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_kill" ] pub fn pthread_kill ( __threadid : pthread_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23__libc_current_sigrtmin" ] pub fn __libc_current_sigrtmin ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23__libc_current_sigrtmax" ] pub fn __libc_current_sigrtmax ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8closelog" ] pub fn closelog ( ) ; } extern "C" { # [ link_name = "\u{1}_Z7openlog" ] pub fn openlog ( __ident : * const :: std :: os :: raw :: c_char , __option : :: std :: os :: raw :: c_int , __facility : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10setlogmask" ] pub fn setlogmask ( __mask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6syslog" ] pub fn syslog ( __pri : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { # [ link_name = "\u{1}_Z7vsyslog" ] pub fn vsyslog ( __pri : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __ap : * mut __va_list_tag ) ; } pub type cc_t = :: std :: os :: raw :: c_uchar ; pub type speed_t = :: std :: os :: raw :: c_uint ; pub type tcflag_t = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termios { pub c_iflag : tcflag_t , pub c_oflag : tcflag_t , pub c_cflag : tcflag_t , pub c_lflag : tcflag_t , pub c_line : cc_t , pub c_cc : [ cc_t ; 32usize ] , pub c_ispeed : speed_t , pub c_ospeed : speed_t , } # [ test ] fn bindgen_test_layout_termios ( ) { assert_eq ! ( :: std :: mem :: size_of :: < termios > ( ) , 60usize , concat ! ( "Size of: " , stringify ! ( termios ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < termios > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( termios ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z11cfgetospeed" ] pub fn cfgetospeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { # [ link_name = "\u{1}_Z11cfgetispeed" ] pub fn cfgetispeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { # [ link_name = "\u{1}_Z11cfsetospeed" ] pub fn cfsetospeed ( __termios_p : * mut termios , __speed : speed_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11cfsetispeed" ] pub fn cfsetispeed ( __termios_p : * mut termios , __speed : speed_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10cfsetspeed" ] pub fn cfsetspeed ( __termios_p : * mut termios , __speed : speed_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tcgetattr" ] pub fn tcgetattr ( __fd : :: std :: os :: raw :: c_int , __termios_p : * mut termios ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tcsetattr" ] pub fn tcsetattr ( __fd : :: std :: os :: raw :: c_int , __optional_actions : :: std :: os :: raw :: c_int , __termios_p : * const termios ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9cfmakeraw" ] pub fn cfmakeraw ( __termios_p : * mut termios ) ; } extern "C" { # [ link_name = "\u{1}_Z11tcsendbreak" ] pub fn tcsendbreak ( __fd : :: std :: os :: raw :: c_int , __duration : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tcdrain" ] pub fn tcdrain ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tcflush" ] pub fn tcflush ( __fd : :: std :: os :: raw :: c_int , __queue_selector : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6tcflow" ] pub fn tcflow ( __fd : :: std :: os :: raw :: c_int , __action : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8tcgetsid" ] pub fn tcgetsid ( __fd : :: std :: os :: raw :: c_int ) -> __pid_t ; } pub type useconds_t = __useconds_t ; extern "C" { # [ link_name = "\u{1}_Z6access" ] pub fn access ( __name : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9faccessat" ] pub fn faccessat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5lseek" ] pub fn lseek ( __fd : :: std :: os :: raw :: c_int , __offset : __off_t , __whence : :: std :: os :: raw :: c_int ) -> __off_t ; } extern "C" { # [ link_name = "\u{1}_Z5close" ] pub fn close ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4read" ] pub fn read ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z5write" ] pub fn write ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z5pread" ] pub fn pread ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize , __offset : __off_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6pwrite" ] pub fn pwrite ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __offset : __off_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z4pipe" ] pub fn pipe ( __pipedes : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5alarm" ] pub fn alarm ( __seconds : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z5sleep" ] pub fn sleep ( __seconds : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z6ualarm" ] pub fn ualarm ( __value : __useconds_t , __interval : __useconds_t ) -> __useconds_t ; } extern "C" { # [ link_name = "\u{1}_Z6usleep" ] pub fn usleep ( __useconds : __useconds_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5pause" ] pub fn pause ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5chown" ] pub fn chown ( __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fchown" ] pub fn fchown ( __fd : :: std :: os :: raw :: c_int , __owner : __uid_t , __group : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6lchown" ] pub fn lchown ( __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8fchownat" ] pub fn fchownat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5chdir" ] pub fn chdir ( __path : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fchdir" ] pub fn fchdir ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6getcwd" ] pub fn getcwd ( __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5getwd" ] pub fn getwd ( __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z3dup" ] pub fn dup ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4dup2" ] pub fn dup2 ( __fd : :: std :: os :: raw :: c_int , __fd2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execve" ] pub fn execve ( __path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7fexecve" ] pub fn fexecve ( __fd : :: std :: os :: raw :: c_int , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5execv" ] pub fn execv ( __path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execle" ] pub fn execle ( __path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5execl" ] pub fn execl ( __path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execvp" ] pub fn execvp ( __file : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execlp" ] pub fn execlp ( __file : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4nice" ] pub fn nice ( __inc : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5_exit" ] pub fn _exit ( __status : :: std :: os :: raw :: c_int ) ; } pub const _PC_LINK_MAX : _bindgen_ty_29 = 0 ; pub const _PC_MAX_CANON : _bindgen_ty_29 = 1 ; pub const _PC_MAX_INPUT : _bindgen_ty_29 = 2 ; pub const _PC_NAME_MAX : _bindgen_ty_29 = 3 ; pub const _PC_PATH_MAX : _bindgen_ty_29 = 4 ; pub const _PC_PIPE_BUF : _bindgen_ty_29 = 5 ; pub const _PC_CHOWN_RESTRICTED : _bindgen_ty_29 = 6 ; pub const _PC_NO_TRUNC : _bindgen_ty_29 = 7 ; pub const _PC_VDISABLE : _bindgen_ty_29 = 8 ; pub const _PC_SYNC_IO : _bindgen_ty_29 = 9 ; pub const _PC_ASYNC_IO : _bindgen_ty_29 = 10 ; pub const _PC_PRIO_IO : _bindgen_ty_29 = 11 ; pub const _PC_SOCK_MAXBUF : _bindgen_ty_29 = 12 ; pub const _PC_FILESIZEBITS : _bindgen_ty_29 = 13 ; pub const _PC_REC_INCR_XFER_SIZE : _bindgen_ty_29 = 14 ; pub const _PC_REC_MAX_XFER_SIZE : _bindgen_ty_29 = 15 ; pub const _PC_REC_MIN_XFER_SIZE : _bindgen_ty_29 = 16 ; pub const _PC_REC_XFER_ALIGN : _bindgen_ty_29 = 17 ; pub const _PC_ALLOC_SIZE_MIN : _bindgen_ty_29 = 18 ; pub const _PC_SYMLINK_MAX : _bindgen_ty_29 = 19 ; pub const _PC_2_SYMLINKS : _bindgen_ty_29 = 20 ; pub type _bindgen_ty_29 = u32 ; pub const _SC_ARG_MAX : _bindgen_ty_30 = 0 ; pub const _SC_CHILD_MAX : _bindgen_ty_30 = 1 ; pub const _SC_CLK_TCK : _bindgen_ty_30 = 2 ; pub const _SC_NGROUPS_MAX : _bindgen_ty_30 = 3 ; pub const _SC_OPEN_MAX : _bindgen_ty_30 = 4 ; pub const _SC_STREAM_MAX : _bindgen_ty_30 = 5 ; pub const _SC_TZNAME_MAX : _bindgen_ty_30 = 6 ; pub const _SC_JOB_CONTROL : _bindgen_ty_30 = 7 ; pub const _SC_SAVED_IDS : _bindgen_ty_30 = 8 ; pub const _SC_REALTIME_SIGNALS : _bindgen_ty_30 = 9 ; pub const _SC_PRIORITY_SCHEDULING : _bindgen_ty_30 = 10 ; pub const _SC_TIMERS : _bindgen_ty_30 = 11 ; pub const _SC_ASYNCHRONOUS_IO : _bindgen_ty_30 = 12 ; pub const _SC_PRIORITIZED_IO : _bindgen_ty_30 = 13 ; pub const _SC_SYNCHRONIZED_IO : _bindgen_ty_30 = 14 ; pub const _SC_FSYNC : _bindgen_ty_30 = 15 ; pub const _SC_MAPPED_FILES : _bindgen_ty_30 = 16 ; pub const _SC_MEMLOCK : _bindgen_ty_30 = 17 ; pub const _SC_MEMLOCK_RANGE : _bindgen_ty_30 = 18 ; pub const _SC_MEMORY_PROTECTION : _bindgen_ty_30 = 19 ; pub const _SC_MESSAGE_PASSING : _bindgen_ty_30 = 20 ; pub const _SC_SEMAPHORES : _bindgen_ty_30 = 21 ; pub const _SC_SHARED_MEMORY_OBJECTS : _bindgen_ty_30 = 22 ; pub const _SC_AIO_LISTIO_MAX : _bindgen_ty_30 = 23 ; pub const _SC_AIO_MAX : _bindgen_ty_30 = 24 ; pub const _SC_AIO_PRIO_DELTA_MAX : _bindgen_ty_30 = 25 ; pub const _SC_DELAYTIMER_MAX : _bindgen_ty_30 = 26 ; pub const _SC_MQ_OPEN_MAX : _bindgen_ty_30 = 27 ; pub const _SC_MQ_PRIO_MAX : _bindgen_ty_30 = 28 ; pub const _SC_VERSION : _bindgen_ty_30 = 29 ; pub const _SC_PAGESIZE : _bindgen_ty_30 = 30 ; pub const _SC_RTSIG_MAX : _bindgen_ty_30 = 31 ; pub const _SC_SEM_NSEMS_MAX : _bindgen_ty_30 = 32 ; pub const _SC_SEM_VALUE_MAX : _bindgen_ty_30 = 33 ; pub const _SC_SIGQUEUE_MAX : _bindgen_ty_30 = 34 ; pub const _SC_TIMER_MAX : _bindgen_ty_30 = 35 ; pub const _SC_BC_BASE_MAX : _bindgen_ty_30 = 36 ; pub const _SC_BC_DIM_MAX : _bindgen_ty_30 = 37 ; pub const _SC_BC_SCALE_MAX : _bindgen_ty_30 = 38 ; pub const _SC_BC_STRING_MAX : _bindgen_ty_30 = 39 ; pub const _SC_COLL_WEIGHTS_MAX : _bindgen_ty_30 = 40 ; pub const _SC_EQUIV_CLASS_MAX : _bindgen_ty_30 = 41 ; pub const _SC_EXPR_NEST_MAX : _bindgen_ty_30 = 42 ; pub const _SC_LINE_MAX : _bindgen_ty_30 = 43 ; pub const _SC_RE_DUP_MAX : _bindgen_ty_30 = 44 ; pub const _SC_CHARCLASS_NAME_MAX : _bindgen_ty_30 = 45 ; pub const _SC_2_VERSION : _bindgen_ty_30 = 46 ; pub const _SC_2_C_BIND : _bindgen_ty_30 = 47 ; pub const _SC_2_C_DEV : _bindgen_ty_30 = 48 ; pub const _SC_2_FORT_DEV : _bindgen_ty_30 = 49 ; pub const _SC_2_FORT_RUN : _bindgen_ty_30 = 50 ; pub const _SC_2_SW_DEV : _bindgen_ty_30 = 51 ; pub const _SC_2_LOCALEDEF : _bindgen_ty_30 = 52 ; pub const _SC_PII : _bindgen_ty_30 = 53 ; pub const _SC_PII_XTI : _bindgen_ty_30 = 54 ; pub const _SC_PII_SOCKET : _bindgen_ty_30 = 55 ; pub const _SC_PII_INTERNET : _bindgen_ty_30 = 56 ; pub const _SC_PII_OSI : _bindgen_ty_30 = 57 ; pub const _SC_POLL : _bindgen_ty_30 = 58 ; pub const _SC_SELECT : _bindgen_ty_30 = 59 ; pub const _SC_UIO_MAXIOV : _bindgen_ty_30 = 60 ; pub const _SC_IOV_MAX : _bindgen_ty_30 = 60 ; pub const _SC_PII_INTERNET_STREAM : _bindgen_ty_30 = 61 ; pub const _SC_PII_INTERNET_DGRAM : _bindgen_ty_30 = 62 ; pub const _SC_PII_OSI_COTS : _bindgen_ty_30 = 63 ; pub const _SC_PII_OSI_CLTS : _bindgen_ty_30 = 64 ; pub const _SC_PII_OSI_M : _bindgen_ty_30 = 65 ; pub const _SC_T_IOV_MAX : _bindgen_ty_30 = 66 ; pub const _SC_THREADS : _bindgen_ty_30 = 67 ; pub const _SC_THREAD_SAFE_FUNCTIONS : _bindgen_ty_30 = 68 ; pub const _SC_GETGR_R_SIZE_MAX : _bindgen_ty_30 = 69 ; pub const _SC_GETPW_R_SIZE_MAX : _bindgen_ty_30 = 70 ; pub const _SC_LOGIN_NAME_MAX : _bindgen_ty_30 = 71 ; pub const _SC_TTY_NAME_MAX : _bindgen_ty_30 = 72 ; pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : _bindgen_ty_30 = 73 ; pub const _SC_THREAD_KEYS_MAX : _bindgen_ty_30 = 74 ; pub const _SC_THREAD_STACK_MIN : _bindgen_ty_30 = 75 ; pub const _SC_THREAD_THREADS_MAX : _bindgen_ty_30 = 76 ; pub const _SC_THREAD_ATTR_STACKADDR : _bindgen_ty_30 = 77 ; pub const _SC_THREAD_ATTR_STACKSIZE : _bindgen_ty_30 = 78 ; pub const _SC_THREAD_PRIORITY_SCHEDULING : _bindgen_ty_30 = 79 ; pub const _SC_THREAD_PRIO_INHERIT : _bindgen_ty_30 = 80 ; pub const _SC_THREAD_PRIO_PROTECT : _bindgen_ty_30 = 81 ; pub const _SC_THREAD_PROCESS_SHARED : _bindgen_ty_30 = 82 ; pub const _SC_NPROCESSORS_CONF : _bindgen_ty_30 = 83 ; pub const _SC_NPROCESSORS_ONLN : _bindgen_ty_30 = 84 ; pub const _SC_PHYS_PAGES : _bindgen_ty_30 = 85 ; pub const _SC_AVPHYS_PAGES : _bindgen_ty_30 = 86 ; pub const _SC_ATEXIT_MAX : _bindgen_ty_30 = 87 ; pub const _SC_PASS_MAX : _bindgen_ty_30 = 88 ; pub const _SC_XOPEN_VERSION : _bindgen_ty_30 = 89 ; pub const _SC_XOPEN_XCU_VERSION : _bindgen_ty_30 = 90 ; pub const _SC_XOPEN_UNIX : _bindgen_ty_30 = 91 ; pub const _SC_XOPEN_CRYPT : _bindgen_ty_30 = 92 ; pub const _SC_XOPEN_ENH_I18N : _bindgen_ty_30 = 93 ; pub const _SC_XOPEN_SHM : _bindgen_ty_30 = 94 ; pub const _SC_2_CHAR_TERM : _bindgen_ty_30 = 95 ; pub const _SC_2_C_VERSION : _bindgen_ty_30 = 96 ; pub const _SC_2_UPE : _bindgen_ty_30 = 97 ; pub const _SC_XOPEN_XPG2 : _bindgen_ty_30 = 98 ; pub const _SC_XOPEN_XPG3 : _bindgen_ty_30 = 99 ; pub const _SC_XOPEN_XPG4 : _bindgen_ty_30 = 100 ; pub const _SC_CHAR_BIT : _bindgen_ty_30 = 101 ; pub const _SC_CHAR_MAX : _bindgen_ty_30 = 102 ; pub const _SC_CHAR_MIN : _bindgen_ty_30 = 103 ; pub const _SC_INT_MAX : _bindgen_ty_30 = 104 ; pub const _SC_INT_MIN : _bindgen_ty_30 = 105 ; pub const _SC_LONG_BIT : _bindgen_ty_30 = 106 ; pub const _SC_WORD_BIT : _bindgen_ty_30 = 107 ; pub const _SC_MB_LEN_MAX : _bindgen_ty_30 = 108 ; pub const _SC_NZERO : _bindgen_ty_30 = 109 ; pub const _SC_SSIZE_MAX : _bindgen_ty_30 = 110 ; pub const _SC_SCHAR_MAX : _bindgen_ty_30 = 111 ; pub const _SC_SCHAR_MIN : _bindgen_ty_30 = 112 ; pub const _SC_SHRT_MAX : _bindgen_ty_30 = 113 ; pub const _SC_SHRT_MIN : _bindgen_ty_30 = 114 ; pub const _SC_UCHAR_MAX : _bindgen_ty_30 = 115 ; pub const _SC_UINT_MAX : _bindgen_ty_30 = 116 ; pub const _SC_ULONG_MAX : _bindgen_ty_30 = 117 ; pub const _SC_USHRT_MAX : _bindgen_ty_30 = 118 ; pub const _SC_NL_ARGMAX : _bindgen_ty_30 = 119 ; pub const _SC_NL_LANGMAX : _bindgen_ty_30 = 120 ; pub const _SC_NL_MSGMAX : _bindgen_ty_30 = 121 ; pub const _SC_NL_NMAX : _bindgen_ty_30 = 122 ; pub const _SC_NL_SETMAX : _bindgen_ty_30 = 123 ; pub const _SC_NL_TEXTMAX : _bindgen_ty_30 = 124 ; pub const _SC_XBS5_ILP32_OFF32 : _bindgen_ty_30 = 125 ; pub const _SC_XBS5_ILP32_OFFBIG : _bindgen_ty_30 = 126 ; pub const _SC_XBS5_LP64_OFF64 : _bindgen_ty_30 = 127 ; pub const _SC_XBS5_LPBIG_OFFBIG : _bindgen_ty_30 = 128 ; pub const _SC_XOPEN_LEGACY : _bindgen_ty_30 = 129 ; pub const _SC_XOPEN_REALTIME : _bindgen_ty_30 = 130 ; pub const _SC_XOPEN_REALTIME_THREADS : _bindgen_ty_30 = 131 ; pub const _SC_ADVISORY_INFO : _bindgen_ty_30 = 132 ; pub const _SC_BARRIERS : _bindgen_ty_30 = 133 ; pub const _SC_BASE : _bindgen_ty_30 = 134 ; pub const _SC_C_LANG_SUPPORT : _bindgen_ty_30 = 135 ; pub const _SC_C_LANG_SUPPORT_R : _bindgen_ty_30 = 136 ; pub const _SC_CLOCK_SELECTION : _bindgen_ty_30 = 137 ; pub const _SC_CPUTIME : _bindgen_ty_30 = 138 ; pub const _SC_THREAD_CPUTIME : _bindgen_ty_30 = 139 ; pub const _SC_DEVICE_IO : _bindgen_ty_30 = 140 ; pub const _SC_DEVICE_SPECIFIC : _bindgen_ty_30 = 141 ; pub const _SC_DEVICE_SPECIFIC_R : _bindgen_ty_30 = 142 ; pub const _SC_FD_MGMT : _bindgen_ty_30 = 143 ; pub const _SC_FIFO : _bindgen_ty_30 = 144 ; pub const _SC_PIPE : _bindgen_ty_30 = 145 ; pub const _SC_FILE_ATTRIBUTES : _bindgen_ty_30 = 146 ; pub const _SC_FILE_LOCKING : _bindgen_ty_30 = 147 ; pub const _SC_FILE_SYSTEM : _bindgen_ty_30 = 148 ; pub const _SC_MONOTONIC_CLOCK : _bindgen_ty_30 = 149 ; pub const _SC_MULTI_PROCESS : _bindgen_ty_30 = 150 ; pub const _SC_SINGLE_PROCESS : _bindgen_ty_30 = 151 ; pub const _SC_NETWORKING : _bindgen_ty_30 = 152 ; pub const _SC_READER_WRITER_LOCKS : _bindgen_ty_30 = 153 ; pub const _SC_SPIN_LOCKS : _bindgen_ty_30 = 154 ; pub const _SC_REGEXP : _bindgen_ty_30 = 155 ; pub const _SC_REGEX_VERSION : _bindgen_ty_30 = 156 ; pub const _SC_SHELL : _bindgen_ty_30 = 157 ; pub const _SC_SIGNALS : _bindgen_ty_30 = 158 ; pub const _SC_SPAWN : _bindgen_ty_30 = 159 ; pub const _SC_SPORADIC_SERVER : _bindgen_ty_30 = 160 ; pub const _SC_THREAD_SPORADIC_SERVER : _bindgen_ty_30 = 161 ; pub const _SC_SYSTEM_DATABASE : _bindgen_ty_30 = 162 ; pub const _SC_SYSTEM_DATABASE_R : _bindgen_ty_30 = 163 ; pub const _SC_TIMEOUTS : _bindgen_ty_30 = 164 ; pub const _SC_TYPED_MEMORY_OBJECTS : _bindgen_ty_30 = 165 ; pub const _SC_USER_GROUPS : _bindgen_ty_30 = 166 ; pub const _SC_USER_GROUPS_R : _bindgen_ty_30 = 167 ; pub const _SC_2_PBS : _bindgen_ty_30 = 168 ; pub const _SC_2_PBS_ACCOUNTING : _bindgen_ty_30 = 169 ; pub const _SC_2_PBS_LOCATE : _bindgen_ty_30 = 170 ; pub const _SC_2_PBS_MESSAGE : _bindgen_ty_30 = 171 ; pub const _SC_2_PBS_TRACK : _bindgen_ty_30 = 172 ; pub const _SC_SYMLOOP_MAX : _bindgen_ty_30 = 173 ; pub const _SC_STREAMS : _bindgen_ty_30 = 174 ; pub const _SC_2_PBS_CHECKPOINT : _bindgen_ty_30 = 175 ; pub const _SC_V6_ILP32_OFF32 : _bindgen_ty_30 = 176 ; pub const _SC_V6_ILP32_OFFBIG : _bindgen_ty_30 = 177 ; pub const _SC_V6_LP64_OFF64 : _bindgen_ty_30 = 178 ; pub const _SC_V6_LPBIG_OFFBIG : _bindgen_ty_30 = 179 ; pub const _SC_HOST_NAME_MAX : _bindgen_ty_30 = 180 ; pub const _SC_TRACE : _bindgen_ty_30 = 181 ; pub const _SC_TRACE_EVENT_FILTER : _bindgen_ty_30 = 182 ; pub const _SC_TRACE_INHERIT : _bindgen_ty_30 = 183 ; pub const _SC_TRACE_LOG : _bindgen_ty_30 = 184 ; pub const _SC_LEVEL1_ICACHE_SIZE : _bindgen_ty_30 = 185 ; pub const _SC_LEVEL1_ICACHE_ASSOC : _bindgen_ty_30 = 186 ; pub const _SC_LEVEL1_ICACHE_LINESIZE : _bindgen_ty_30 = 187 ; pub const _SC_LEVEL1_DCACHE_SIZE : _bindgen_ty_30 = 188 ; pub const _SC_LEVEL1_DCACHE_ASSOC : _bindgen_ty_30 = 189 ; pub const _SC_LEVEL1_DCACHE_LINESIZE : _bindgen_ty_30 = 190 ; pub const _SC_LEVEL2_CACHE_SIZE : _bindgen_ty_30 = 191 ; pub const _SC_LEVEL2_CACHE_ASSOC : _bindgen_ty_30 = 192 ; pub const _SC_LEVEL2_CACHE_LINESIZE : _bindgen_ty_30 = 193 ; pub const _SC_LEVEL3_CACHE_SIZE : _bindgen_ty_30 = 194 ; pub const _SC_LEVEL3_CACHE_ASSOC : _bindgen_ty_30 = 195 ; pub const _SC_LEVEL3_CACHE_LINESIZE : _bindgen_ty_30 = 196 ; pub const _SC_LEVEL4_CACHE_SIZE : _bindgen_ty_30 = 197 ; pub const _SC_LEVEL4_CACHE_ASSOC : _bindgen_ty_30 = 198 ; pub const _SC_LEVEL4_CACHE_LINESIZE : _bindgen_ty_30 = 199 ; pub const _SC_IPV6 : _bindgen_ty_30 = 235 ; pub const _SC_RAW_SOCKETS : _bindgen_ty_30 = 236 ; pub const _SC_V7_ILP32_OFF32 : _bindgen_ty_30 = 237 ; pub const _SC_V7_ILP32_OFFBIG : _bindgen_ty_30 = 238 ; pub const _SC_V7_LP64_OFF64 : _bindgen_ty_30 = 239 ; pub const _SC_V7_LPBIG_OFFBIG : _bindgen_ty_30 = 240 ; pub const _SC_SS_REPL_MAX : _bindgen_ty_30 = 241 ; pub const _SC_TRACE_EVENT_NAME_MAX : _bindgen_ty_30 = 242 ; pub const _SC_TRACE_NAME_MAX : _bindgen_ty_30 = 243 ; pub const _SC_TRACE_SYS_MAX : _bindgen_ty_30 = 244 ; pub const _SC_TRACE_USER_EVENT_MAX : _bindgen_ty_30 = 245 ; pub const _SC_XOPEN_STREAMS : _bindgen_ty_30 = 246 ; pub const _SC_THREAD_ROBUST_PRIO_INHERIT : _bindgen_ty_30 = 247 ; pub const _SC_THREAD_ROBUST_PRIO_PROTECT : _bindgen_ty_30 = 248 ; pub type _bindgen_ty_30 = u32 ; pub const _CS_PATH : _bindgen_ty_31 = 0 ; pub const _CS_V6_WIDTH_RESTRICTED_ENVS : _bindgen_ty_31 = 1 ; pub const _CS_GNU_LIBC_VERSION : _bindgen_ty_31 = 2 ; pub const _CS_GNU_LIBPTHREAD_VERSION : _bindgen_ty_31 = 3 ; pub const _CS_V5_WIDTH_RESTRICTED_ENVS : _bindgen_ty_31 = 4 ; pub const _CS_V7_WIDTH_RESTRICTED_ENVS : _bindgen_ty_31 = 5 ; pub const _CS_LFS_CFLAGS : _bindgen_ty_31 = 1000 ; pub const _CS_LFS_LDFLAGS : _bindgen_ty_31 = 1001 ; pub const _CS_LFS_LIBS : _bindgen_ty_31 = 1002 ; pub const _CS_LFS_LINTFLAGS : _bindgen_ty_31 = 1003 ; pub const _CS_LFS64_CFLAGS : _bindgen_ty_31 = 1004 ; pub const _CS_LFS64_LDFLAGS : _bindgen_ty_31 = 1005 ; pub const _CS_LFS64_LIBS : _bindgen_ty_31 = 1006 ; pub const _CS_LFS64_LINTFLAGS : _bindgen_ty_31 = 1007 ; pub const _CS_XBS5_ILP32_OFF32_CFLAGS : _bindgen_ty_31 = 1100 ; pub const _CS_XBS5_ILP32_OFF32_LDFLAGS : _bindgen_ty_31 = 1101 ; pub const _CS_XBS5_ILP32_OFF32_LIBS : _bindgen_ty_31 = 1102 ; pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS : _bindgen_ty_31 = 1103 ; pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS : _bindgen_ty_31 = 1104 ; pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1105 ; pub const _CS_XBS5_ILP32_OFFBIG_LIBS : _bindgen_ty_31 = 1106 ; pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1107 ; pub const _CS_XBS5_LP64_OFF64_CFLAGS : _bindgen_ty_31 = 1108 ; pub const _CS_XBS5_LP64_OFF64_LDFLAGS : _bindgen_ty_31 = 1109 ; pub const _CS_XBS5_LP64_OFF64_LIBS : _bindgen_ty_31 = 1110 ; pub const _CS_XBS5_LP64_OFF64_LINTFLAGS : _bindgen_ty_31 = 1111 ; pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_31 = 1112 ; pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1113 ; pub const _CS_XBS5_LPBIG_OFFBIG_LIBS : _bindgen_ty_31 = 1114 ; pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1115 ; pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS : _bindgen_ty_31 = 1116 ; pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS : _bindgen_ty_31 = 1117 ; pub const _CS_POSIX_V6_ILP32_OFF32_LIBS : _bindgen_ty_31 = 1118 ; pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS : _bindgen_ty_31 = 1119 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS : _bindgen_ty_31 = 1120 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1121 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS : _bindgen_ty_31 = 1122 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1123 ; pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS : _bindgen_ty_31 = 1124 ; pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS : _bindgen_ty_31 = 1125 ; pub const _CS_POSIX_V6_LP64_OFF64_LIBS : _bindgen_ty_31 = 1126 ; pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS : _bindgen_ty_31 = 1127 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_31 = 1128 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1129 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS : _bindgen_ty_31 = 1130 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1131 ; pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS : _bindgen_ty_31 = 1132 ; pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS : _bindgen_ty_31 = 1133 ; pub const _CS_POSIX_V7_ILP32_OFF32_LIBS : _bindgen_ty_31 = 1134 ; pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS : _bindgen_ty_31 = 1135 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS : _bindgen_ty_31 = 1136 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1137 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS : _bindgen_ty_31 = 1138 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1139 ; pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS : _bindgen_ty_31 = 1140 ; pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS : _bindgen_ty_31 = 1141 ; pub const _CS_POSIX_V7_LP64_OFF64_LIBS : _bindgen_ty_31 = 1142 ; pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS : _bindgen_ty_31 = 1143 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_31 = 1144 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1145 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS : _bindgen_ty_31 = 1146 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1147 ; pub const _CS_V6_ENV : _bindgen_ty_31 = 1148 ; pub const _CS_V7_ENV : _bindgen_ty_31 = 1149 ; pub type _bindgen_ty_31 = u32 ; extern "C" { # [ link_name = "\u{1}_Z8pathconf" ] pub fn pathconf ( __path : * const :: std :: os :: raw :: c_char , __name : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z9fpathconf" ] pub fn fpathconf ( __fd : :: std :: os :: raw :: c_int , __name : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7sysconf" ] pub fn sysconf ( __name : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7confstr" ] pub fn confstr ( __name : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6getpid" ] pub fn getpid ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getppid" ] pub fn getppid ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getpgrp" ] pub fn getpgrp ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z9__getpgid" ] pub fn __getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getpgid" ] pub fn getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7setpgid" ] pub fn setpgid ( __pid : __pid_t , __pgid : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7setpgrp" ] pub fn setpgrp ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setsid" ] pub fn setsid ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z6getsid" ] pub fn getsid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z6getuid" ] pub fn getuid ( ) -> __uid_t ; } extern "C" { # [ link_name = "\u{1}_Z7geteuid" ] pub fn geteuid ( ) -> __uid_t ; } extern "C" { # [ link_name = "\u{1}_Z6getgid" ] pub fn getgid ( ) -> __gid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getegid" ] pub fn getegid ( ) -> __gid_t ; } extern "C" { # [ link_name = "\u{1}_Z9getgroups" ] pub fn getgroups ( __size : :: std :: os :: raw :: c_int , __list : * mut __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setuid" ] pub fn setuid ( __uid : __uid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8setreuid" ] pub fn setreuid ( __ruid : __uid_t , __euid : __uid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7seteuid" ] pub fn seteuid ( __uid : __uid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setgid" ] pub fn setgid ( __gid : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8setregid" ] pub fn setregid ( __rgid : __gid_t , __egid : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7setegid" ] pub fn setegid ( __gid : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4fork" ] pub fn fork ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z5vfork" ] pub fn vfork ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7ttyname" ] pub fn ttyname ( __fd : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9ttyname_r" ] pub fn ttyname_r ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6isatty" ] pub fn isatty ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ttyslot" ] pub fn ttyslot ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4link" ] pub fn link ( __from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6linkat" ] pub fn linkat ( __fromfd : :: std :: os :: raw :: c_int , __from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7symlink" ] pub fn symlink ( __from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8readlink" ] pub fn readlink ( __path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z9symlinkat" ] pub fn symlinkat ( __from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10readlinkat" ] pub fn readlinkat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6unlink" ] pub fn unlink ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8unlinkat" ] pub fn unlinkat ( __fd : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5rmdir" ] pub fn rmdir ( __path : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tcgetpgrp" ] pub fn tcgetpgrp ( __fd : :: std :: os :: raw :: c_int ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z9tcsetpgrp" ] pub fn tcsetpgrp ( __fd : :: std :: os :: raw :: c_int , __pgrp_id : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8getlogin" ] pub fn getlogin ( ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z10getlogin_r" ] pub fn getlogin_r ( __name : * mut :: std :: os :: raw :: c_char , __name_len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8setlogin" ] pub fn setlogin ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6getopt" ] pub fn getopt ( ___argc : :: std :: os :: raw :: c_int , ___argv : * const * mut :: std :: os :: raw :: c_char , __shortopts : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11gethostname" ] pub fn gethostname ( __name : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sethostname" ] pub fn sethostname ( __name : * const :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sethostid" ] pub fn sethostid ( __id : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getdomainname" ] pub fn getdomainname ( __name : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13setdomainname" ] pub fn setdomainname ( __name : * const :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vhangup" ] pub fn vhangup ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6revoke" ] pub fn revoke ( __file : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6profil" ] pub fn profil ( __sample_buffer : * mut :: std :: os :: raw :: c_ushort , __size : usize , __offset : usize , __scale : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4acct" ] pub fn acct ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12getusershell" ] pub fn getusershell ( ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z12endusershell" ] pub fn endusershell ( ) ; } extern "C" { # [ link_name = "\u{1}_Z12setusershell" ] pub fn setusershell ( ) ; } extern "C" { # [ link_name = "\u{1}_Z6daemon" ] pub fn daemon ( __nochdir : :: std :: os :: raw :: c_int , __noclose : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6chroot" ] pub fn chroot ( __path : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7getpass" ] pub fn getpass ( __prompt : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5fsync" ] pub fn fsync ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9gethostid" ] pub fn gethostid ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z4sync" ] pub fn sync ( ) ; } extern "C" { # [ link_name = "\u{1}_Z11getpagesize" ] pub fn getpagesize ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getdtablesize" ] pub fn getdtablesize ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8truncate" ] pub fn truncate ( __file : * const :: std :: os :: raw :: c_char , __length : __off_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9ftruncate" ] pub fn ftruncate ( __fd : :: std :: os :: raw :: c_int , __length : __off_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z3brk" ] pub fn brk ( __addr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4sbrk" ] pub fn sbrk ( __delta : isize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7syscall" ] pub fn syscall ( __sysno : :: std :: os :: raw :: c_long , ... ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z9fdatasync" ] pub fn fdatasync ( __fildes : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct if_nameindex { pub if_index : :: std :: os :: raw :: c_uint , pub if_name : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_if_nameindex ( ) { assert_eq ! ( :: std :: mem :: size_of :: < if_nameindex > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( if_nameindex ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < if_nameindex > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( if_nameindex ) ) ) ; } impl Default for if_nameindex { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const IFF_UP : _bindgen_ty_32 = 1 ; pub const IFF_BROADCAST : _bindgen_ty_32 = 2 ; pub const IFF_DEBUG : _bindgen_ty_32 = 4 ; pub const IFF_LOOPBACK : _bindgen_ty_32 = 8 ; pub const IFF_POINTOPOINT : _bindgen_ty_32 = 16 ; pub const IFF_NOTRAILERS : _bindgen_ty_32 = 32 ; pub const IFF_RUNNING : _bindgen_ty_32 = 64 ; pub const IFF_NOARP : _bindgen_ty_32 = 128 ; pub const IFF_PROMISC : _bindgen_ty_32 = 256 ; pub const IFF_ALLMULTI : _bindgen_ty_32 = 512 ; pub const IFF_MASTER : _bindgen_ty_32 = 1024 ; pub const IFF_SLAVE : _bindgen_ty_32 = 2048 ; pub const IFF_MULTICAST : _bindgen_ty_32 = 4096 ; pub const IFF_PORTSEL : _bindgen_ty_32 = 8192 ; pub const IFF_AUTOMEDIA : _bindgen_ty_32 = 16384 ; pub const IFF_DYNAMIC : _bindgen_ty_32 = 32768 ; pub type _bindgen_ty_32 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddr { pub ifa_addr : sockaddr , pub ifa_ifu : ifaddr__bindgen_ty_1 , pub ifa_ifp : * mut iface , pub ifa_next : * mut ifaddr , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddr__bindgen_ty_1 { pub ifu_broadaddr : sockaddr , pub ifu_dstaddr : sockaddr , _bindgen_union_align : [ u16 ; 8usize ] , } # [ test ] fn bindgen_test_layout_ifaddr__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddr__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ifaddr__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddr__bindgen_ty_1 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( ifaddr__bindgen_ty_1 ) ) ) ; } impl Default for ifaddr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddr > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( ifaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifaddr ) ) ) ; } impl Default for ifaddr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ifmap { pub mem_start : :: std :: os :: raw :: c_ulong , pub mem_end : :: std :: os :: raw :: c_ulong , pub base_addr : :: std :: os :: raw :: c_ushort , pub irq : :: std :: os :: raw :: c_uchar , pub dma : :: std :: os :: raw :: c_uchar , pub port : :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_ifmap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifmap > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( ifmap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifmap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifmap ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifreq { pub ifr_ifrn : ifreq__bindgen_ty_1 , pub ifr_ifru : ifreq__bindgen_ty_2 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_1 { pub ifrn_name : [ :: std :: os :: raw :: c_char ; 16usize ] , _bindgen_union_align : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_ifreq__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifreq__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifreq__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( ifreq__bindgen_ty_1 ) ) ) ; } impl Default for ifreq__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_2 { pub ifru_addr : sockaddr , pub ifru_dstaddr : sockaddr , pub ifru_broadaddr : sockaddr , pub ifru_netmask : sockaddr , pub ifru_hwaddr : sockaddr , pub ifru_flags : :: std :: os :: raw :: c_short , pub ifru_ivalue : :: std :: os :: raw :: c_int , pub ifru_mtu : :: std :: os :: raw :: c_int , pub ifru_map : ifmap , pub ifru_slave : [ :: std :: os :: raw :: c_char ; 16usize ] , pub ifru_newname : [ :: std :: os :: raw :: c_char ; 16usize ] , pub ifru_data : __caddr_t , _bindgen_union_align : [ u64 ; 3usize ] , } # [ test ] fn bindgen_test_layout_ifreq__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifreq__bindgen_ty_2 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifreq__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifreq__bindgen_ty_2 ) ) ) ; } impl Default for ifreq__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifreq > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( ifreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifreq > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifreq ) ) ) ; } impl Default for ifreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifconf { pub ifc_len : :: std :: os :: raw :: c_int , pub ifc_ifcu : ifconf__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifconf__bindgen_ty_1 { pub ifcu_buf : __caddr_t , pub ifcu_req : * mut ifreq , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_ifconf__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifconf__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ifconf__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifconf__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifconf__bindgen_ty_1 ) ) ) ; } impl Default for ifconf__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifconf ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifconf > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ifconf ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifconf > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifconf ) ) ) ; } impl Default for ifconf { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z14if_nametoindex" ] pub fn if_nametoindex ( __ifname : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z14if_indextoname" ] pub fn if_indextoname ( __ifindex : :: std :: os :: raw :: c_uint , __ifname : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z12if_nameindex" ] pub fn if_nameindex ( ) -> * mut if_nameindex ; } extern "C" { # [ link_name = "\u{1}_Z16if_freenameindex" ] pub fn if_freenameindex ( __ptr : * mut if_nameindex ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcphdr { pub source : u_int16_t , pub dest : u_int16_t , pub seq : u_int32_t , pub ack_seq : u_int32_t , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub window : u_int16_t , pub check : u_int16_t , pub urg_ptr : u_int16_t , } # [ test ] fn bindgen_test_layout_tcphdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcphdr > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( tcphdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcphdr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( tcphdr ) ) ) ; } impl tcphdr { # [ inline ] pub fn res1 ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_res1 ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn doff ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_doff ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn fin ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_fin ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn syn ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_syn ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rst ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_rst ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn psh ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_psh ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ack ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ack ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn urg ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_urg ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn res2 ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_res2 ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( res1 : u_int16_t , doff : u_int16_t , fin : u_int16_t , syn : u_int16_t , rst : u_int16_t , psh : u_int16_t , ack : u_int16_t , urg : u_int16_t , res2 : u_int16_t ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let res1 : u16 = unsafe { :: std :: mem :: transmute ( res1 ) } ; res1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let doff : u16 = unsafe { :: std :: mem :: transmute ( doff ) } ; doff as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let fin : u16 = unsafe { :: std :: mem :: transmute ( fin ) } ; fin as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let syn : u16 = unsafe { :: std :: mem :: transmute ( syn ) } ; syn as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let rst : u16 = unsafe { :: std :: mem :: transmute ( rst ) } ; rst as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let psh : u16 = unsafe { :: std :: mem :: transmute ( psh ) } ; psh as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ack : u16 = unsafe { :: std :: mem :: transmute ( ack ) } ; ack as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let urg : u16 = unsafe { :: std :: mem :: transmute ( urg ) } ; urg as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let res2 : u16 = unsafe { :: std :: mem :: transmute ( res2 ) } ; res2 as u64 } ) ; __bindgen_bitfield_unit } } pub const TCP_ESTABLISHED : _bindgen_ty_33 = 1 ; pub const TCP_SYN_SENT : _bindgen_ty_33 = 2 ; pub const TCP_SYN_RECV : _bindgen_ty_33 = 3 ; pub const TCP_FIN_WAIT1 : _bindgen_ty_33 = 4 ; pub const TCP_FIN_WAIT2 : _bindgen_ty_33 = 5 ; pub const TCP_TIME_WAIT : _bindgen_ty_33 = 6 ; pub const TCP_CLOSE : _bindgen_ty_33 = 7 ; pub const TCP_CLOSE_WAIT : _bindgen_ty_33 = 8 ; pub const TCP_LAST_ACK : _bindgen_ty_33 = 9 ; pub const TCP_LISTEN : _bindgen_ty_33 = 10 ; pub const TCP_CLOSING : _bindgen_ty_33 = 11 ; pub type _bindgen_ty_33 = u32 ; pub const tcp_ca_state_TCP_CA_Open : tcp_ca_state = 0 ; pub const tcp_ca_state_TCP_CA_Disorder : tcp_ca_state = 1 ; pub const tcp_ca_state_TCP_CA_CWR : tcp_ca_state = 2 ; pub const tcp_ca_state_TCP_CA_Recovery : tcp_ca_state = 3 ; pub const tcp_ca_state_TCP_CA_Loss : tcp_ca_state = 4 ; pub type tcp_ca_state = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_info { pub tcpi_state : u_int8_t , pub tcpi_ca_state : u_int8_t , pub tcpi_retransmits : u_int8_t , pub tcpi_probes : u_int8_t , pub tcpi_backoff : u_int8_t , pub tcpi_options : u_int8_t , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub tcpi_rto : u_int32_t , pub tcpi_ato : u_int32_t , pub tcpi_snd_mss : u_int32_t , pub tcpi_rcv_mss : u_int32_t , pub tcpi_unacked : u_int32_t , pub tcpi_sacked : u_int32_t , pub tcpi_lost : u_int32_t , pub tcpi_retrans : u_int32_t , pub tcpi_fackets : u_int32_t , pub tcpi_last_data_sent : u_int32_t , pub tcpi_last_ack_sent : u_int32_t , pub tcpi_last_data_recv : u_int32_t , pub tcpi_last_ack_recv : u_int32_t , pub tcpi_pmtu : u_int32_t , pub tcpi_rcv_ssthresh : u_int32_t , pub tcpi_rtt : u_int32_t , pub tcpi_rttvar : u_int32_t , pub tcpi_snd_ssthresh : u_int32_t , pub tcpi_snd_cwnd : u_int32_t , pub tcpi_advmss : u_int32_t , pub tcpi_reordering : u_int32_t , pub tcpi_rcv_rtt : u_int32_t , pub tcpi_rcv_space : u_int32_t , pub tcpi_total_retrans : u_int32_t , } # [ test ] fn bindgen_test_layout_tcp_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_info > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( tcp_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_info > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( tcp_info ) ) ) ; } impl tcp_info { # [ inline ] pub fn tcpi_snd_wscale ( & self ) -> u_int8_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_snd_wscale ( & mut self , val : u_int8_t ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn tcpi_rcv_wscale ( & self ) -> u_int8_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_rcv_wscale ( & mut self , val : u_int8_t ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tcpi_snd_wscale : u_int8_t , tcpi_rcv_wscale : u_int8_t ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let tcpi_snd_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_snd_wscale ) } ; tcpi_snd_wscale as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let tcpi_rcv_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_rcv_wscale ) } ; tcpi_rcv_wscale as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_md5sig { pub tcpm_addr : sockaddr_storage , pub __tcpm_pad1 : u_int16_t , pub tcpm_keylen : u_int16_t , pub __tcpm_pad2 : u_int32_t , pub tcpm_key : [ u_int8_t ; 80usize ] , } # [ test ] fn bindgen_test_layout_tcp_md5sig ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_md5sig > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( tcp_md5sig ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_md5sig > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( tcp_md5sig ) ) ) ; } impl Default for tcp_md5sig { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_repair_opt { pub opt_code : u_int32_t , pub opt_val : u_int32_t , } # [ test ] fn bindgen_test_layout_tcp_repair_opt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_repair_opt > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( tcp_repair_opt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_repair_opt > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( tcp_repair_opt ) ) ) ; } pub const TCP_NO_QUEUE : _bindgen_ty_34 = 0 ; pub const TCP_RECV_QUEUE : _bindgen_ty_34 = 1 ; pub const TCP_SEND_QUEUE : _bindgen_ty_34 = 2 ; pub const TCP_QUEUES_NR : _bindgen_ty_34 = 3 ; pub type _bindgen_ty_34 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_cookie_transactions { pub tcpct_flags : u_int16_t , pub __tcpct_pad1 : u_int8_t , pub tcpct_cookie_desired : u_int8_t , pub tcpct_s_data_desired : u_int16_t , pub tcpct_used : u_int16_t , pub tcpct_value : [ u_int8_t ; 536usize ] , } # [ test ] fn bindgen_test_layout_tcp_cookie_transactions ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_cookie_transactions > ( ) , 544usize , concat ! ( "Size of: " , stringify ! ( tcp_cookie_transactions ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_cookie_transactions > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( tcp_cookie_transactions ) ) ) ; } impl Default for tcp_cookie_transactions { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct winsize { pub ws_row : :: std :: os :: raw :: c_ushort , pub ws_col : :: std :: os :: raw :: c_ushort , pub ws_xpixel : :: std :: os :: raw :: c_ushort , pub ws_ypixel : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout_winsize ( ) { assert_eq ! ( :: std :: mem :: size_of :: < winsize > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( winsize ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < winsize > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( winsize ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termio { pub c_iflag : :: std :: os :: raw :: c_ushort , pub c_oflag : :: std :: os :: raw :: c_ushort , pub c_cflag : :: std :: os :: raw :: c_ushort , pub c_lflag : :: std :: os :: raw :: c_ushort , pub c_line : :: std :: os :: raw :: c_uchar , pub c_cc : [ :: std :: os :: raw :: c_uchar ; 8usize ] , } # [ test ] fn bindgen_test_layout_termio ( ) { assert_eq ! ( :: std :: mem :: size_of :: < termio > ( ) , 18usize , concat ! ( "Size of: " , stringify ! ( termio ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < termio > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( termio ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z5ioctl" ] pub fn ioctl ( __fd : :: std :: os :: raw :: c_int , __request : :: std :: os :: raw :: c_ulong , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4mmap" ] pub fn mmap ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __prot : :: std :: os :: raw :: c_int , __flags : :: std :: os :: raw :: c_int , __fd : :: std :: os :: raw :: c_int , __offset : __off_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6munmap" ] pub fn munmap ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mprotect" ] pub fn mprotect ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __prot : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5msync" ] pub fn msync ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7madvise" ] pub fn madvise ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __advice : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13posix_madvise" ] pub fn posix_madvise ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __advice : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5mlock" ] pub fn mlock ( __addr : * const :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7munlock" ] pub fn munlock ( __addr : * const :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mlockall" ] pub fn mlockall ( __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10munlockall" ] pub fn munlockall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mincore" ] pub fn mincore ( __start : * mut :: std :: os :: raw :: c_void , __len : usize , __vec : * mut :: std :: os :: raw :: c_uchar ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8shm_open" ] pub fn shm_open ( __name : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , __mode : mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10shm_unlink" ] pub fn shm_unlink ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } pub const __rlimit_resource_RLIMIT_CPU : __rlimit_resource = 0 ; pub const __rlimit_resource_RLIMIT_FSIZE : __rlimit_resource = 1 ; pub const __rlimit_resource_RLIMIT_DATA : __rlimit_resource = 2 ; pub const __rlimit_resource_RLIMIT_STACK : __rlimit_resource = 3 ; pub const __rlimit_resource_RLIMIT_CORE : __rlimit_resource = 4 ; pub const __rlimit_resource___RLIMIT_RSS : __rlimit_resource = 5 ; pub const __rlimit_resource_RLIMIT_NOFILE : __rlimit_resource = 7 ; pub const __rlimit_resource___RLIMIT_OFILE : __rlimit_resource = 7 ; pub const __rlimit_resource_RLIMIT_AS : __rlimit_resource = 9 ; pub const __rlimit_resource___RLIMIT_NPROC : __rlimit_resource = 6 ; pub const __rlimit_resource___RLIMIT_MEMLOCK : __rlimit_resource = 8 ; pub const __rlimit_resource___RLIMIT_LOCKS : __rlimit_resource = 10 ; pub const __rlimit_resource___RLIMIT_SIGPENDING : __rlimit_resource = 11 ; pub const __rlimit_resource___RLIMIT_MSGQUEUE : __rlimit_resource = 12 ; pub const __rlimit_resource___RLIMIT_NICE : __rlimit_resource = 13 ; pub const __rlimit_resource___RLIMIT_RTPRIO : __rlimit_resource = 14 ; pub const __rlimit_resource___RLIMIT_RTTIME : __rlimit_resource = 15 ; pub const __rlimit_resource___RLIMIT_NLIMITS : __rlimit_resource = 16 ; pub const __rlimit_resource___RLIM_NLIMITS : __rlimit_resource = 16 ; pub type __rlimit_resource = u32 ; pub type rlim_t = __rlim_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct rlimit { pub rlim_cur : rlim_t , pub rlim_max : rlim_t , } # [ test ] fn bindgen_test_layout_rlimit ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rlimit > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( rlimit ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rlimit > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rlimit ) ) ) ; } pub const __rusage_who_RUSAGE_SELF : __rusage_who = 0 ; pub const __rusage_who_RUSAGE_CHILDREN : __rusage_who = -1 ; pub type __rusage_who = i32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct rusage { pub ru_utime : timeval , pub ru_stime : timeval , pub __bindgen_anon_1 : rusage__bindgen_ty_1 , pub __bindgen_anon_2 : rusage__bindgen_ty_2 , pub __bindgen_anon_3 : rusage__bindgen_ty_3 , pub __bindgen_anon_4 : rusage__bindgen_ty_4 , pub __bindgen_anon_5 : rusage__bindgen_ty_5 , pub __bindgen_anon_6 : rusage__bindgen_ty_6 , pub __bindgen_anon_7 : rusage__bindgen_ty_7 , pub __bindgen_anon_8 : rusage__bindgen_ty_8 , pub __bindgen_anon_9 : rusage__bindgen_ty_9 , pub __bindgen_anon_10 : rusage__bindgen_ty_10 , pub __bindgen_anon_11 : rusage__bindgen_ty_11 , pub __bindgen_anon_12 : rusage__bindgen_ty_12 , pub __bindgen_anon_13 : rusage__bindgen_ty_13 , pub __bindgen_anon_14 : rusage__bindgen_ty_14 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_1 { pub ru_maxrss : :: std :: os :: raw :: c_long , pub __ru_maxrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_1 ) ) ) ; } impl Default for rusage__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_2 { pub ru_ixrss : :: std :: os :: raw :: c_long , pub __ru_ixrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_2 ) ) ) ; } impl Default for rusage__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_3 { pub ru_idrss : :: std :: os :: raw :: c_long , pub __ru_idrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_3 ) ) ) ; } impl Default for rusage__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_4 { pub ru_isrss : :: std :: os :: raw :: c_long , pub __ru_isrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_4 ) ) ) ; } impl Default for rusage__bindgen_ty_4 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_5 { pub ru_minflt : :: std :: os :: raw :: c_long , pub __ru_minflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_5 ) ) ) ; } impl Default for rusage__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_6 { pub ru_majflt : :: std :: os :: raw :: c_long , pub __ru_majflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_6 ) ) ) ; } impl Default for rusage__bindgen_ty_6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_7 { pub ru_nswap : :: std :: os :: raw :: c_long , pub __ru_nswap_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_7 ) ) ) ; } impl Default for rusage__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_8 { pub ru_inblock : :: std :: os :: raw :: c_long , pub __ru_inblock_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_8 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_8 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_8 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_8 ) ) ) ; } impl Default for rusage__bindgen_ty_8 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_9 { pub ru_oublock : :: std :: os :: raw :: c_long , pub __ru_oublock_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_9 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_9 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_9 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_9 ) ) ) ; } impl Default for rusage__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_10 { pub ru_msgsnd : :: std :: os :: raw :: c_long , pub __ru_msgsnd_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_10 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_10 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_10 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_10 ) ) ) ; } impl Default for rusage__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_11 { pub ru_msgrcv : :: std :: os :: raw :: c_long , pub __ru_msgrcv_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_11 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_11 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_11 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_11 ) ) ) ; } impl Default for rusage__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_12 { pub ru_nsignals : :: std :: os :: raw :: c_long , pub __ru_nsignals_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_12 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_12 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_12 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_12 ) ) ) ; } impl Default for rusage__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_13 { pub ru_nvcsw : :: std :: os :: raw :: c_long , pub __ru_nvcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_13 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_13 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_13 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_13 ) ) ) ; } impl Default for rusage__bindgen_ty_13 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_14 { pub ru_nivcsw : :: std :: os :: raw :: c_long , pub __ru_nivcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_14 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_14 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_14 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_14 ) ) ) ; } impl Default for rusage__bindgen_ty_14 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_rusage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( rusage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage ) ) ) ; } impl Default for rusage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __priority_which_PRIO_PROCESS : __priority_which = 0 ; pub const __priority_which_PRIO_PGRP : __priority_which = 1 ; pub const __priority_which_PRIO_USER : __priority_which = 2 ; pub type __priority_which = u32 ; pub type __rlimit_resource_t = :: std :: os :: raw :: c_int ; pub type __rusage_who_t = :: std :: os :: raw :: c_int ; pub type __priority_which_t = :: std :: os :: raw :: c_int ; extern "C" { # [ link_name = "\u{1}_Z9getrlimit" ] pub fn getrlimit ( __resource : __rlimit_resource_t , __rlimits : * mut rlimit ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9setrlimit" ] pub fn setrlimit ( __resource : __rlimit_resource_t , __rlimits : * const rlimit ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9getrusage" ] pub fn getrusage ( __who : __rusage_who_t , __usage : * mut rusage ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getpriority" ] pub fn getpriority ( __which : __priority_which_t , __who : id_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11setpriority" ] pub fn setpriority ( __which : __priority_which_t , __who : id_t , __prio : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4stat" ] pub fn stat ( __file : * const :: std :: os :: raw :: c_char , __buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fstat" ] pub fn fstat ( __fd : :: std :: os :: raw :: c_int , __buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7fstatat" ] pub fn fstatat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __buf : * mut stat , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5lstat" ] pub fn lstat ( __file : * const :: std :: os :: raw :: c_char , __buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5chmod" ] pub fn chmod ( __file : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6lchmod" ] pub fn lchmod ( __file : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fchmod" ] pub fn fchmod ( __fd : :: std :: os :: raw :: c_int , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8fchmodat" ] pub fn fchmodat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5umask" ] pub fn umask ( __mask : __mode_t ) -> __mode_t ; } extern "C" { # [ link_name = "\u{1}_Z5mkdir" ] pub fn mkdir ( __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mkdirat" ] pub fn mkdirat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5mknod" ] pub fn mknod ( __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : __dev_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mknodat" ] pub fn mknodat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : __dev_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6mkfifo" ] pub fn mkfifo ( __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mkfifoat" ] pub fn mkfifoat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9utimensat" ] pub fn utimensat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __times : * const timespec , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8futimens" ] pub fn futimens ( __fd : :: std :: os :: raw :: c_int , __times : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8__fxstat" ] pub fn __fxstat ( __ver : :: std :: os :: raw :: c_int , __fildes : :: std :: os :: raw :: c_int , __stat_buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7__xstat" ] pub fn __xstat ( __ver : :: std :: os :: raw :: c_int , __filename : * const :: std :: os :: raw :: c_char , __stat_buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8__lxstat" ] pub fn __lxstat ( __ver : :: std :: os :: raw :: c_int , __filename : * const :: std :: os :: raw :: c_char , __stat_buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10__fxstatat" ] pub fn __fxstatat ( __ver : :: std :: os :: raw :: c_int , __fildes : :: std :: os :: raw :: c_int , __filename : * const :: std :: os :: raw :: c_char , __stat_buf : * mut stat , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8__xmknod" ] pub fn __xmknod ( __ver : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10__xmknodat" ] pub fn __xmknodat ( __ver : :: std :: os :: raw :: c_int , __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_un { pub sun_family : sa_family_t , pub sun_path : [ :: std :: os :: raw :: c_char ; 108usize ] , } # [ test ] fn bindgen_test_layout_sockaddr_un ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_un > ( ) , 110usize , concat ! ( "Size of: " , stringify ! ( sockaddr_un ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_un > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_un ) ) ) ; } impl Default for sockaddr_un { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user_fpregs_struct { pub cwd : :: std :: os :: raw :: c_ushort , pub swd : :: std :: os :: raw :: c_ushort , pub ftw : :: std :: os :: raw :: c_ushort , pub fop : :: std :: os :: raw :: c_ushort , pub rip : :: std :: os :: raw :: c_ulonglong , pub rdp : :: std :: os :: raw :: c_ulonglong , pub mxcsr : :: std :: os :: raw :: c_uint , pub mxcr_mask : :: std :: os :: raw :: c_uint , pub st_space : [ :: std :: os :: raw :: c_uint ; 32usize ] , pub xmm_space : [ :: std :: os :: raw :: c_uint ; 64usize ] , pub padding : [ :: std :: os :: raw :: c_uint ; 24usize ] , } # [ test ] fn bindgen_test_layout_user_fpregs_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user_fpregs_struct > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( user_fpregs_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user_fpregs_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user_fpregs_struct ) ) ) ; } impl Default for user_fpregs_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct user_regs_struct { pub r15 : :: std :: os :: raw :: c_ulonglong , pub r14 : :: std :: os :: raw :: c_ulonglong , pub r13 : :: std :: os :: raw :: c_ulonglong , pub r12 : :: std :: os :: raw :: c_ulonglong , pub rbp : :: std :: os :: raw :: c_ulonglong , pub rbx : :: std :: os :: raw :: c_ulonglong , pub r11 : :: std :: os :: raw :: c_ulonglong , pub r10 : :: std :: os :: raw :: c_ulonglong , pub r9 : :: std :: os :: raw :: c_ulonglong , pub r8 : :: std :: os :: raw :: c_ulonglong , pub rax : :: std :: os :: raw :: c_ulonglong , pub rcx : :: std :: os :: raw :: c_ulonglong , pub rdx : :: std :: os :: raw :: c_ulonglong , pub rsi : :: std :: os :: raw :: c_ulonglong , pub rdi : :: std :: os :: raw :: c_ulonglong , pub orig_rax : :: std :: os :: raw :: c_ulonglong , pub rip : :: std :: os :: raw :: c_ulonglong , pub cs : :: std :: os :: raw :: c_ulonglong , pub eflags : :: std :: os :: raw :: c_ulonglong , pub rsp : :: std :: os :: raw :: c_ulonglong , pub ss : :: std :: os :: raw :: c_ulonglong , pub fs_base : :: std :: os :: raw :: c_ulonglong , pub gs_base : :: std :: os :: raw :: c_ulonglong , pub ds : :: std :: os :: raw :: c_ulonglong , pub es : :: std :: os :: raw :: c_ulonglong , pub fs : :: std :: os :: raw :: c_ulonglong , pub gs : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_user_regs_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user_regs_struct > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( user_regs_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user_regs_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user_regs_struct ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user { pub regs : user_regs_struct , pub u_fpvalid : :: std :: os :: raw :: c_int , pub i387 : user_fpregs_struct , pub u_tsize : :: std :: os :: raw :: c_ulonglong , pub u_dsize : :: std :: os :: raw :: c_ulonglong , pub u_ssize : :: std :: os :: raw :: c_ulonglong , pub start_code : :: std :: os :: raw :: c_ulonglong , pub start_stack : :: std :: os :: raw :: c_ulonglong , pub signal : :: std :: os :: raw :: c_longlong , pub reserved : :: std :: os :: raw :: c_int , pub __bindgen_anon_1 : user__bindgen_ty_1 , pub __bindgen_anon_2 : user__bindgen_ty_2 , pub magic : :: std :: os :: raw :: c_ulonglong , pub u_comm : [ :: std :: os :: raw :: c_char ; 32usize ] , pub u_debugreg : [ :: std :: os :: raw :: c_ulonglong ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_1 { pub u_ar0 : * mut user_regs_struct , pub __u_ar0_word : :: std :: os :: raw :: c_ulonglong , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_user__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( user__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user__bindgen_ty_1 ) ) ) ; } impl Default for user__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_2 { pub u_fpstate : * mut user_fpregs_struct , pub __u_fpstate_word : :: std :: os :: raw :: c_ulonglong , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_user__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( user__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user__bindgen_ty_2 ) ) ) ; } impl Default for user__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_user ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user > ( ) , 912usize , concat ! ( "Size of: " , stringify ! ( user ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user ) ) ) ; } impl Default for user { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = u32 ; extern "C" { # [ link_name = "\u{1}_Z4wait" ] pub fn wait ( __stat_loc : __WAIT_STATUS ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7waitpid" ] pub fn waitpid ( __pid : __pid_t , __stat_loc : * mut :: std :: os :: raw :: c_int , __options : :: std :: os :: raw :: c_int ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z6waitid" ] pub fn waitid ( __idtype : idtype_t , __id : __id_t , __infop : * mut siginfo_t , __options : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5wait3" ] pub fn wait3 ( __stat_loc : __WAIT_STATUS , __options : :: std :: os :: raw :: c_int , __usage : * mut rusage ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z5wait4" ] pub fn wait4 ( __pid : __pid_t , __stat_loc : __WAIT_STATUS , __options : :: std :: os :: raw :: c_int , __usage : * mut rusage ) -> __pid_t ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_pci_device { _unused : [ u8 ; 0 ] , } 
 /// \brief Environment initialization options 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_env_opts { pub name : * const :: std :: os :: raw :: c_char , pub core_mask : * const :: std :: os :: raw :: c_char , pub shm_id : :: std :: os :: raw :: c_int , pub mem_channel : :: std :: os :: raw :: c_int , pub master_core : :: std :: os :: raw :: c_int , pub mem_size : :: std :: os :: raw :: c_int , pub no_pci : bool , pub hugepage_single_segments : bool , 
 /// Opaque context for use of the env implementation. 
 pub env_context : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_spdk_env_opts ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_env_opts > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( spdk_env_opts ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_env_opts > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_env_opts ) ) ) ; } impl Default for spdk_env_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Allocate dma/sharable memory based on a given dma_flg. It is a physically
/// contiguous memory buffer with the given size, alignment and socket id.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Combination of SPDK_MALLOC flags (\ref SPDK_MALLOC_DMA, \ref SPDK_MALLOC_SHARE).
///
/// \return a pointer to the allocated memory buffer. 
 # [ link_name = "\u{1}_Z11spdk_malloc" ] pub fn spdk_malloc ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : :: std :: os :: raw :: c_int , flags : u32 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Allocate dma/sharable memory based on a given dma_flg. It is a physically
/// contiguous memory buffer with the given size, alignment and socket id.
/// Also, the buffer will be zeroed.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Combination of SPDK_MALLOC flags (\ref SPDK_MALLOC_DMA, \ref SPDK_MALLOC_SHARE).
///
/// \return a pointer to the allocated memory buffer. 
 # [ link_name = "\u{1}_Z12spdk_zmalloc" ] pub fn spdk_zmalloc ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : :: std :: os :: raw :: c_int , flags : u32 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Free buffer memory that was previously allocated with spdk_malloc() or spdk_zmalloc().
///
/// \param buf Buffer to free. 
 # [ link_name = "\u{1}_Z9spdk_free" ] pub fn spdk_free ( buf : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Initialize the default value of opts.
///
/// \param opts Data structure where SPDK will initialize the default options. 
 # [ link_name = "\u{1}_Z18spdk_env_opts_init" ] pub fn spdk_env_opts_init ( opts : * mut spdk_env_opts ) ; } extern "C" { 
 /// Initialize the environment library. This must be called prior to using
/// any other functions in this library.
///
/// \param opts Environment initialization options.
/// \return 0 on success, or negative errno on failure. 
 # [ link_name = "\u{1}_Z13spdk_env_init" ] pub fn spdk_env_init ( opts : * const spdk_env_opts ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Allocate a pinned, physically contiguous memory buffer with the given size
/// and alignment.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
///
/// \return a pointer to the allocated memory buffer. 
 # [ link_name = "\u{1}_Z15spdk_dma_malloc" ] pub fn spdk_dma_malloc ( size : usize , align : usize , phys_addr : * mut u64 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Allocate a pinned, physically contiguous memory buffer with the given size,
/// alignment and socket id.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the allocated memory buffer. 
 # [ link_name = "\u{1}_Z22spdk_dma_malloc_socket" ] pub fn spdk_dma_malloc_socket ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Allocate a pinned, physically contiguous memory buffer with the given size
/// and alignment. The buffer will be zeroed.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
///
/// \return a pointer to the allocated memory buffer. 
 # [ link_name = "\u{1}_Z16spdk_dma_zmalloc" ] pub fn spdk_dma_zmalloc ( size : usize , align : usize , phys_addr : * mut u64 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Allocate a pinned, physically contiguous memory buffer with the given size,
/// alignment and socket id. The buffer will be zeroed.
///
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the allocated memory buffer. 
 # [ link_name = "\u{1}_Z23spdk_dma_zmalloc_socket" ] pub fn spdk_dma_zmalloc_socket ( size : usize , align : usize , phys_addr : * mut u64 , socket_id : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Resize the allocated and pinned memory buffer with the given new size and
/// alignment. Existing contents are preserved.
///
/// \param buf Buffer to resize.
/// \param size Size in bytes.
/// \param align Alignment value for the allocated memory. If '0', the allocated
/// buffer is suitably aligned (in the same manner as malloc()). Otherwise, the
/// allocated buffer is aligned to the multiple of align. In this case, it must
/// be a power of two.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the allocated buffer is passed. If NULL, the physical address is not returned.
///
/// \return a pointer to the resized memory buffer. 
 # [ link_name = "\u{1}_Z16spdk_dma_realloc" ] pub fn spdk_dma_realloc ( buf : * mut :: std :: os :: raw :: c_void , size : usize , align : usize , phys_addr : * mut u64 ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Free a memory buffer previously allocated, for example from spdk_dma_zmalloc().
/// This call is never made from the performance path.
///
/// \param buf Buffer to free. 
 # [ link_name = "\u{1}_Z13spdk_dma_free" ] pub fn spdk_dma_free ( buf : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Reserve a named, process shared memory zone with the given size, socket_id
/// and flags.
///
/// \param name Name to set for this memory zone.
/// \param len Length in bytes.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param flags Flags to set for this memory zone.
///
/// \return a pointer to the allocated memory address on success, or NULL on failure. 
 # [ link_name = "\u{1}_Z20spdk_memzone_reserve" ] pub fn spdk_memzone_reserve ( name : * const :: std :: os :: raw :: c_char , len : usize , socket_id : :: std :: os :: raw :: c_int , flags : :: std :: os :: raw :: c_uint ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Lookup the memory zone identified by the given name.
///
/// \param name Name of the memory zone.
///
/// \return a pointer to the reserved memory address on success, or NULL on failure. 
 # [ link_name = "\u{1}_Z19spdk_memzone_lookup" ] pub fn spdk_memzone_lookup ( name : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Free the memory zone identified by the given name.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z17spdk_memzone_free" ] pub fn spdk_memzone_free ( name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Dump debug information about all memzones.
///
/// \param f File to write debug information to. 
 # [ link_name = "\u{1}_Z17spdk_memzone_dump" ] pub fn spdk_memzone_dump ( f : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mempool { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Create a thread-safe memory pool.
///
/// \param name Name for the memory pool.
/// \param count Count of elements.
/// \param ele_size Element size in bytes.
/// \param cache_size How many elements may be cached in per-core caches. Use
/// SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the created memory pool. 
 # [ link_name = "\u{1}_Z19spdk_mempool_create" ] pub fn spdk_mempool_create ( name : * const :: std :: os :: raw :: c_char , count : usize , ele_size : usize , cache_size : usize , socket_id : :: std :: os :: raw :: c_int ) -> * mut spdk_mempool ; } 
 /// An object callback function for memory pool.
///
/// Used by spdk_mempool_create_ctor(). 
 pub type spdk_mempool_obj_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( mp : * mut spdk_mempool , opaque : * mut :: std :: os :: raw :: c_void , obj : * mut :: std :: os :: raw :: c_void , obj_idx : :: std :: os :: raw :: c_uint ) > ; extern "C" { 
 /// Create a thread-safe memory pool with user provided initialization function
/// and argument.
///
/// \param name Name for the memory pool.
/// \param count Count of elements.
/// \param ele_size Element size in bytes.
/// \param cache_size How many elements may be cached in per-core caches. Use
/// SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
/// \param obj_init User provided object calllback initialization function.
/// \param obj_init_arg User provided callback initialization function argument.
///
/// \return a pointer to the created memory pool. 
 # [ link_name = "\u{1}_Z24spdk_mempool_create_ctor" ] pub fn spdk_mempool_create_ctor ( name : * const :: std :: os :: raw :: c_char , count : usize , ele_size : usize , cache_size : usize , socket_id : :: std :: os :: raw :: c_int , obj_init : spdk_mempool_obj_cb_t , obj_init_arg : * mut :: std :: os :: raw :: c_void ) -> * mut spdk_mempool ; } extern "C" { 
 /// Get the name of a memory pool.
///
/// \param mp Memory pool to query.
///
/// \return the name of the memory pool. 
 # [ link_name = "\u{1}_Z21spdk_mempool_get_name" ] pub fn spdk_mempool_get_name ( mp : * mut spdk_mempool ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { 
 /// Free a memory pool. 
 # [ link_name = "\u{1}_Z17spdk_mempool_free" ] pub fn spdk_mempool_free ( mp : * mut spdk_mempool ) ; } extern "C" { 
 /// Get an element from a memory pool. If no elements remain, return NULL.
///
/// \param mp Memory pool to query.
///
/// \return a pointer to the element. 
 # [ link_name = "\u{1}_Z16spdk_mempool_get" ] pub fn spdk_mempool_get ( mp : * mut spdk_mempool ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// Get multiple elements from a memory pool.
///
/// \param mp Memory pool to get multiple elements from.
/// \param ele_arr Array of the elements to fill.
/// \param count Count of elements to get.
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z21spdk_mempool_get_bulk" ] pub fn spdk_mempool_get_bulk ( mp : * mut spdk_mempool , ele_arr : * mut * mut :: std :: os :: raw :: c_void , count : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Put an element back into the memory pool.
///
/// \param mp Memory pool to put element back into.
/// \param ele Element to put. 
 # [ link_name = "\u{1}_Z16spdk_mempool_put" ] pub fn spdk_mempool_put ( mp : * mut spdk_mempool , ele : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Put multiple elements back into the memory pool.
///
/// \param mp Memory pool to put multiple elements back into.
/// \param ele_arr Array of the elements to put.
/// \param count Count of elements to put. 
 # [ link_name = "\u{1}_Z21spdk_mempool_put_bulk" ] pub fn spdk_mempool_put_bulk ( mp : * mut spdk_mempool , ele_arr : * const * mut :: std :: os :: raw :: c_void , count : usize ) ; } extern "C" { 
 /// Get the number of entries in the memory pool.
///
/// \param pool Memory pool to query.
///
/// \return the number of entries in the memory pool. 
 # [ link_name = "\u{1}_Z18spdk_mempool_count" ] pub fn spdk_mempool_count ( pool : * const spdk_mempool ) -> usize ; } extern "C" { 
 /// Get the number of dedicated CPU cores utilized by this env abstraction.
///
/// \return the number of dedicated CPU cores. 
 # [ link_name = "\u{1}_Z23spdk_env_get_core_count" ] pub fn spdk_env_get_core_count ( ) -> u32 ; } extern "C" { 
 /// Get the CPU core index of the current thread.
///
/// This will only function when called from threads set up by
/// this environment abstraction. For any other threads \c SPDK_ENV_LCORE_ID_ANY
/// will be returned.
///
/// \return the CPU core index of the current thread. 
 # [ link_name = "\u{1}_Z25spdk_env_get_current_core" ] pub fn spdk_env_get_current_core ( ) -> u32 ; } extern "C" { 
 /// Get the index of the first dedicated CPU core for this application.
///
/// \return the index of the first dedicated CPU core. 
 # [ link_name = "\u{1}_Z23spdk_env_get_first_core" ] pub fn spdk_env_get_first_core ( ) -> u32 ; } extern "C" { 
 /// Get the index of the last dedicated CPU core for this application.
///
/// \return the index of the last dedicated CPU core. 
 # [ link_name = "\u{1}_Z22spdk_env_get_last_core" ] pub fn spdk_env_get_last_core ( ) -> u32 ; } extern "C" { 
 /// Get the index of the next dedicated CPU core for this application.
///
/// If there is no next core, return UINT32_MAX.
///
/// \param prev_core Index of previous core.
///
/// \return the index of the next dedicated CPU core. 
 # [ link_name = "\u{1}_Z22spdk_env_get_next_core" ] pub fn spdk_env_get_next_core ( prev_core : u32 ) -> u32 ; } extern "C" { 
 /// Get the socket ID for the given core.
///
/// \param core CPU core to query.
///
/// \return the socket ID for the given core. 
 # [ link_name = "\u{1}_Z22spdk_env_get_socket_id" ] pub fn spdk_env_get_socket_id ( core : u32 ) -> u32 ; } pub type thread_start_fn = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { 
 /// Launch a thread pinned to the given core. Only a single pinned thread may be
/// launched per core. Subsequent attempts to launch pinned threads on that core
/// will fail.
///
/// \param core The core to pin the thread to.
/// \param fn Entry point on the new thread.
/// \param arg Argument apssed to thread_start_fn
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z29spdk_env_thread_launch_pinned" ] pub fn spdk_env_thread_launch_pinned ( core : u32 , fn_ : thread_start_fn , arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Wait for all threads to exit before returning. 
 # [ link_name = "\u{1}_Z24spdk_env_thread_wait_all" ] pub fn spdk_env_thread_wait_all ( ) ; } extern "C" { 
 /// Check whether the calling process is primary process.
///
/// \return true if the calling process is primary process, or false otherwise. 
 # [ link_name = "\u{1}_Z23spdk_process_is_primary" ] pub fn spdk_process_is_primary ( ) -> bool ; } extern "C" { 
 /// Get a monotonic timestamp counter.
///
/// \return the monotonic timestamp counter. 
 # [ link_name = "\u{1}_Z14spdk_get_ticks" ] pub fn spdk_get_ticks ( ) -> u64 ; } extern "C" { 
 /// Get the tick rate of spdk_get_ticks() per second.
///
/// \return the tick rate of spdk_get_ticks() per second. 
 # [ link_name = "\u{1}_Z17spdk_get_ticks_hz" ] pub fn spdk_get_ticks_hz ( ) -> u64 ; } extern "C" { 
 /// Delay the given number of microseconds.
///
/// \param us Number of microseconds. 
 # [ link_name = "\u{1}_Z13spdk_delay_us" ] pub fn spdk_delay_us ( us : :: std :: os :: raw :: c_uint ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_ring { _unused : [ u8 ; 0 ] , } pub const spdk_ring_type_SPDK_RING_TYPE_SP_SC : spdk_ring_type = 0 ; pub const spdk_ring_type_SPDK_RING_TYPE_MP_SC : spdk_ring_type = 1 ; pub type spdk_ring_type = u32 ; extern "C" { 
 /// Create a ring.
///
/// \param type Type for the ring. (SPDK_RING_TYPE_SP_SC or SPDK_RING_TYPE_MP_SC).
/// \param count Size of the ring in elements.
/// \param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY
/// for any socket.
///
/// \return a pointer to the created ring. 
 # [ link_name = "\u{1}_Z16spdk_ring_create" ] pub fn spdk_ring_create ( type_ : spdk_ring_type , count : usize , socket_id : :: std :: os :: raw :: c_int ) -> * mut spdk_ring ; } extern "C" { 
 /// Free the ring.
///
/// \param ring Ring to free. 
 # [ link_name = "\u{1}_Z14spdk_ring_free" ] pub fn spdk_ring_free ( ring : * mut spdk_ring ) ; } extern "C" { 
 /// Get the number of objects in the ring.
///
/// \param ring the ring.
///
/// \return the number of objects in the ring. 
 # [ link_name = "\u{1}_Z15spdk_ring_count" ] pub fn spdk_ring_count ( ring : * mut spdk_ring ) -> usize ; } extern "C" { 
 /// Queue the array of objects (with length count) on the ring.
///
/// \param ring A pointer to the ring.
/// \param objs A pointer to the array to be queued.
/// \param count Length count of the array of objects.
///
/// \return the number of objects enqueued. 
 # [ link_name = "\u{1}_Z17spdk_ring_enqueue" ] pub fn spdk_ring_enqueue ( ring : * mut spdk_ring , objs : * mut * mut :: std :: os :: raw :: c_void , count : usize ) -> usize ; } extern "C" { 
 /// Dequeue count objects from the ring into the array objs.
///
/// \param ring A pointer to the ring.
/// \param objs A pointer to the array to be dequeued.
/// \param count Maximum number of elements to be dequeued.
///
/// \return the number of objects dequeued which is less than 'count'. 
 # [ link_name = "\u{1}_Z17spdk_ring_dequeue" ] pub fn spdk_ring_dequeue ( ring : * mut spdk_ring , objs : * mut * mut :: std :: os :: raw :: c_void , count : usize ) -> usize ; } extern "C" { 
 /// Get the physical address of a buffer.
///
/// \param buf A pointer to a buffer.
///
/// \return the physical address of this buffer on success, or SPDK_VTOPHYS_ERROR
/// on failure. 
 # [ link_name = "\u{1}_Z12spdk_vtophys" ] pub fn spdk_vtophys ( buf : * mut :: std :: os :: raw :: c_void ) -> u64 ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_addr { pub domain : u32 , pub bus : u8 , pub dev : u8 , pub func : u8 , } # [ test ] fn bindgen_test_layout_spdk_pci_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_pci_addr > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_pci_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_pci_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_pci_addr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_pci_id { pub vendor_id : u16 , pub device_id : u16 , pub subvendor_id : u16 , pub subdevice_id : u16 , } # [ test ] fn bindgen_test_layout_spdk_pci_id ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_pci_id > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_pci_id ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_pci_id > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_pci_id ) ) ) ; } pub type spdk_pci_enum_cb = :: std :: option :: Option < unsafe extern "C" fn ( enum_ctx : * mut :: std :: os :: raw :: c_void , pci_dev : * mut spdk_pci_device ) -> :: std :: os :: raw :: c_int > ; extern "C" { 
 /// Enumerate NVMe devices.
///
/// \param enum_cb Called when the enumerate operation completes.
/// \param enum_ctx Argument passed to the callback function.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z23spdk_pci_nvme_enumerate" ] pub fn spdk_pci_nvme_enumerate ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Enumerate I/OAT device.
///
/// \param enum_cb Called when the enumerate operation completes.
/// \param enum_ctx Argument passed to the callback function.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z23spdk_pci_ioat_enumerate" ] pub fn spdk_pci_ioat_enumerate ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Enumerate virtio device.
///
/// \param enum_cb Called when the enumerate operation completes.
/// \param enum_ctx Argument passed to the callback function.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z25spdk_pci_virtio_enumerate" ] pub fn spdk_pci_virtio_enumerate ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Get PCI device from the given address.
///
/// \param pci_addr A pointer to the PCI address struct.
///
/// \return a pointer to the PCI device or NULL if no devide is found at the given
/// address. 
 # [ link_name = "\u{1}_Z19spdk_pci_get_device" ] pub fn spdk_pci_get_device ( pci_addr : * mut spdk_pci_addr ) -> * mut spdk_pci_device ; } extern "C" { 
 /// Get a mapping of the virtual address to the BAR of the PCI device.
///
/// \param dev PCI device.
/// \param bar Index to the BAR.
/// \param mapped_addr A pointer to the pointer to hold the virtual address of
/// the mapping.
/// \param phys_addr A pointer to the variable to hold the physical address of
/// the mapping.
/// \param size A pointer to the variable to hold the mapped size in bytes.
///
/// \return 0 on success. 
 # [ link_name = "\u{1}_Z23spdk_pci_device_map_bar" ] pub fn spdk_pci_device_map_bar ( dev : * mut spdk_pci_device , bar : u32 , mapped_addr : * mut * mut :: std :: os :: raw :: c_void , phys_addr : * mut u64 , size : * mut u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Remove the mapping of the virtual address to the BAR of the PCI device.
///
/// \param dev PCI device.
/// \param bar Index to the BAR.
/// \param addr Virtual address to remove that must be the mapped_addr returned
/// by a previous call to spdk_pci_device_map_bar().
///
/// \return 0 on success. 
 # [ link_name = "\u{1}_Z25spdk_pci_device_unmap_bar" ] pub fn spdk_pci_device_unmap_bar ( dev : * mut spdk_pci_device , bar : u32 , addr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Get the domain address of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the domain address of PCI device. 
 # [ link_name = "\u{1}_Z26spdk_pci_device_get_domain" ] pub fn spdk_pci_device_get_domain ( dev : * mut spdk_pci_device ) -> u32 ; } extern "C" { 
 /// Get the bus address of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the bus address of PCI device. 
 # [ link_name = "\u{1}_Z23spdk_pci_device_get_bus" ] pub fn spdk_pci_device_get_bus ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { 
 /// Get the device address of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the device address of PCI device. 
 # [ link_name = "\u{1}_Z23spdk_pci_device_get_dev" ] pub fn spdk_pci_device_get_dev ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { 
 /// Get the function address of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the function address of PCI device. 
 # [ link_name = "\u{1}_Z24spdk_pci_device_get_func" ] pub fn spdk_pci_device_get_func ( dev : * mut spdk_pci_device ) -> u8 ; } extern "C" { 
 /// Get the PCI address of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the PCI address structure. 
 # [ link_name = "\u{1}_Z24spdk_pci_device_get_addr" ] pub fn spdk_pci_device_get_addr ( dev : * mut spdk_pci_device ) -> spdk_pci_addr ; } extern "C" { 
 /// Get the vendor ID of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the vendor ID of PCI device. 
 # [ link_name = "\u{1}_Z29spdk_pci_device_get_vendor_id" ] pub fn spdk_pci_device_get_vendor_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the device ID of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the device ID of PCI device. 
 # [ link_name = "\u{1}_Z29spdk_pci_device_get_device_id" ] pub fn spdk_pci_device_get_device_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the subvendor ID of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the subvendor ID of PCI device. 
 # [ link_name = "\u{1}_Z32spdk_pci_device_get_subvendor_id" ] pub fn spdk_pci_device_get_subvendor_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Get the subdevice ID of a PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return the subdevice ID of PCI device. 
 # [ link_name = "\u{1}_Z32spdk_pci_device_get_subdevice_id" ] pub fn spdk_pci_device_get_subdevice_id ( dev : * mut spdk_pci_device ) -> u16 ; } extern "C" { 
 /// Allocate a PCI ID struct for the PCI device.
///
/// \param dev A pointer to the PCI device.
///
/// \return a PCI ID struct. 
 # [ link_name = "\u{1}_Z22spdk_pci_device_get_id" ] pub fn spdk_pci_device_get_id ( dev : * mut spdk_pci_device ) -> spdk_pci_id ; } extern "C" { 
 /// Get the NUMA socket ID of a PCI device.
///
/// \param dev PCI device to get the socket ID of.
///
/// \return the socket ID (>= 0) of PCI device. 
 # [ link_name = "\u{1}_Z29spdk_pci_device_get_socket_id" ] pub fn spdk_pci_device_get_socket_id ( dev : * mut spdk_pci_device ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Get the serial number of a PCI device.
///
/// \param dev A pointer to the PCI device.
/// \param sn String to store the serial number.
/// \param len Length of the 'sn'.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z33spdk_pci_device_get_serial_number" ] pub fn spdk_pci_device_get_serial_number ( dev : * mut spdk_pci_device , sn : * mut :: std :: os :: raw :: c_char , len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Claim a PCI device for exclusive SPDK userspace access.
///
/// Uses F_SETLK on a shared memory file with the PCI address embedded in its name.
/// As long as this file remains open with the lock acquired, other processes will
/// not be able to successfully call this function on the same PCI device.
///
/// \param pci_addr PCI address of the device to claim
///
/// \return -1 if the device has already been claimed, an fd otherwise. This fd
/// should be closed when the application no longer needs access to the PCI device
/// (including when it is hot removed). 
 # [ link_name = "\u{1}_Z21spdk_pci_device_claim" ] pub fn spdk_pci_device_claim ( pci_addr : * const spdk_pci_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Detach a PCI device.
///
/// \param device PCI device to detach. 
 # [ link_name = "\u{1}_Z22spdk_pci_device_detach" ] pub fn spdk_pci_device_detach ( device : * mut spdk_pci_device ) ; } extern "C" { 
 /// Attach a NVMe device.
///
/// \param enum_cb Called when the attach operation completes.
/// \param enum_ctx Argument passed to the callback function.
/// \param pci_address PCI address of the NVMe device.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z27spdk_pci_nvme_device_attach" ] pub fn spdk_pci_nvme_device_attach ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut :: std :: os :: raw :: c_void , pci_address : * mut spdk_pci_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Attach a I/OAT device.
///
/// \param enum_cb Called when the attach operation completes.
/// \param enum_ctx Argument passed to the callback function.
/// \param pci_address PCI address of the I/OAT device.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z27spdk_pci_ioat_device_attach" ] pub fn spdk_pci_ioat_device_attach ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut :: std :: os :: raw :: c_void , pci_address : * mut spdk_pci_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Attach a virtio device.
///
/// \param enum_cb Called when the attach operation completes.
/// \param enum_ctx Argument passed to the callback function.
/// \param pci_address PCI address of the virtio device.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z29spdk_pci_virtio_device_attach" ] pub fn spdk_pci_virtio_device_attach ( enum_cb : spdk_pci_enum_cb , enum_ctx : * mut :: std :: os :: raw :: c_void , pci_address : * mut spdk_pci_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Read PCI configuration space in any specified size.
///
/// \param dev PCI device.
/// \param value A pointer to the buffer to hold the value.
/// \param len Length in bytes to read.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z24spdk_pci_device_cfg_read" ] pub fn spdk_pci_device_cfg_read ( dev : * mut spdk_pci_device , value : * mut :: std :: os :: raw :: c_void , len : u32 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Write PCI configuration space in any specified size.
///
/// \param dev PCI device.
/// \param value A pointer to the value to write.
/// \param len Length in bytes to write.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z25spdk_pci_device_cfg_write" ] pub fn spdk_pci_device_cfg_write ( dev : * mut spdk_pci_device , value : * mut :: std :: os :: raw :: c_void , len : u32 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Read 1 byte from PCI configuration space.
///
/// \param dev PCI device.
/// \param value A pointer to the buffer to hold the value.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z25spdk_pci_device_cfg_read8" ] pub fn spdk_pci_device_cfg_read8 ( dev : * mut spdk_pci_device , value : * mut u8 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Write 1 byte to PCI configuration space.
///
/// \param dev PCI device.
/// \param value A value to write.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z26spdk_pci_device_cfg_write8" ] pub fn spdk_pci_device_cfg_write8 ( dev : * mut spdk_pci_device , value : u8 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Read 2 bytes from PCI configuration space.
///
/// \param dev PCI device.
/// \param value A pointer to the buffer to hold the value.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z26spdk_pci_device_cfg_read16" ] pub fn spdk_pci_device_cfg_read16 ( dev : * mut spdk_pci_device , value : * mut u16 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Write 2 bytes to PCI configuration space.
///
/// \param dev PCI device.
/// \param value A value to write.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z27spdk_pci_device_cfg_write16" ] pub fn spdk_pci_device_cfg_write16 ( dev : * mut spdk_pci_device , value : u16 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Read 4 bytes from PCI configuration space.
///
/// \param dev PCI device.
/// \param value A pointer to the buffer to hold the value.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z26spdk_pci_device_cfg_read32" ] pub fn spdk_pci_device_cfg_read32 ( dev : * mut spdk_pci_device , value : * mut u32 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Write 4 bytes to PCI configuration space.
///
/// \param dev PCI device.
/// \param value A value to write.
/// \param offset Offset in bytes.
///
/// \return 0 on success, -1 on failure. 
 # [ link_name = "\u{1}_Z27spdk_pci_device_cfg_write32" ] pub fn spdk_pci_device_cfg_write32 ( dev : * mut spdk_pci_device , value : u32 , offset : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Compare two PCI addresses.
///
/// \param a1 PCI address 1.
/// \param a2 PCI address 2.
///
/// \return 0 if a1 == a2, less than 0 if a1 < a2, greater than 0 if a1 > a2 
 # [ link_name = "\u{1}_Z21spdk_pci_addr_compare" ] pub fn spdk_pci_addr_compare ( a1 : * const spdk_pci_addr , a2 : * const spdk_pci_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Convert a string representation of a PCI address into a struct spdk_pci_addr.
///
/// \param addr PCI adddress output on success.
/// \param bdf PCI address in domain:bus:device.function format or
/// domain.bus.device.function format.
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z19spdk_pci_addr_parse" ] pub fn spdk_pci_addr_parse ( addr : * mut spdk_pci_addr , bdf : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Convert a struct spdk_pci_addr to a string.
///
/// \param bdf String into which a string will be output in the format
/// domain:bus:device.function. The string must be at least 14 characters in size.
/// \param sz Size of bdf in bytes. Must be at least 14.
/// \param addr PCI address.
///
/// \return 0 on success, or a negated errno on failure. 
 # [ link_name = "\u{1}_Z17spdk_pci_addr_fmt" ] pub fn spdk_pci_addr_fmt ( bdf : * mut :: std :: os :: raw :: c_char , sz : usize , addr : * const spdk_pci_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Remove any CPU affinity from the current thread. 
 # [ link_name = "\u{1}_Z24spdk_unaffinitize_thread" ] pub fn spdk_unaffinitize_thread ( ) ; } extern "C" { 
 /// Call a function with CPU affinity unset.
///
/// This can be used to run a function that creates other threads without inheriting the calling
/// thread's CPU affinity.
///
/// \param cb Function to call
/// \param arg Parameter to the function cb().
///
/// \return the return value of cb(). 
 # [ link_name = "\u{1}_Z23spdk_call_unaffinitized" ] pub fn spdk_call_unaffinitized ( cb : :: std :: option :: Option < unsafe extern "C" fn ( arg : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > , arg : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void ; } 
 /// Page-granularity memory address translation table. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_mem_map { _unused : [ u8 ; 0 ] , } pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_REGISTER : spdk_mem_map_notify_action = 0 ; pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_UNREGISTER : spdk_mem_map_notify_action = 1 ; pub type spdk_mem_map_notify_action = u32 ; pub type spdk_mem_map_notify_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut :: std :: os :: raw :: c_void , map : * mut spdk_mem_map , action : spdk_mem_map_notify_action , vaddr : * mut :: std :: os :: raw :: c_void , size : usize ) -> :: std :: os :: raw :: c_int > ; extern "C" { 
 /// Allocate a virtual memory address translation map.
///
/// \param default_translation Default translation for the map.
/// \param notify_cb Callback function to notify the mapping.
/// \param cb_ctx Argument passed to the callback function.
///
/// \return a pointer to the allocated virtual memory address translation map. 
 # [ link_name = "\u{1}_Z18spdk_mem_map_alloc" ] pub fn spdk_mem_map_alloc ( default_translation : u64 , notify_cb : spdk_mem_map_notify_cb , cb_ctx : * mut :: std :: os :: raw :: c_void ) -> * mut spdk_mem_map ; } extern "C" { 
 /// Free a memory map previously allocated by spdk_mem_map_alloc().
///
/// \param pmap Memory map to free. 
 # [ link_name = "\u{1}_Z17spdk_mem_map_free" ] pub fn spdk_mem_map_free ( pmap : * mut * mut spdk_mem_map ) ; } extern "C" { 
 /// Register an address translation for a range of virtual memory.
///
/// \param map Memory map.
/// \param vaddr Virtual address of the region to register - must be 2 MB aligned.
/// \param size Size of the region in bytes - must be multiple of 2 MB in the
/// current implementation.
/// \param translation Translation to store in the map for this address range.
///
/// \sa spdk_mem_map_clear_translation().
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z28spdk_mem_map_set_translation" ] pub fn spdk_mem_map_set_translation ( map : * mut spdk_mem_map , vaddr : u64 , size : u64 , translation : u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Unregister an address translation.
///
/// \param map Memory map.
/// \param vaddr Virtual address of the region to unregister - must be 2 MB aligned.
/// \param size Size of the region in bytes - must be multiple of 2 MB in the
/// current implementation.
///
/// \sa spdk_mem_map_set_translation().
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z30spdk_mem_map_clear_translation" ] pub fn spdk_mem_map_clear_translation ( map : * mut spdk_mem_map , vaddr : u64 , size : u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Look up the translation of a virtual address in a memory map.
///
/// \param map Memory map.
/// \param vaddr Virtual address.
///
/// \return the translation of 2MB hugepage mapping. 
 # [ link_name = "\u{1}_Z22spdk_mem_map_translate" ] pub fn spdk_mem_map_translate ( map : * const spdk_mem_map , vaddr : u64 ) -> u64 ; } extern "C" { 
 /// Register the specified memory region for address translation.
///
/// The memory region must map to pinned huge pages (2MB or greater).
///
/// \param vaddr Virtual address to register.
/// \param len Length in bytes of the vaddr.
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z17spdk_mem_register" ] pub fn spdk_mem_register ( vaddr : * mut :: std :: os :: raw :: c_void , len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Unregister the specified memory region from vtophys address translation.
///
/// The caller must ensure all in-flight DMA operations to this memory region
/// are completed or cancelled before calling this function.
///
/// \param vaddr Virtual address to unregister.
/// \param leng Length in bytes of the vaddr.
///
/// \return 0 on success, negative errno on failure. 
 # [ link_name = "\u{1}_Z19spdk_mem_unregister" ] pub fn spdk_mem_unregister ( vaddr : * mut :: std :: os :: raw :: c_void , len : usize ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cap_register { pub raw : u64 , pub bits : spdk_nvme_cap_register__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cap_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cap_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cap_register__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cap_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cap_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cap_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cap_register__bindgen_ty_1 { # [ inline ] pub fn mqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 5u8 , val as u64 ) } } # [ inline ] pub fn to ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_to ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn dstrd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_dstrd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 4u8 , val as u64 ) } } # [ inline ] pub fn nssrs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 36usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssrs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 36usize , 1u8 , val as u64 ) } } # [ inline ] pub fn css_nvm ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 37usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_css_nvm ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 37usize , 1u8 , val as u64 ) } } # [ inline ] pub fn css_reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 38usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set_css_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 38usize , 7u8 , val as u64 ) } } # [ inline ] pub fn bps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 45usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 45usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 46usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 46usize , 2u8 , val as u64 ) } } # [ inline ] pub fn mpsmin ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmin ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 4u8 , val as u64 ) } } # [ inline ] pub fn mpsmax ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 52usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmax ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 52usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mqes : u32 , cqr : u32 , ams : u32 , reserved1 : u32 , to : u32 , dstrd : u32 , nssrs : u32 , css_nvm : u32 , css_reserved : u32 , bps : u32 , reserved2 : u32 , mpsmin : u32 , mpsmax : u32 , reserved3 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let mqes : u32 = unsafe { :: std :: mem :: transmute ( mqes ) } ; mqes as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cqr : u32 = unsafe { :: std :: mem :: transmute ( cqr ) } ; cqr as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 2u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let to : u32 = unsafe { :: std :: mem :: transmute ( to ) } ; to as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 4u8 , { let dstrd : u32 = unsafe { :: std :: mem :: transmute ( dstrd ) } ; dstrd as u64 } ) ; __bindgen_bitfield_unit . set ( 36usize , 1u8 , { let nssrs : u32 = unsafe { :: std :: mem :: transmute ( nssrs ) } ; nssrs as u64 } ) ; __bindgen_bitfield_unit . set ( 37usize , 1u8 , { let css_nvm : u32 = unsafe { :: std :: mem :: transmute ( css_nvm ) } ; css_nvm as u64 } ) ; __bindgen_bitfield_unit . set ( 38usize , 7u8 , { let css_reserved : u32 = unsafe { :: std :: mem :: transmute ( css_reserved ) } ; css_reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 45usize , 1u8 , { let bps : u32 = unsafe { :: std :: mem :: transmute ( bps ) } ; bps as u64 } ) ; __bindgen_bitfield_unit . set ( 46usize , 2u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 4u8 , { let mpsmin : u32 = unsafe { :: std :: mem :: transmute ( mpsmin ) } ; mpsmin as u64 } ) ; __bindgen_bitfield_unit . set ( 52usize , 4u8 , { let mpsmax : u32 = unsafe { :: std :: mem :: transmute ( mpsmax ) } ; mpsmax as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let reserved3 : u32 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cap_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cap_register > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cap_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cap_register > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cap_register ) ) ) ; } impl Default for spdk_nvme_cap_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cc_register { pub raw : u32 , pub bits : spdk_nvme_cc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cc_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cc_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cc_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cc_register__bindgen_ty_1 { # [ inline ] pub fn en ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_en ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn css ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_css ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn mps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 3u8 , val as u64 ) } } # [ inline ] pub fn shn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn iosqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iosqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn iocqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iocqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( en : u32 , reserved1 : u32 , css : u32 , mps : u32 , ams : u32 , shn : u32 , iosqes : u32 , iocqes : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let en : u32 = unsafe { :: std :: mem :: transmute ( en ) } ; en as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let css : u32 = unsafe { :: std :: mem :: transmute ( css ) } ; css as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 4u8 , { let mps : u32 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 3u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let shn : u32 = unsafe { :: std :: mem :: transmute ( shn ) } ; shn as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let iosqes : u32 = unsafe { :: std :: mem :: transmute ( iosqes ) } ; iosqes as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 4u8 , { let iocqes : u32 = unsafe { :: std :: mem :: transmute ( iocqes ) } ; iocqes as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cc_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cc_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cc_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cc_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cc_register ) ) ) ; } impl Default for spdk_nvme_cc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shn_value_SPDK_NVME_SHN_NORMAL : spdk_nvme_shn_value = 1 ; pub const spdk_nvme_shn_value_SPDK_NVME_SHN_ABRUPT : spdk_nvme_shn_value = 2 ; pub type spdk_nvme_shn_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_csts_register { pub raw : u32 , pub bits : spdk_nvme_csts_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_csts_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_csts_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_csts_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_csts_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_csts_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_csts_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_csts_register__bindgen_ty_1 { # [ inline ] pub fn rdy ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rdy ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cfs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cfs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn shst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn nssro ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssro ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( rdy : u32 , cfs : u32 , shst : u32 , nssro : u32 , pp : u32 , reserved1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let rdy : u32 = unsafe { :: std :: mem :: transmute ( rdy ) } ; rdy as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cfs : u32 = unsafe { :: std :: mem :: transmute ( cfs ) } ; cfs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let shst : u32 = unsafe { :: std :: mem :: transmute ( shst ) } ; shst as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let nssro : u32 = unsafe { :: std :: mem :: transmute ( nssro ) } ; nssro as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let pp : u32 = unsafe { :: std :: mem :: transmute ( pp ) } ; pp as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_csts_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_csts_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_csts_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_csts_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_csts_register ) ) ) ; } impl Default for spdk_nvme_csts_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shst_value_SPDK_NVME_SHST_NORMAL : spdk_nvme_shst_value = 0 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_OCCURRING : spdk_nvme_shst_value = 1 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_COMPLETE : spdk_nvme_shst_value = 2 ; pub type spdk_nvme_shst_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_aqa_register { pub raw : u32 , pub bits : spdk_nvme_aqa_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_aqa_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_aqa_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_aqa_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_aqa_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_aqa_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_aqa_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_aqa_register__bindgen_ty_1 { # [ inline ] pub fn asqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_asqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn acqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_acqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( asqs : u32 , reserved1 : u32 , acqs : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 12u8 , { let asqs : u32 = unsafe { :: std :: mem :: transmute ( asqs ) } ; asqs as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 12u8 , { let acqs : u32 = unsafe { :: std :: mem :: transmute ( acqs ) } ; acqs as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 4u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_aqa_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_aqa_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_aqa_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_aqa_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_aqa_register ) ) ) ; } impl Default for spdk_nvme_aqa_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_vs_register { pub raw : u32 , pub bits : spdk_nvme_vs_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_vs_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_vs_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_vs_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_vs_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_vs_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_vs_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_vs_register__bindgen_ty_1 { # [ inline ] pub fn ter ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_ter ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mnr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mnr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mjr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mjr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ter : u32 , mnr : u32 , mjr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let ter : u32 = unsafe { :: std :: mem :: transmute ( ter ) } ; ter as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let mnr : u32 = unsafe { :: std :: mem :: transmute ( mnr ) } ; mnr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let mjr : u32 = unsafe { :: std :: mem :: transmute ( mjr ) } ; mjr as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_vs_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_vs_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_vs_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_vs_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_vs_register ) ) ) ; } impl Default for spdk_nvme_vs_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbloc_register { pub raw : u32 , pub bits : spdk_nvme_cmbloc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbloc_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbloc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbloc_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbloc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbloc_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cmbloc_register__bindgen_ty_1 { # [ inline ] pub fn bir ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_bir ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 9u8 , val as u64 ) } } # [ inline ] pub fn ofst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_ofst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bir : u32 , reserved1 : u32 , ofst : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let bir : u32 = unsafe { :: std :: mem :: transmute ( bir ) } ; bir as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let ofst : u32 = unsafe { :: std :: mem :: transmute ( ofst ) } ; ofst as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbloc_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbloc_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbloc_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbloc_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbloc_register ) ) ) ; } impl Default for spdk_nvme_cmbloc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbsz_register { pub raw : u32 , pub bits : spdk_nvme_cmbsz_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbsz_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbsz_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbsz_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbsz_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbsz_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cmbsz_register__bindgen_ty_1 { # [ inline ] pub fn sqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lists ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_lists ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn szu ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_szu ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn sz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_sz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( sqs : u32 , cqs : u32 , lists : u32 , rds : u32 , wds : u32 , reserved1 : u32 , szu : u32 , sz : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let sqs : u32 = unsafe { :: std :: mem :: transmute ( sqs ) } ; sqs as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cqs : u32 = unsafe { :: std :: mem :: transmute ( cqs ) } ; cqs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let lists : u32 = unsafe { :: std :: mem :: transmute ( lists ) } ; lists as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let rds : u32 = unsafe { :: std :: mem :: transmute ( rds ) } ; rds as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let wds : u32 = unsafe { :: std :: mem :: transmute ( wds ) } ; wds as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let szu : u32 = unsafe { :: std :: mem :: transmute ( szu ) } ; szu as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let sz : u32 = unsafe { :: std :: mem :: transmute ( sz ) } ; sz as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbsz_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbsz_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbsz_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbsz_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbsz_register ) ) ) ; } impl Default for spdk_nvme_cmbsz_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Boot partition information 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bpinfo_register { pub raw : u32 , pub bits : spdk_nvme_bpinfo_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_bpinfo_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bpinfo_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bpinfo_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bpinfo_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bpinfo_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_bpinfo_register__bindgen_ty_1 { # [ inline ] pub fn bpsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_bpsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 15u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 9u8 , val as u64 ) } } # [ inline ] pub fn brs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_brs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 5u8 , val as u64 ) } } # [ inline ] pub fn abpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_abpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bpsz : u32 , reserved1 : u32 , brs : u32 , reserved2 : u32 , abpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 15u8 , { let bpsz : u32 = unsafe { :: std :: mem :: transmute ( bpsz ) } ; bpsz as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let brs : u32 = unsafe { :: std :: mem :: transmute ( brs ) } ; brs as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 5u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let abpid : u32 = unsafe { :: std :: mem :: transmute ( abpid ) } ; abpid as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_bpinfo_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bpinfo_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bpinfo_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bpinfo_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bpinfo_register ) ) ) ; } impl Default for spdk_nvme_bpinfo_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Boot partition read select 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bprsel_register { pub raw : u32 , pub bits : spdk_nvme_bprsel_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bprsel_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_bprsel_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bprsel_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bprsel_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bprsel_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bprsel_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_bprsel_register__bindgen_ty_1 { # [ inline ] pub fn bprsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_bprsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 10u8 , val as u64 ) } } # [ inline ] pub fn bprof ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_bprof ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 20u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bprsz : u32 , bprof : u32 , reserved : u32 , bpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 10u8 , { let bprsz : u32 = unsafe { :: std :: mem :: transmute ( bprsz ) } ; bprsz as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 20u8 , { let bprof : u32 = unsafe { :: std :: mem :: transmute ( bprof ) } ; bprof as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let bpid : u32 = unsafe { :: std :: mem :: transmute ( bpid ) } ; bpid as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_bprsel_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bprsel_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bprsel_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bprsel_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bprsel_register ) ) ) ; } impl Default for spdk_nvme_bprsel_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_registers { 
 /// controller capabilities 
 pub cap : spdk_nvme_cap_register , 
 /// version of NVMe specification 
 pub vs : spdk_nvme_vs_register , pub intms : u32 , pub intmc : u32 , 
 /// controller configuration 
 pub cc : spdk_nvme_cc_register , pub reserved1 : u32 , pub csts : spdk_nvme_csts_register , pub nssr : u32 , 
 /// admin queue attributes 
 pub aqa : spdk_nvme_aqa_register , pub asq : u64 , pub acq : u64 , 
 /// controller memory buffer location 
 pub cmbloc : spdk_nvme_cmbloc_register , 
 /// controller memory buffer size 
 pub cmbsz : spdk_nvme_cmbsz_register , 
 /// boot partition information 
 pub bpinfo : spdk_nvme_bpinfo_register , 
 /// boot partition read select 
 pub bprsel : spdk_nvme_bprsel_register , 
 /// boot partition memory buffer location (must be 4KB aligned) 
 pub bpmbl : u64 , pub reserved3 : [ u32 ; 1004usize ] , pub doorbell : [ spdk_nvme_registers__bindgen_ty_1 ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registers__bindgen_ty_1 { pub sq_tdbl : u32 , pub cq_hdbl : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvme_registers__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_registers__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_registers__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_registers__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_registers__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvme_registers ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_registers > ( ) , 4104usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_registers ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_registers > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_registers ) ) ) ; } impl Default for spdk_nvme_registers { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 0 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_BIT_BUCKET : spdk_nvme_sgl_descriptor_type = 1 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_SEGMENT : spdk_nvme_sgl_descriptor_type = 2 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_LAST_SEGMENT : spdk_nvme_sgl_descriptor_type = 3 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 4 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC : spdk_nvme_sgl_descriptor_type = 15 ; pub type spdk_nvme_sgl_descriptor_type = u32 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_ADDRESS : spdk_nvme_sgl_descriptor_subtype = 0 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_OFFSET : spdk_nvme_sgl_descriptor_subtype = 1 ; pub type spdk_nvme_sgl_descriptor_subtype = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor { pub address : u64 , pub __bindgen_anon_1 : spdk_nvme_sgl_descriptor__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 { pub generic : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 , pub unkeyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 , pub keyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { pub reserved : [ u8 ; 7usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { pub length : u32 , pub reserved : [ u8 ; 3usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) ) ; } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub __bindgen_align : [ u64 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ) ) ; } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { # [ inline ] pub fn length ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u64 ) } } # [ inline ] pub fn set_length ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn key ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 32u8 ) as u64 ) } } # [ inline ] pub fn set_key ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 32u8 , val as u64 ) } } # [ inline ] pub fn subtype ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 60usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_type ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 60usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( length : u64 , key : u64 , subtype : u64 , type_ : u64 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let length : u64 = unsafe { :: std :: mem :: transmute ( length ) } ; length as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 32u8 , { let key : u64 = unsafe { :: std :: mem :: transmute ( key ) } ; key as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 4u8 , { let subtype : u64 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 60usize , 4u8 , { let type_ : u64 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor ) ) ) ; } impl Default for spdk_nvme_sgl_descriptor { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_PRP : spdk_nvme_psdt_value = 0 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_CONTIG : spdk_nvme_psdt_value = 1 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_SGL : spdk_nvme_psdt_value = 2 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_RESERVED : spdk_nvme_psdt_value = 3 ; pub type spdk_nvme_psdt_value = u32 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_URGENT : spdk_nvme_qprio = 0 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_HIGH : spdk_nvme_qprio = 1 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_MEDIUM : spdk_nvme_qprio = 2 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_LOW : spdk_nvme_qprio = 3 ; 
 /// Submission queue priority values for Create I/O Submission Queue Command.
///
/// Only valid for weighted round robin arbitration method. 
 pub type spdk_nvme_qprio = u32 ; 
 /// < weighted round robin 
 pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_WRR : spdk_nvme_cap_ams = 1 ; 
 /// < vendor specific 
 pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_VS : spdk_nvme_cap_ams = 2 ; 
 /// Optional Arbitration Mechanism Supported by the controller.
///
/// Two bits for CAP.AMS (18:17) field are set to '1' when the controller supports.
/// There is no bit for AMS_RR where all controllers support and set to 0x0 by default. 
 pub type spdk_nvme_cap_ams = u32 ; 
 /// < default round robin 
 pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_RR : spdk_nvme_cc_ams = 0 ; 
 /// < weighted round robin 
 pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_WRR : spdk_nvme_cc_ams = 1 ; 
 /// < vendor specific 
 pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_VS : spdk_nvme_cc_ams = 7 ; 
 /// Arbitration Mechanism Selected to the controller.
///
/// Value 0x2 to 0x6 is reserved. 
 pub type spdk_nvme_cc_ams = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmd { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub cid : u16 , pub nsid : u32 , pub rsvd2 : u32 , pub rsvd3 : u32 , pub mptr : u64 , pub dptr : spdk_nvme_cmd__bindgen_ty_1 , pub cdw10 : u32 , pub cdw11 : u32 , pub cdw12 : u32 , pub cdw13 : u32 , pub cdw14 : u32 , pub cdw15 : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmd__bindgen_ty_1 { pub prp : spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 , pub sgl1 : spdk_nvme_sgl_descriptor , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 { pub prp1 : u64 , pub prp2 : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmd__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmd__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_cmd__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmd > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmd ) ) ) ; } impl Default for spdk_nvme_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_cmd { # [ inline ] pub fn opc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_opc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn fuse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_fuse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn rsvd1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 4u8 , val as u64 ) } } # [ inline ] pub fn psdt ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_psdt ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opc : u16 , fuse : u16 , rsvd1 : u16 , psdt : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let opc : u16 = unsafe { :: std :: mem :: transmute ( opc ) } ; opc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let fuse : u16 = unsafe { :: std :: mem :: transmute ( fuse ) } ; fuse as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 4u8 , { let rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( rsvd1 ) } ; rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let psdt : u16 = unsafe { :: std :: mem :: transmute ( psdt ) } ; psdt as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_status { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_status ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_status > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_status ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_status > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_status ) ) ) ; } impl spdk_nvme_status { # [ inline ] pub fn p ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_p ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_sc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 8u8 , val as u64 ) } } # [ inline ] pub fn sct ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_sct ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rsvd2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn m ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_m ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dnr ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dnr ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( p : u16 , sc : u16 , sct : u16 , rsvd2 : u16 , m : u16 , dnr : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let p : u16 = unsafe { :: std :: mem :: transmute ( p ) } ; p as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 8u8 , { let sc : u16 = unsafe { :: std :: mem :: transmute ( sc ) } ; sc as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let sct : u16 = unsafe { :: std :: mem :: transmute ( sct ) } ; sct as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( rsvd2 ) } ; rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let m : u16 = unsafe { :: std :: mem :: transmute ( m ) } ; m as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let dnr : u16 = unsafe { :: std :: mem :: transmute ( dnr ) } ; dnr as u64 } ) ; __bindgen_bitfield_unit } } 
 /// Completion queue entry 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cpl { pub cdw0 : u32 , pub rsvd1 : u32 , pub sqhd : u16 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ test ] fn bindgen_test_layout_spdk_nvme_cpl ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cpl > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cpl ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cpl > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cpl ) ) ) ; } 
 /// Dataset Management range 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_dsm_range { pub attributes : spdk_nvme_dsm_range__bindgen_ty_1 , pub length : u32 , pub starting_lba : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_dsm_range__bindgen_ty_1 { pub bits : spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 , pub raw : u32 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn af ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_af ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn al ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_al ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn sr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn access_size ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_access_size ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( af : u32 , al : u32 , reserved0 : u32 , sr : u32 , sw : u32 , wp : u32 , reserved1 : u32 , access_size : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let af : u32 = unsafe { :: std :: mem :: transmute ( af ) } ; af as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let al : u32 = unsafe { :: std :: mem :: transmute ( al ) } ; al as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved0 : u32 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let sr : u32 = unsafe { :: std :: mem :: transmute ( sr ) } ; sr as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let sw : u32 = unsafe { :: std :: mem :: transmute ( sw ) } ; sw as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let wp : u32 = unsafe { :: std :: mem :: transmute ( wp ) } ; wp as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let access_size : u32 = unsafe { :: std :: mem :: transmute ( access_size ) } ; access_size as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_dsm_range__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_dsm_range__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_dsm_range__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_dsm_range ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_dsm_range > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_dsm_range > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_dsm_range ) ) ) ; } impl Default for spdk_nvme_dsm_range { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_GENERIC : spdk_nvme_status_code_type = 0 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_COMMAND_SPECIFIC : spdk_nvme_status_code_type = 1 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_MEDIA_ERROR : spdk_nvme_status_code_type = 2 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_VENDOR_SPECIFIC : spdk_nvme_status_code_type = 7 ; 
 /// Status code types 
 pub type spdk_nvme_status_code_type = u32 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SUCCESS : spdk_nvme_generic_command_status_code = 0 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_OPCODE : spdk_nvme_generic_command_status_code = 1 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_FIELD : spdk_nvme_generic_command_status_code = 2 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_ID_CONFLICT : spdk_nvme_generic_command_status_code = 3 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_TRANSFER_ERROR : spdk_nvme_generic_command_status_code = 4 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_POWER_LOSS : spdk_nvme_generic_command_status_code = 5 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INTERNAL_DEVICE_ERROR : spdk_nvme_generic_command_status_code = 6 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_BY_REQUEST : spdk_nvme_generic_command_status_code = 7 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_SQ_DELETION : spdk_nvme_generic_command_status_code = 8 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_FAILED_FUSED : spdk_nvme_generic_command_status_code = 9 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_MISSING_FUSED : spdk_nvme_generic_command_status_code = 10 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT : spdk_nvme_generic_command_status_code = 11 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR : spdk_nvme_generic_command_status_code = 12 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR : spdk_nvme_generic_command_status_code = 13 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS : spdk_nvme_generic_command_status_code = 14 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 15 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 16 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID : spdk_nvme_generic_command_status_code = 17 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF : spdk_nvme_generic_command_status_code = 18 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_PRP_OFFSET : spdk_nvme_generic_command_status_code = 19 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED : spdk_nvme_generic_command_status_code = 20 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_OPERATION_DENIED : spdk_nvme_generic_command_status_code = 21 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_OFFSET : spdk_nvme_generic_command_status_code = 22 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT : spdk_nvme_generic_command_status_code = 24 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_EXPIRED : spdk_nvme_generic_command_status_code = 25 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_INVALID : spdk_nvme_generic_command_status_code = 26 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_PREEMPT : spdk_nvme_generic_command_status_code = 27 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_FAILED : spdk_nvme_generic_command_status_code = 28 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_IN_PROGRESS : spdk_nvme_generic_command_status_code = 29 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID : spdk_nvme_generic_command_status_code = 30 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_INVALID_IN_CMB : spdk_nvme_generic_command_status_code = 31 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_LBA_OUT_OF_RANGE : spdk_nvme_generic_command_status_code = 128 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_CAPACITY_EXCEEDED : spdk_nvme_generic_command_status_code = 129 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_NAMESPACE_NOT_READY : spdk_nvme_generic_command_status_code = 130 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_RESERVATION_CONFLICT : spdk_nvme_generic_command_status_code = 131 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_FORMAT_IN_PROGRESS : spdk_nvme_generic_command_status_code = 132 ; 
 /// Generic command status codes 
 pub type spdk_nvme_generic_command_status_code = u32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_COMPLETION_QUEUE_INVALID : spdk_nvme_command_specific_status_code = 0 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER : spdk_nvme_command_specific_status_code = 1 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED : spdk_nvme_command_specific_status_code = 2 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 3 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 5 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_SLOT : spdk_nvme_command_specific_status_code = 6 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE : spdk_nvme_command_specific_status_code = 7 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR : spdk_nvme_command_specific_status_code = 8 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_LOG_PAGE : spdk_nvme_command_specific_status_code = 9 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FORMAT : spdk_nvme_command_specific_status_code = 10 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET : spdk_nvme_command_specific_status_code = 11 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_DELETION : spdk_nvme_command_specific_status_code = 12 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE : spdk_nvme_command_specific_status_code = 13 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE : spdk_nvme_command_specific_status_code = 14 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC : spdk_nvme_command_specific_status_code = 15 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET : spdk_nvme_command_specific_status_code = 16 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_RESET : spdk_nvme_command_specific_status_code = 17 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION : spdk_nvme_command_specific_status_code = 18 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED : spdk_nvme_command_specific_status_code = 19 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_OVERLAPPING_RANGE : spdk_nvme_command_specific_status_code = 20 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY : spdk_nvme_command_specific_status_code = 21 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE : spdk_nvme_command_specific_status_code = 22 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED : spdk_nvme_command_specific_status_code = 24 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_IS_PRIVATE : spdk_nvme_command_specific_status_code = 25 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED : spdk_nvme_command_specific_status_code = 26 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED : spdk_nvme_command_specific_status_code = 27 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONTROLLER_LIST_INVALID : spdk_nvme_command_specific_status_code = 28 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS : spdk_nvme_command_specific_status_code = 29 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED : spdk_nvme_command_specific_status_code = 30 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_CTRLR_ID : spdk_nvme_command_specific_status_code = 31 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE : spdk_nvme_command_specific_status_code = 32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES : spdk_nvme_command_specific_status_code = 33 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_RESOURCE_ID : spdk_nvme_command_specific_status_code = 34 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONFLICTING_ATTRIBUTES : spdk_nvme_command_specific_status_code = 128 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_PROTECTION_INFO : spdk_nvme_command_specific_status_code = 129 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE : spdk_nvme_command_specific_status_code = 130 ; 
 /// Command specific status codes 
 pub type spdk_nvme_command_specific_status_code = u32 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_WRITE_FAULTS : spdk_nvme_media_error_status_code = 128 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_UNRECOVERED_READ_ERROR : spdk_nvme_media_error_status_code = 129 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_GUARD_CHECK_ERROR : spdk_nvme_media_error_status_code = 130 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 131 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 132 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_COMPARE_FAILURE : spdk_nvme_media_error_status_code = 133 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_ACCESS_DENIED : spdk_nvme_media_error_status_code = 134 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK : spdk_nvme_media_error_status_code = 135 ; 
 /// Media error status codes 
 pub type spdk_nvme_media_error_status_code = u32 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_SQ : spdk_nvme_admin_opcode = 0 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_SQ : spdk_nvme_admin_opcode = 1 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LOG_PAGE : spdk_nvme_admin_opcode = 2 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_CQ : spdk_nvme_admin_opcode = 4 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_CQ : spdk_nvme_admin_opcode = 5 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_IDENTIFY : spdk_nvme_admin_opcode = 6 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ABORT : spdk_nvme_admin_opcode = 8 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SET_FEATURES : spdk_nvme_admin_opcode = 9 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_FEATURES : spdk_nvme_admin_opcode = 10 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ASYNC_EVENT_REQUEST : spdk_nvme_admin_opcode = 12 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_MANAGEMENT : spdk_nvme_admin_opcode = 13 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_COMMIT : spdk_nvme_admin_opcode = 16 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD : spdk_nvme_admin_opcode = 17 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DEVICE_SELF_TEST : spdk_nvme_admin_opcode = 20 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_ATTACHMENT : spdk_nvme_admin_opcode = 21 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_KEEP_ALIVE : spdk_nvme_admin_opcode = 24 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_SEND : spdk_nvme_admin_opcode = 25 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_RECEIVE : spdk_nvme_admin_opcode = 26 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT : spdk_nvme_admin_opcode = 28 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_SEND : spdk_nvme_admin_opcode = 29 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_RECEIVE : spdk_nvme_admin_opcode = 30 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG : spdk_nvme_admin_opcode = 124 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FORMAT_NVM : spdk_nvme_admin_opcode = 128 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_SEND : spdk_nvme_admin_opcode = 129 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_RECEIVE : spdk_nvme_admin_opcode = 130 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SANITIZE : spdk_nvme_admin_opcode = 132 ; 
 /// Admin opcodes 
 pub type spdk_nvme_admin_opcode = u32 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_FLUSH : spdk_nvme_nvm_opcode = 0 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE : spdk_nvme_nvm_opcode = 1 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_READ : spdk_nvme_nvm_opcode = 2 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_UNCORRECTABLE : spdk_nvme_nvm_opcode = 4 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_COMPARE : spdk_nvme_nvm_opcode = 5 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_ZEROES : spdk_nvme_nvm_opcode = 8 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_DATASET_MANAGEMENT : spdk_nvme_nvm_opcode = 9 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REGISTER : spdk_nvme_nvm_opcode = 13 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REPORT : spdk_nvme_nvm_opcode = 14 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_ACQUIRE : spdk_nvme_nvm_opcode = 17 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_RELEASE : spdk_nvme_nvm_opcode = 21 ; 
 /// NVM command set opcodes 
 pub type spdk_nvme_nvm_opcode = u32 ; 
 /// Opcode does not transfer data 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_NONE : spdk_nvme_data_transfer = 0 ; 
 /// Opcode transfers data from host to controller (e.g. Write) 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_HOST_TO_CONTROLLER : spdk_nvme_data_transfer = 1 ; 
 /// Opcode transfers data from controller to host (e.g. Read) 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_CONTROLLER_TO_HOST : spdk_nvme_data_transfer = 2 ; 
 /// Opcode transfers data both directions 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_BIDIRECTIONAL : spdk_nvme_data_transfer = 3 ; 
 /// Data transfer (bits 1:0) of an NVMe opcode.
///
/// \sa spdk_nvme_opc_get_data_transfer 
 pub type spdk_nvme_data_transfer = u32 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ARBITRATION : spdk_nvme_feat = 1 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_POWER_MANAGEMENT : spdk_nvme_feat = 2 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_RANGE_TYPE : spdk_nvme_feat = 3 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD : spdk_nvme_feat = 4 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ERROR_RECOVERY : spdk_nvme_feat = 5 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE : spdk_nvme_feat = 6 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NUMBER_OF_QUEUES : spdk_nvme_feat = 7 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_COALESCING : spdk_nvme_feat = 8 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION : spdk_nvme_feat = 9 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_WRITE_ATOMICITY : spdk_nvme_feat = 10 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION : spdk_nvme_feat = 11 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION : spdk_nvme_feat = 12 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_MEM_BUFFER : spdk_nvme_feat = 13 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TIMESTAMP : spdk_nvme_feat = 14 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_KEEP_ALIVE_TIMER : spdk_nvme_feat = 15 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT : spdk_nvme_feat = 16 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG : spdk_nvme_feat = 17 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER : spdk_nvme_feat = 128 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_IDENTIFIER : spdk_nvme_feat = 129 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_MASK : spdk_nvme_feat = 130 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_PERSIST : spdk_nvme_feat = 131 ; pub type spdk_nvme_feat = u32 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_READ : spdk_nvme_dsm_attribute = 1 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE : spdk_nvme_dsm_attribute = 2 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_DEALLOCATE : spdk_nvme_dsm_attribute = 4 ; pub type spdk_nvme_dsm_attribute = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_power_state { pub mp : u16 , pub reserved1 : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub enlat : u32 , pub exlat : u32 , pub _bitfield_2 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub reserved7 : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_power_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_power_state > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_power_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_power_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_power_state ) ) ) ; } impl spdk_nvme_power_state { # [ inline ] pub fn mps ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nops ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_nops ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mps : u8 , nops : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let mps : u8 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let nops : u8 = unsafe { :: std :: mem :: transmute ( nops ) } ; nops as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } # [ inline ] pub fn rrt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rrl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 8usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 8usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 13usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 16usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 16usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved5 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 21usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved5 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 21usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 24usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 24usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 29usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 29usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_2 ( rrt : u8 , reserved3 : u8 , rrl : u8 , reserved4 : u8 , rwt : u8 , reserved5 : u8 , rwl : u8 , reserved6 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let rrt : u8 = unsafe { :: std :: mem :: transmute ( rrt ) } ; rrt as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 5u8 , { let rrl : u8 = unsafe { :: std :: mem :: transmute ( rrl ) } ; rrl as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 5u8 , { let rwt : u8 = unsafe { :: std :: mem :: transmute ( rwt ) } ; rwt as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 3u8 , { let reserved5 : u8 = unsafe { :: std :: mem :: transmute ( reserved5 ) } ; reserved5 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 5u8 , { let rwl : u8 = unsafe { :: std :: mem :: transmute ( rwl ) } ; rwl as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 3u8 , { let reserved6 : u8 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// Identify namespace indicated in CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS : spdk_nvme_identify_cns = 0 ; 
 /// Identify controller 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR : spdk_nvme_identify_cns = 1 ; 
 /// List active NSIDs greater than CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST : spdk_nvme_identify_cns = 2 ; 
 /// List namespace identification descriptors 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST : spdk_nvme_identify_cns = 3 ; 
 /// List allocated NSIDs greater than CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST : spdk_nvme_identify_cns = 16 ; 
 /// Identify namespace if CDW1.NSID is allocated 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED : spdk_nvme_identify_cns = 17 ; 
 /// Get list of controllers starting at CDW10.CNTID that are attached to CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST : spdk_nvme_identify_cns = 18 ; 
 /// Get list of controllers starting at CDW10.CNTID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_LIST : spdk_nvme_identify_cns = 19 ; 
 /// Get primary controller capabilities structure 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP : spdk_nvme_identify_cns = 20 ; 
 /// Get secondary controller list 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST : spdk_nvme_identify_cns = 21 ; 
 /// Identify command CNS value 
 pub type spdk_nvme_identify_cns = u32 ; 
 /// NVM subsystem uses dynamic controller model 
 pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_DYNAMIC : spdk_nvmf_ctrlr_model = 0 ; 
 /// NVM subsystem uses static controller model 
 pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_STATIC : spdk_nvmf_ctrlr_model = 1 ; 
 /// NVMe over Fabrics controller model 
 pub type spdk_nvmf_ctrlr_model = u32 ; 
 /// SGLs are not supported 
 pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_NOT_SUPPORTED : spdk_nvme_sgls_supported = 0 ; 
 /// SGLs are supported with no alignment or granularity requirement. 
 pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED : spdk_nvme_sgls_supported = 1 ; 
 /// SGLs are supported with a DWORD alignment and granularity requirement. 
 pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED : spdk_nvme_sgls_supported = 2 ; 
 /// Identify Controller data sgls.supported values 
 pub type spdk_nvme_sgls_supported = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data { 
 /// pci vendor id 
 pub vid : u16 , 
 /// pci subsystem vendor id 
 pub ssvid : u16 , 
 /// serial number 
 pub sn : [ i8 ; 20usize ] , 
 /// model number 
 pub mn : [ i8 ; 40usize ] , 
 /// firmware revision 
 pub fr : [ u8 ; 8usize ] , 
 /// recommended arbitration burst 
 pub rab : u8 , 
 /// ieee oui identifier 
 pub ieee : [ u8 ; 3usize ] , pub cmic : spdk_nvme_ctrlr_data__bindgen_ty_1 , 
 /// maximum data transfer size 
 pub mdts : u8 , 
 /// controller id 
 pub cntlid : u16 , 
 /// version 
 pub ver : spdk_nvme_vs_register , 
 /// RTD3 resume latency 
 pub rtd3r : u32 , 
 /// RTD3 entry latency 
 pub rtd3e : u32 , pub oaes : spdk_nvme_ctrlr_data__bindgen_ty_2 , pub ctratt : spdk_nvme_ctrlr_data__bindgen_ty_3 , pub reserved_100 : [ u8 ; 12usize ] , 
 /// FRU globally unique identifier 
 pub fguid : [ u8 ; 16usize ] , pub reserved_128 : [ u8 ; 128usize ] , pub oacs : spdk_nvme_ctrlr_data__bindgen_ty_4 , 
 /// abort command limit 
 pub acl : u8 , 
 /// asynchronous event request limit 
 pub aerl : u8 , pub frmw : spdk_nvme_ctrlr_data__bindgen_ty_5 , pub lpa : spdk_nvme_ctrlr_data__bindgen_ty_6 , 
 /// error log page entries 
 pub elpe : u8 , 
 /// number of power states supported 
 pub npss : u8 , pub avscc : spdk_nvme_ctrlr_data__bindgen_ty_7 , pub apsta : spdk_nvme_ctrlr_data__bindgen_ty_8 , 
 /// warning composite temperature threshold 
 pub wctemp : u16 , 
 /// critical composite temperature threshold 
 pub cctemp : u16 , 
 /// maximum time for firmware activation 
 pub mtfa : u16 , 
 /// host memory buffer preferred size 
 pub hmpre : u32 , 
 /// host memory buffer minimum size 
 pub hmmin : u32 , 
 /// total NVM capacity 
 pub tnvmcap : [ u64 ; 2usize ] , 
 /// unallocated NVM capacity 
 pub unvmcap : [ u64 ; 2usize ] , pub rpmbs : spdk_nvme_ctrlr_data__bindgen_ty_9 , 
 /// extended device self-test time (in minutes) 
 pub edstt : u16 , pub dsto : spdk_nvme_ctrlr_data__bindgen_ty_10 , 
 /// Firmware update granularity
    ///
    /// 4KB units
    /// 0x00 = no information provided
    /// 0xFF = no restriction 
 pub fwug : u8 , 
 /// Keep Alive Support
    ///
    /// Granularity of keep alive timer in 100 ms units
    /// 0 = keep alive not supported 
 pub kas : u16 , pub hctma : spdk_nvme_ctrlr_data__bindgen_ty_11 , 
 /// Minimum thermal management temperature 
 pub mntmt : u16 , 
 /// Maximum thermal management temperature 
 pub mxtmt : u16 , pub sanicap : spdk_nvme_ctrlr_data__bindgen_ty_12 , pub reserved3 : [ u8 ; 180usize ] , pub sqes : spdk_nvme_ctrlr_data__bindgen_ty_13 , pub cqes : spdk_nvme_ctrlr_data__bindgen_ty_14 , pub maxcmd : u16 , 
 /// number of namespaces 
 pub nn : u32 , pub oncs : spdk_nvme_ctrlr_data__bindgen_ty_15 , 
 /// fused operation support 
 pub fuses : u16 , pub fna : spdk_nvme_ctrlr_data__bindgen_ty_16 , pub vwc : spdk_nvme_ctrlr_data__bindgen_ty_17 , 
 /// atomic write unit normal 
 pub awun : u16 , 
 /// atomic write unit power fail 
 pub awupf : u16 , 
 /// NVM vendor specific command configuration 
 pub nvscc : u8 , pub reserved531 : u8 , 
 /// atomic compare & write unit 
 pub acwu : u16 , pub reserved534 : u16 , pub sgls : spdk_nvme_ctrlr_data__bindgen_ty_18 , pub reserved4 : [ u8 ; 228usize ] , pub subnqn : [ u8 ; 256usize ] , pub reserved5 : [ u8 ; 768usize ] , pub nvmf_specific : spdk_nvme_ctrlr_data__bindgen_ty_19 , pub psd : [ spdk_nvme_power_state ; 32usize ] , pub vs : [ u8 ; 1024usize ] , } 
 /// controller multi-path I/O and namespace sharing capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn multi_port ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_port ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn multi_host ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_host ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sr_iov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_sr_iov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( multi_port : u8 , multi_host : u8 , sr_iov : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let multi_port : u8 = unsafe { :: std :: mem :: transmute ( multi_port ) } ; multi_port as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let multi_host : u8 = unsafe { :: std :: mem :: transmute ( multi_host ) } ; multi_host as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let sr_iov : u8 = unsafe { :: std :: mem :: transmute ( sr_iov ) } ; sr_iov as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// optional asynchronous events supported 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_2 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_2 { # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ns_attribute_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attribute_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 22u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 22u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reserved1 : u32 , ns_attribute_notices : u32 , fw_activation_notices : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ns_attribute_notices : u32 = unsafe { :: std :: mem :: transmute ( ns_attribute_notices ) } ; ns_attribute_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let fw_activation_notices : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notices ) } ; fw_activation_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 22u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// controller attributes 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_3 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_3 { # [ inline ] pub fn host_id_exhid_supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_host_id_exhid_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn non_operational_power_state_permissive_mode ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_non_operational_power_state_permissive_mode ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( host_id_exhid_supported : u32 , non_operational_power_state_permissive_mode : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let host_id_exhid_supported : u32 = unsafe { :: std :: mem :: transmute ( host_id_exhid_supported ) } ; host_id_exhid_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let non_operational_power_state_permissive_mode : u32 = unsafe { :: std :: mem :: transmute ( non_operational_power_state_permissive_mode ) } ; non_operational_power_state_permissive_mode as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// optional admin command support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_4 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_4 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_4 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_4 { # [ inline ] pub fn security ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_security ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn format ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_format ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn firmware ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_firmware ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_manage ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ns_manage ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_self_test ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_device_self_test ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn directives ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_directives ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nvme_mi ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nvme_mi ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn virtualization_management ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_virtualization_management ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn doorbell_buffer_config ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_doorbell_buffer_config ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oacs_rsvd ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u16 ) } } # [ inline ] pub fn set_oacs_rsvd ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( security : u16 , format : u16 , firmware : u16 , ns_manage : u16 , device_self_test : u16 , directives : u16 , nvme_mi : u16 , virtualization_management : u16 , doorbell_buffer_config : u16 , oacs_rsvd : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let security : u16 = unsafe { :: std :: mem :: transmute ( security ) } ; security as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let format : u16 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let firmware : u16 = unsafe { :: std :: mem :: transmute ( firmware ) } ; firmware as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ns_manage : u16 = unsafe { :: std :: mem :: transmute ( ns_manage ) } ; ns_manage as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let device_self_test : u16 = unsafe { :: std :: mem :: transmute ( device_self_test ) } ; device_self_test as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let directives : u16 = unsafe { :: std :: mem :: transmute ( directives ) } ; directives as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let nvme_mi : u16 = unsafe { :: std :: mem :: transmute ( nvme_mi ) } ; nvme_mi as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let virtualization_management : u16 = unsafe { :: std :: mem :: transmute ( virtualization_management ) } ; virtualization_management as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let doorbell_buffer_config : u16 = unsafe { :: std :: mem :: transmute ( doorbell_buffer_config ) } ; doorbell_buffer_config as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let oacs_rsvd : u16 = unsafe { :: std :: mem :: transmute ( oacs_rsvd ) } ; oacs_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// firmware updates 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_5 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_5 { # [ inline ] pub fn slot1_ro ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_slot1_ro ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn num_slots ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_slots ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn activation_without_reset ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_activation_without_reset ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn frmw_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_frmw_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( slot1_ro : u8 , num_slots : u8 , activation_without_reset : u8 , frmw_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let slot1_ro : u8 = unsafe { :: std :: mem :: transmute ( slot1_ro ) } ; slot1_ro as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let num_slots : u8 = unsafe { :: std :: mem :: transmute ( num_slots ) } ; num_slots as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let activation_without_reset : u8 = unsafe { :: std :: mem :: transmute ( activation_without_reset ) } ; activation_without_reset as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let frmw_rsvd : u8 = unsafe { :: std :: mem :: transmute ( frmw_rsvd ) } ; frmw_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// log page attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_6 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_6 { # [ inline ] pub fn ns_smart ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_smart ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn celp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_celp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn edlp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_edlp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_telemetry ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lpa_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_lpa_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_smart : u8 , celp : u8 , edlp : u8 , telemetry : u8 , lpa_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_smart : u8 = unsafe { :: std :: mem :: transmute ( ns_smart ) } ; ns_smart as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let celp : u8 = unsafe { :: std :: mem :: transmute ( celp ) } ; celp as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let edlp : u8 = unsafe { :: std :: mem :: transmute ( edlp ) } ; edlp as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let telemetry : u8 = unsafe { :: std :: mem :: transmute ( telemetry ) } ; telemetry as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let lpa_rsvd : u8 = unsafe { :: std :: mem :: transmute ( lpa_rsvd ) } ; lpa_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// admin vendor specific command configuration 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_7 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_7 { # [ inline ] pub fn spec_format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_spec_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn avscc_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_avscc_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( spec_format : u8 , avscc_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let spec_format : u8 = unsafe { :: std :: mem :: transmute ( spec_format ) } ; spec_format as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let avscc_rsvd : u8 = unsafe { :: std :: mem :: transmute ( avscc_rsvd ) } ; avscc_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// autonomous power state transition attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_8 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_8 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_8 { # [ inline ] pub fn supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn apsta_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_apsta_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u8 , apsta_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u8 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let apsta_rsvd : u8 = unsafe { :: std :: mem :: transmute ( apsta_rsvd ) } ; apsta_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// replay protected memory block support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub reserved2 : u8 , pub total_size : u8 , pub access_size : u8 , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_9 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_9 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_9 { # [ inline ] pub fn num_rpmb_units ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_rpmb_units ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn auth_method ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_auth_method ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num_rpmb_units : u8 , auth_method : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let num_rpmb_units : u8 = unsafe { :: std :: mem :: transmute ( num_rpmb_units ) } ; num_rpmb_units as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let auth_method : u8 = unsafe { :: std :: mem :: transmute ( auth_method ) } ; auth_method as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// device self-test options 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_10 { pub raw : u8 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { # [ inline ] pub fn one_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_one_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( one_only : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let one_only : u8 = unsafe { :: std :: mem :: transmute ( one_only ) } ; one_only as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Host controlled thermal management attributes 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_11 { pub raw : u16 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 , _bindgen_union_align : u16 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { # [ inline ] pub fn supported ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u16 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Sanitize capabilities 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_12 { pub raw : u32 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { # [ inline ] pub fn crypto_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_crypto_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn block_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_block_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn overwrite ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_overwrite ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( crypto_erase : u32 , block_erase : u32 , overwrite : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let crypto_erase : u32 = unsafe { :: std :: mem :: transmute ( crypto_erase ) } ; crypto_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let block_erase : u32 = unsafe { :: std :: mem :: transmute ( block_erase ) } ; block_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let overwrite : u32 = unsafe { :: std :: mem :: transmute ( overwrite ) } ; overwrite as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// submission queue entry size 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_13 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_13 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_13 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_13 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_13 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } 
 /// completion queue entry size 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_14 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_14 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_14 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_14 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_14 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } 
 /// optional nvm command support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_15 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_15 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_15 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_15 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_15 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_15 { # [ inline ] pub fn compare ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_compare ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_unc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_unc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dsm ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dsm ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_zeroes ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_zeroes ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn set_features_save ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_set_features_save ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reservations ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_reservations ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn timestamp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_timestamp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( compare : u16 , write_unc : u16 , dsm : u16 , write_zeroes : u16 , set_features_save : u16 , reservations : u16 , timestamp : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let compare : u16 = unsafe { :: std :: mem :: transmute ( compare ) } ; compare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_unc : u16 = unsafe { :: std :: mem :: transmute ( write_unc ) } ; write_unc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dsm : u16 = unsafe { :: std :: mem :: transmute ( dsm ) } ; dsm as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zeroes : u16 = unsafe { :: std :: mem :: transmute ( write_zeroes ) } ; write_zeroes as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let set_features_save : u16 = unsafe { :: std :: mem :: transmute ( set_features_save ) } ; set_features_save as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let reservations : u16 = unsafe { :: std :: mem :: transmute ( reservations ) } ; reservations as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let timestamp : u16 = unsafe { :: std :: mem :: transmute ( timestamp ) } ; timestamp as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// format nvm attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_16 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_16 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_16 { # [ inline ] pub fn format_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_format_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn erase_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_erase_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn crypto_erase_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_crypto_erase_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format_all_ns : u8 , erase_all_ns : u8 , crypto_erase_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let format_all_ns : u8 = unsafe { :: std :: mem :: transmute ( format_all_ns ) } ; format_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let erase_all_ns : u8 = unsafe { :: std :: mem :: transmute ( erase_all_ns ) } ; erase_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let crypto_erase_supported : u8 = unsafe { :: std :: mem :: transmute ( crypto_erase_supported ) } ; crypto_erase_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// volatile write cache 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_17 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_17 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_17 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_17 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_17 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_17 { # [ inline ] pub fn present ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_present ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( present : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let present : u8 = unsafe { :: std :: mem :: transmute ( present ) } ; present as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// SGL support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_18 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_18 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_18 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_18 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_18 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_18 { # [ inline ] pub fn supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn keyed_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_keyed_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 13u8 , val as u64 ) } } # [ inline ] pub fn bit_bucket_descriptor ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bit_bucket_descriptor ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_pointer ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_pointer ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oversized_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_oversized_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_address ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_address ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sgl_offset ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sgl_offset ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 11u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u32 , keyed_sgl : u32 , reserved1 : u32 , bit_bucket_descriptor : u32 , metadata_pointer : u32 , oversized_sgl : u32 , metadata_address : u32 , sgl_offset : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let supported : u32 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let keyed_sgl : u32 = unsafe { :: std :: mem :: transmute ( keyed_sgl ) } ; keyed_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let bit_bucket_descriptor : u32 = unsafe { :: std :: mem :: transmute ( bit_bucket_descriptor ) } ; bit_bucket_descriptor as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let metadata_pointer : u32 = unsafe { :: std :: mem :: transmute ( metadata_pointer ) } ; metadata_pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let oversized_sgl : u32 = unsafe { :: std :: mem :: transmute ( oversized_sgl ) } ; oversized_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let metadata_address : u32 = unsafe { :: std :: mem :: transmute ( metadata_address ) } ; metadata_address as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let sgl_offset : u32 = unsafe { :: std :: mem :: transmute ( sgl_offset ) } ; sgl_offset as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 11u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// NVMe over Fabrics-specific fields 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 { 
 /// I/O queue command capsule supported size (16-byte units) 
 pub ioccsz : u32 , 
 /// I/O queue response capsule supported size (16-byte units) 
 pub iorcsz : u32 , 
 /// In-capsule data offset (16-byte units) 
 pub icdoff : u16 , pub ctrattr : spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 , 
 /// Maximum SGL block descriptors (0 = no limit) 
 pub msdbd : u8 , pub reserved : [ u8 ; 244usize ] , } 
 /// Controller attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { # [ inline ] pub fn ctrlr_model ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ctrlr_model ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ctrlr_model : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ctrlr_model : u8 = unsafe { :: std :: mem :: transmute ( ctrlr_model ) } ; ctrlr_model as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19 > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_19 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data ) ) ) ; } impl Default for spdk_nvme_ctrlr_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities { 
 /// controller id 
 pub cntlid : u16 , 
 /// port identifier 
 pub portid : u16 , pub crt : spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 , pub reserved : [ u8 ; 27usize ] , 
 /// total number of VQ flexible resources 
 pub vqfrt : u32 , 
 /// total number of VQ flexible resources assigned to secondary controllers 
 pub vqrfa : u32 , 
 /// total number of VQ flexible resources allocated to primary controller 
 pub vqrfap : u16 , 
 /// total number of VQ Private resources for the primary controller 
 pub vqprt : u16 , 
 /// max number of VQ flexible Resources that may be assigned to a secondary controller 
 pub vqfrsm : u16 , 
 /// preferred granularity of assigning and removing VQ Flexible Resources 
 pub vqgran : u16 , pub reserved1 : [ u8 ; 16usize ] , 
 /// total number of VI flexible resources for the primary and its secondary controllers 
 pub vifrt : u32 , 
 /// total number of VI flexible resources assigned to the secondary controllers 
 pub virfa : u32 , 
 /// total number of VI flexible resources currently allocated to the primary controller 
 pub virfap : u16 , 
 /// total number of VI private resources for the primary controller 
 pub viprt : u16 , 
 /// max number of VI flexible resources that may be assigned to a secondary controller 
 pub vifrsm : u16 , 
 /// preferred granularity of assigning and removing VI flexible resources 
 pub vigran : u16 , pub reserved2 : [ u8 ; 4016usize ] , } 
 /// controller resource types 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { # [ inline ] pub fn vq_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vq_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn vi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( vq_supported : u8 , vi_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let vq_supported : u8 = unsafe { :: std :: mem :: transmute ( vq_supported ) } ; vq_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let vi_supported : u8 = unsafe { :: std :: mem :: transmute ( vi_supported ) } ; vi_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_primary_ctrl_capabilities > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_primary_ctrl_capabilities ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_primary_ctrl_capabilities > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_primary_ctrl_capabilities ) ) ) ; } impl Default for spdk_nvme_primary_ctrl_capabilities { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry { 
 /// controller identifier of the secondary controller 
 pub scid : u16 , 
 /// controller identifier of the associated primary controller 
 pub pcid : u16 , pub scs : spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 , pub reserved : [ u8 ; 3usize ] , 
 /// VF number if the secondary controller is an SR-IOV VF 
 pub vfn : u16 , 
 /// number of VQ flexible resources assigned to the indicated secondary controller 
 pub nvq : u16 , 
 /// number of VI flexible resources assigned to the indicated secondary controller 
 pub nvi : u16 , pub reserved1 : [ u8 ; 18usize ] , } 
 /// indicates the state of the secondary controller 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { # [ inline ] pub fn is_online ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_is_online ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( is_online : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let is_online : u8 = unsafe { :: std :: mem :: transmute ( is_online ) } ; is_online as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_secondary_ctrl_entry > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_secondary_ctrl_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_secondary_ctrl_entry > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_secondary_ctrl_entry ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_list { 
 /// number of Secondary controller entries in the list 
 pub number : u8 , pub reserved : [ u8 ; 31usize ] , pub entries : [ spdk_nvme_secondary_ctrl_entry ; 127usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_secondary_ctrl_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_secondary_ctrl_list > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_secondary_ctrl_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_secondary_ctrl_list > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_secondary_ctrl_list ) ) ) ; } impl Default for spdk_nvme_secondary_ctrl_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_data { 
 /// namespace size 
 pub nsze : u64 , 
 /// namespace capacity 
 pub ncap : u64 , 
 /// namespace utilization 
 pub nuse : u64 , pub nsfeat : spdk_nvme_ns_data__bindgen_ty_1 , 
 /// number of lba formats 
 pub nlbaf : u8 , pub flbas : spdk_nvme_ns_data__bindgen_ty_2 , pub mc : spdk_nvme_ns_data__bindgen_ty_3 , pub dpc : spdk_nvme_ns_data__bindgen_ty_4 , pub dps : spdk_nvme_ns_data__bindgen_ty_5 , pub nmic : spdk_nvme_ns_data__bindgen_ty_6 , pub nsrescap : spdk_nvme_ns_data__bindgen_ty_7 , pub fpi : spdk_nvme_ns_data__bindgen_ty_8 , pub dlfeat : spdk_nvme_ns_data__bindgen_ty_9 , 
 /// namespace atomic write unit normal 
 pub nawun : u16 , 
 /// namespace atomic write unit power fail 
 pub nawupf : u16 , 
 /// namespace atomic compare & write unit 
 pub nacwu : u16 , 
 /// namespace atomic boundary size normal 
 pub nabsn : u16 , 
 /// namespace atomic boundary offset 
 pub nabo : u16 , 
 /// namespace atomic boundary size power fail 
 pub nabspf : u16 , 
 /// namespace optimal I/O boundary in logical blocks 
 pub noiob : u16 , 
 /// NVM capacity 
 pub nvmcap : [ u64 ; 2usize ] , pub reserved64 : [ u8 ; 40usize ] , 
 /// namespace globally unique identifier 
 pub nguid : [ u8 ; 16usize ] , 
 /// IEEE extended unique identifier 
 pub eui64 : u64 , pub lbaf : [ spdk_nvme_ns_data__bindgen_ty_10 ; 16usize ] , pub reserved6 : [ u8 ; 192usize ] , pub vendor_specific : [ u8 ; 3712usize ] , } 
 /// namespace features 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_1 { # [ inline ] pub fn thin_prov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_thin_prov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_atomic_write_unit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_atomic_write_unit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dealloc_or_unwritten_error ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_dealloc_or_unwritten_error ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guid_never_reused ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guid_never_reused ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( thin_prov : u8 , ns_atomic_write_unit : u8 , dealloc_or_unwritten_error : u8 , guid_never_reused : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let thin_prov : u8 = unsafe { :: std :: mem :: transmute ( thin_prov ) } ; thin_prov as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ns_atomic_write_unit : u8 = unsafe { :: std :: mem :: transmute ( ns_atomic_write_unit ) } ; ns_atomic_write_unit as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dealloc_or_unwritten_error : u8 = unsafe { :: std :: mem :: transmute ( dealloc_or_unwritten_error ) } ; dealloc_or_unwritten_error as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let guid_never_reused : u8 = unsafe { :: std :: mem :: transmute ( guid_never_reused ) } ; guid_never_reused as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// formatted lba size 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_2 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_2 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_2 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_2 { # [ inline ] pub fn format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format : u8 , extended : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let format : u8 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// metadata capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_3 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_3 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_3 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_3 { # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pointer ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pointer ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( extended : u8 , pointer : u8 , reserved3 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pointer : u8 = unsafe { :: std :: mem :: transmute ( pointer ) } ; pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// end-to-end data protection capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_4 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_4 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_4 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_4 { # [ inline ] pub fn pit1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_end ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_end ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit1 : u8 , pit2 : u8 , pit3 : u8 , md_start : u8 , md_end : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let pit1 : u8 = unsafe { :: std :: mem :: transmute ( pit1 ) } ; pit1 as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pit2 : u8 = unsafe { :: std :: mem :: transmute ( pit2 ) } ; pit2 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let pit3 : u8 = unsafe { :: std :: mem :: transmute ( pit3 ) } ; pit3 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let md_end : u8 = unsafe { :: std :: mem :: transmute ( md_end ) } ; md_end as u64 } ) ; __bindgen_bitfield_unit } } 
 /// end-to-end data protection type settings 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_5 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_5 { # [ inline ] pub fn pit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_pit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit : u8 , md_start : u8 , reserved4 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let pit : u8 = unsafe { :: std :: mem :: transmute ( pit ) } ; pit as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// namespace multi-path I/O and namespace sharing capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_6 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_6 { # [ inline ] pub fn can_share ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_can_share ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( can_share : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let can_share : u8 = unsafe { :: std :: mem :: transmute ( can_share ) } ; can_share as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// reservation capabilities 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_7 { pub rescap : spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 , pub raw : u8 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { # [ inline ] pub fn persist ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_persist ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ignore_existing_key ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ignore_existing_key ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( persist : u8 , write_exclusive : u8 , exclusive_access : u8 , write_exclusive_reg_only : u8 , exclusive_access_reg_only : u8 , write_exclusive_all_reg : u8 , exclusive_access_all_reg : u8 , ignore_existing_key : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let persist : u8 = unsafe { :: std :: mem :: transmute ( persist ) } ; persist as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_exclusive : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive ) } ; write_exclusive as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let exclusive_access : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access ) } ; exclusive_access as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_exclusive_reg_only : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_reg_only ) } ; write_exclusive_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let exclusive_access_reg_only : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_reg_only ) } ; exclusive_access_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let write_exclusive_all_reg : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_all_reg ) } ; write_exclusive_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let exclusive_access_all_reg : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_all_reg ) } ; exclusive_access_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ignore_existing_key : u8 = unsafe { :: std :: mem :: transmute ( ignore_existing_key ) } ; ignore_existing_key as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7 ) ) ) ; } impl Default for spdk_nvme_ns_data__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// format progress indicator 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_8 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_8 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_8 { # [ inline ] pub fn percentage_remaining ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_percentage_remaining ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn fpi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_fpi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( percentage_remaining : u8 , fpi_supported : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let percentage_remaining : u8 = unsafe { :: std :: mem :: transmute ( percentage_remaining ) } ; percentage_remaining as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let fpi_supported : u8 = unsafe { :: std :: mem :: transmute ( fpi_supported ) } ; fpi_supported as u64 } ) ; __bindgen_bitfield_unit } } 
 /// deallocate logical features 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_9 { pub raw : u8 , pub bits : spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { # [ inline ] pub fn read_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_read_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn write_zero_deallocate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_zero_deallocate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guard_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guard_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( read_value : u8 , write_zero_deallocate : u8 , guard_value : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let read_value : u8 = unsafe { :: std :: mem :: transmute ( read_value ) } ; read_value as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zero_deallocate : u8 = unsafe { :: std :: mem :: transmute ( write_zero_deallocate ) } ; write_zero_deallocate as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let guard_value : u8 = unsafe { :: std :: mem :: transmute ( guard_value ) } ; guard_value as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_9 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_9 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9 ) ) ) ; } impl Default for spdk_nvme_ns_data__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// lba format support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_10 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_10 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_10 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_10 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_10 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_10 { # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn lbads ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lbads ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn rp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_rp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ms : u32 , lbads : u32 , rp : u32 , reserved6 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let lbads : u32 = unsafe { :: std :: mem :: transmute ( lbads ) } ; lbads as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let rp : u32 = unsafe { :: std :: mem :: transmute ( rp ) } ; rp as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let reserved6 : u32 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data ) ) ) ; } impl Default for spdk_nvme_ns_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Not reported 
 pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_NOT_REPORTED : spdk_nvme_dealloc_logical_block_read_value = 0 ; 
 /// Deallocated blocks read 0x00 
 pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_00 : spdk_nvme_dealloc_logical_block_read_value = 1 ; 
 /// Deallocated blocks read 0xFF 
 pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_FF : spdk_nvme_dealloc_logical_block_read_value = 2 ; 
 /// Deallocated logical block features - read value 
 pub type spdk_nvme_dealloc_logical_block_read_value = u32 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE : spdk_nvme_reservation_type = 1 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS : spdk_nvme_reservation_type = 2 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY : spdk_nvme_reservation_type = 3 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY : spdk_nvme_reservation_type = 4 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS : spdk_nvme_reservation_type = 5 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS : spdk_nvme_reservation_type = 6 ; 
 /// Reservation Type Encoding 
 pub type spdk_nvme_reservation_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_acquire_data { 
 /// current reservation key 
 pub crkey : u64 , 
 /// preempt reservation key 
 pub prkey : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_acquire_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_acquire_data > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_acquire_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_acquire_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_acquire_data ) ) ) ; } pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_ACQUIRE : spdk_nvme_reservation_acquire_action = 0 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT : spdk_nvme_reservation_acquire_action = 1 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT_ABORT : spdk_nvme_reservation_acquire_action = 2 ; 
 /// Reservation Acquire action 
 pub type spdk_nvme_reservation_acquire_action = u32 ; # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_status_data { 
 /// reservation action generation counter 
 pub generation : u32 , 
 /// reservation type 
 pub type_ : u8 , 
 /// number of registered controllers 
 pub nr_regctl : u16 , pub reserved1 : u16 , 
 /// persist through power loss state 
 pub ptpl_state : u8 , pub reserved : [ u8 ; 14usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_status_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_status_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_status_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_status_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_status_data ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_ctrlr_data { pub ctrlr_id : u16 , pub rcsts : spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 , pub reserved2 : [ u8 ; 5usize ] , 
 /// host identifier 
 pub host_id : u64 , 
 /// reservation key 
 pub key : u64 , } 
 /// reservation status 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn status ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_status ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( status : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let status : u8 = unsafe { :: std :: mem :: transmute ( status ) } ; status as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_ctrlr_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_ctrlr_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_ctrlr_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_ctrlr_data ) ) ) ; } pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_NO_CHANGES : spdk_nvme_reservation_register_cptpl = 0 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON : spdk_nvme_reservation_register_cptpl = 2 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS : spdk_nvme_reservation_register_cptpl = 3 ; 
 /// Change persist through power loss state for
/// Reservation Register command 
 pub type spdk_nvme_reservation_register_cptpl = u32 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REGISTER_KEY : spdk_nvme_reservation_register_action = 0 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_UNREGISTER_KEY : spdk_nvme_reservation_register_action = 1 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REPLACE_KEY : spdk_nvme_reservation_register_action = 2 ; 
 /// Registration action for Reservation Register command 
 pub type spdk_nvme_reservation_register_action = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_register_data { 
 /// current reservation key 
 pub crkey : u64 , 
 /// new reservation key 
 pub nrkey : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_register_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_register_data > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_register_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_register_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_register_data ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_key_data { 
 /// current reservation key 
 pub crkey : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_key_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_key_data > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_key_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_key_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_key_data ) ) ) ; } pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_RELEASE : spdk_nvme_reservation_release_action = 0 ; pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_CLEAR : spdk_nvme_reservation_release_action = 1 ; 
 /// Reservation Release action 
 pub type spdk_nvme_reservation_release_action = u32 ; 
 /// Error information (mandatory) - \ref spdk_nvme_error_information_entry 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_ERROR : spdk_nvme_log_page = 1 ; 
 /// SMART / health information (mandatory) - \ref spdk_nvme_health_information_page 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_HEALTH_INFORMATION : spdk_nvme_log_page = 2 ; 
 /// Firmware slot information (mandatory) - \ref spdk_nvme_firmware_page 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_FIRMWARE_SLOT : spdk_nvme_log_page = 3 ; 
 /// Changed namespace list (optional) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_CHANGED_NS_LIST : spdk_nvme_log_page = 4 ; 
 /// Command effects log (optional) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_COMMAND_EFFECTS_LOG : spdk_nvme_log_page = 5 ; 
 /// Discovery(refer to the NVMe over Fabrics specification) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_DISCOVERY : spdk_nvme_log_page = 112 ; 
 /// Reservation notification (optional) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_RESERVATION_NOTIFICATION : spdk_nvme_log_page = 128 ; 
 /// Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE 
 pub type spdk_nvme_log_page = u32 ; 
 /// Error information log page (\ref SPDK_NVME_LOG_ERROR) 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_error_information_entry { pub error_count : u64 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , pub error_location : u16 , pub lba : u64 , pub nsid : u32 , pub vendor_specific : u8 , pub reserved : [ u8 ; 35usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_error_information_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_error_information_entry > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_error_information_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_error_information_entry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_error_information_entry ) ) ) ; } impl Default for spdk_nvme_error_information_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_critical_warning_state { pub raw : u8 , pub bits : spdk_nvme_critical_warning_state__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_critical_warning_state__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_critical_warning_state__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_critical_warning_state__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_critical_warning_state__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_critical_warning_state__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_critical_warning_state__bindgen_ty_1 { # [ inline ] pub fn available_spare ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_available_spare ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn temperature ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_temperature ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_reliability ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_device_reliability ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn read_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_read_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn volatile_memory_backup ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_volatile_memory_backup ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( available_spare : u8 , temperature : u8 , device_reliability : u8 , read_only : u8 , volatile_memory_backup : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let available_spare : u8 = unsafe { :: std :: mem :: transmute ( available_spare ) } ; available_spare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let temperature : u8 = unsafe { :: std :: mem :: transmute ( temperature ) } ; temperature as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let device_reliability : u8 = unsafe { :: std :: mem :: transmute ( device_reliability ) } ; device_reliability as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let read_only : u8 = unsafe { :: std :: mem :: transmute ( read_only ) } ; read_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let volatile_memory_backup : u8 = unsafe { :: std :: mem :: transmute ( volatile_memory_backup ) } ; volatile_memory_backup as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_critical_warning_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_critical_warning_state > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_critical_warning_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_critical_warning_state > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_critical_warning_state ) ) ) ; } impl Default for spdk_nvme_critical_warning_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// SMART / health information page (\ref SPDK_NVME_LOG_HEALTH_INFORMATION) 
 # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_health_information_page { pub critical_warning : spdk_nvme_critical_warning_state , pub temperature : u16 , pub available_spare : u8 , pub available_spare_threshold : u8 , pub percentage_used : u8 , pub reserved : [ u8 ; 26usize ] , pub data_units_read : [ u64 ; 2usize ] , pub data_units_written : [ u64 ; 2usize ] , pub host_read_commands : [ u64 ; 2usize ] , pub host_write_commands : [ u64 ; 2usize ] , pub controller_busy_time : [ u64 ; 2usize ] , pub power_cycles : [ u64 ; 2usize ] , pub power_on_hours : [ u64 ; 2usize ] , pub unsafe_shutdowns : [ u64 ; 2usize ] , pub media_errors : [ u64 ; 2usize ] , pub num_error_info_log_entries : [ u64 ; 2usize ] , pub warning_temp_time : u32 , pub critical_temp_time : u32 , pub temp_sensor : [ u16 ; 8usize ] , pub reserved2 : [ u8 ; 296usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_health_information_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_health_information_page > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_health_information_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_health_information_page > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_health_information_page ) ) ) ; } impl Default for spdk_nvme_health_information_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_entry { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmds_and_effect_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmds_and_effect_entry > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmds_and_effect_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmds_and_effect_entry > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmds_and_effect_entry ) ) ) ; } impl spdk_nvme_cmds_and_effect_entry { # [ inline ] pub fn csupp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_csupp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lbcc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_lbcc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ncc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ncc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nic ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nic ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ccc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ccc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn cse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_cse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 13u8 ) as u16 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 13u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( csupp : u16 , lbcc : u16 , ncc : u16 , nic : u16 , ccc : u16 , reserved1 : u16 , cse : u16 , reserved2 : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let csupp : u16 = unsafe { :: std :: mem :: transmute ( csupp ) } ; csupp as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let lbcc : u16 = unsafe { :: std :: mem :: transmute ( lbcc ) } ; lbcc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ncc : u16 = unsafe { :: std :: mem :: transmute ( ncc ) } ; ncc as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let nic : u16 = unsafe { :: std :: mem :: transmute ( nic ) } ; nic as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ccc : u16 = unsafe { :: std :: mem :: transmute ( ccc ) } ; ccc as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let reserved1 : u16 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let cse : u16 = unsafe { :: std :: mem :: transmute ( cse ) } ; cse as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 13u8 , { let reserved2 : u16 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_log_page { 
 /// Commands Supported and Effects Data Structure for the Admin Commands 
 pub admin_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , 
 /// Commands Supported and Effects Data Structure for the IO Commands 
 pub io_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , pub reserved0 : [ u8 ; 2048usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmds_and_effect_log_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmds_and_effect_log_page > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmds_and_effect_log_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmds_and_effect_log_page > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmds_and_effect_log_page ) ) ) ; } impl Default for spdk_nvme_cmds_and_effect_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_ERROR : spdk_nvme_async_event_type = 0 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_SMART : spdk_nvme_async_event_type = 1 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE : spdk_nvme_async_event_type = 2 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_IO : spdk_nvme_async_event_type = 6 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_VENDOR : spdk_nvme_async_event_type = 7 ; 
 /// Asynchronous Event Type 
 pub type spdk_nvme_async_event_type = u32 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_WRITE_INVALID_DB : spdk_nvme_async_event_info_error = 0 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_INVALID_DB_WRITE : spdk_nvme_async_event_info_error = 1 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_DIAGNOSTIC_FAILURE : spdk_nvme_async_event_info_error = 2 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_PERSISTENT_INTERNAL : spdk_nvme_async_event_info_error = 3 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_TRANSIENT_INTERNAL : spdk_nvme_async_event_info_error = 4 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_FW_IMAGE_LOAD : spdk_nvme_async_event_info_error = 5 ; 
 /// Asynchronous Event Information for Error Status 
 pub type spdk_nvme_async_event_info_error = u32 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SUBSYSTEM_RELIABILITY : spdk_nvme_async_event_info_smart = 0 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_TEMPERATURE_THRESHOLD : spdk_nvme_async_event_info_smart = 1 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SPARE_BELOW_THRESHOLD : spdk_nvme_async_event_info_smart = 2 ; 
 /// Asynchronous Event Information for SMART/Health Status 
 pub type spdk_nvme_async_event_info_smart = u32 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED : spdk_nvme_async_event_info_notice = 0 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_FW_ACTIVATION_START : spdk_nvme_async_event_info_notice = 1 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_TELEMETRY_LOG_CHANGED : spdk_nvme_async_event_info_notice = 2 ; 
 /// Asynchronous Event Information for Notice 
 pub type spdk_nvme_async_event_info_notice = u32 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_RESERVATION_LOG_AVAIL : spdk_nvme_async_event_info_nvm_command_set = 0 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_SANITIZE_COMPLETED : spdk_nvme_async_event_info_nvm_command_set = 1 ; 
 /// Asynchronous Event Information for NVM Command Set Specific Status 
 pub type spdk_nvme_async_event_info_nvm_command_set = u32 ; 
 /// Asynchronous Event Request Completion 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_async_event_completion { pub raw : u32 , pub bits : spdk_nvme_async_event_completion__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_async_event_completion__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_async_event_completion__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_async_event_completion__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_async_event_completion__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_async_event_completion__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_async_event_completion__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_async_event_completion__bindgen_ty_1 { # [ inline ] pub fn async_event_type ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_type ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn async_event_info ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_info ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn log_page_identifier ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_log_page_identifier ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( async_event_type : u32 , reserved1 : u32 , async_event_info : u32 , log_page_identifier : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let async_event_type : u32 = unsafe { :: std :: mem :: transmute ( async_event_type ) } ; async_event_type as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let async_event_info : u32 = unsafe { :: std :: mem :: transmute ( async_event_info ) } ; async_event_info as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let log_page_identifier : u32 = unsafe { :: std :: mem :: transmute ( log_page_identifier ) } ; log_page_identifier as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_async_event_completion ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_async_event_completion > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_async_event_completion ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_async_event_completion > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_async_event_completion ) ) ) ; } impl Default for spdk_nvme_async_event_completion { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_ARBITRATION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_arbitration { pub raw : u32 , pub bits : spdk_nvme_feat_arbitration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_arbitration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_arbitration__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_arbitration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_arbitration__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_arbitration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_arbitration__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_arbitration__bindgen_ty_1 { # [ inline ] pub fn ab ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ab ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn lpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn hpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_hpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ab : u32 , reserved : u32 , lpw : u32 , mpw : u32 , hpw : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let ab : u32 = unsafe { :: std :: mem :: transmute ( ab ) } ; ab as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let lpw : u32 = unsafe { :: std :: mem :: transmute ( lpw ) } ; lpw as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let mpw : u32 = unsafe { :: std :: mem :: transmute ( mpw ) } ; mpw as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let hpw : u32 = unsafe { :: std :: mem :: transmute ( hpw ) } ; hpw as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_arbitration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_arbitration > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_arbitration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_arbitration > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_arbitration ) ) ) ; } impl Default for spdk_nvme_feat_arbitration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_POWER_MANAGEMENT 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_power_management { pub raw : u32 , pub bits : spdk_nvme_feat_power_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_power_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_power_management__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_power_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_power_management__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_power_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_power_management__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_power_management__bindgen_ty_1 { # [ inline ] pub fn ps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_ps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn wh ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_wh ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ps : u32 , wh : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let ps : u32 = unsafe { :: std :: mem :: transmute ( ps ) } ; ps as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let wh : u32 = unsafe { :: std :: mem :: transmute ( wh ) } ; wh as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_power_management ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_power_management > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_power_management ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_power_management > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_power_management ) ) ) ; } impl Default for spdk_nvme_feat_power_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_LBA_RANGE_TYPE 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_lba_range_type { pub raw : u32 , pub bits : spdk_nvme_feat_lba_range_type__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_lba_range_type__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_lba_range_type__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_lba_range_type__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_lba_range_type__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_lba_range_type__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_lba_range_type__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_lba_range_type__bindgen_ty_1 { # [ inline ] pub fn num ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_num ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let num : u32 = unsafe { :: std :: mem :: transmute ( num ) } ; num as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_lba_range_type ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_lba_range_type > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_lba_range_type ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_lba_range_type > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_lba_range_type ) ) ) ; } impl Default for spdk_nvme_feat_lba_range_type { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_temperature_threshold { pub raw : u32 , pub bits : spdk_nvme_feat_temperature_threshold__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_temperature_threshold__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_temperature_threshold__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_temperature_threshold__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_temperature_threshold__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { # [ inline ] pub fn tmpth ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmpth ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmpsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_tmpsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn thsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_thsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmpth : u32 , tmpsel : u32 , thsel : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmpth : u32 = unsafe { :: std :: mem :: transmute ( tmpth ) } ; tmpth as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let tmpsel : u32 = unsafe { :: std :: mem :: transmute ( tmpsel ) } ; tmpsel as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 2u8 , { let thsel : u32 = unsafe { :: std :: mem :: transmute ( thsel ) } ; thsel as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_temperature_threshold > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_temperature_threshold ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_temperature_threshold > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_temperature_threshold ) ) ) ; } impl Default for spdk_nvme_feat_temperature_threshold { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_ERROR_RECOVERY 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_error_recovery { pub raw : u32 , pub bits : spdk_nvme_feat_error_recovery__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_error_recovery__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_error_recovery__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_error_recovery__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_error_recovery__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_error_recovery__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_error_recovery__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_error_recovery__bindgen_ty_1 { # [ inline ] pub fn tler ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tler ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn dulbe ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dulbe ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tler : u32 , dulbe : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tler : u32 = unsafe { :: std :: mem :: transmute ( tler ) } ; tler as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let dulbe : u32 = unsafe { :: std :: mem :: transmute ( dulbe ) } ; dulbe as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_error_recovery ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_error_recovery > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_error_recovery ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_error_recovery > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_error_recovery ) ) ) ; } impl Default for spdk_nvme_feat_error_recovery { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_volatile_write_cache { pub raw : u32 , pub bits : spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { # [ inline ] pub fn wce ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wce ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( wce : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let wce : u32 = unsafe { :: std :: mem :: transmute ( wce ) } ; wce as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_volatile_write_cache > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_volatile_write_cache ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_volatile_write_cache > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_volatile_write_cache ) ) ) ; } impl Default for spdk_nvme_feat_volatile_write_cache { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_NUMBER_OF_QUEUES 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_number_of_queues { pub raw : u32 , pub bits : spdk_nvme_feat_number_of_queues__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_number_of_queues__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_number_of_queues__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_number_of_queues__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_number_of_queues__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_number_of_queues__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_number_of_queues__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_number_of_queues__bindgen_ty_1 { # [ inline ] pub fn nsqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_nsqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn ncqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ncqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( nsqr : u32 , ncqr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let nsqr : u32 = unsafe { :: std :: mem :: transmute ( nsqr ) } ; nsqr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let ncqr : u32 = unsafe { :: std :: mem :: transmute ( ncqr ) } ; ncqr as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_number_of_queues ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_number_of_queues > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_number_of_queues ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_number_of_queues > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_number_of_queues ) ) ) ; } impl Default for spdk_nvme_feat_number_of_queues { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_interrupt_vector_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { # [ inline ] pub fn iv ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_iv ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( iv : u32 , cd : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let iv : u32 = unsafe { :: std :: mem :: transmute ( iv ) } ; iv as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cd : u32 = unsafe { :: std :: mem :: transmute ( cd ) } ; cd as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_interrupt_vector_configuration > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_interrupt_vector_configuration > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration ) ) ) ; } impl Default for spdk_nvme_feat_interrupt_vector_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_WRITE_ATOMICITY 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_write_atomicity { pub raw : u32 , pub bits : spdk_nvme_feat_write_atomicity__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_write_atomicity__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_write_atomicity__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_write_atomicity__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_write_atomicity__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_write_atomicity__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_write_atomicity__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_write_atomicity__bindgen_ty_1 { # [ inline ] pub fn dn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( dn : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let dn : u32 = unsafe { :: std :: mem :: transmute ( dn ) } ; dn as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_write_atomicity ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_write_atomicity > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_write_atomicity ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_write_atomicity > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_write_atomicity ) ) ) ; } impl Default for spdk_nvme_feat_write_atomicity { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features / Get Features \ref SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_async_event_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_async_event_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { pub crit_warn : spdk_nvme_critical_warning_state , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_async_event_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_async_event_configuration__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_async_event_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_async_event_configuration__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { # [ inline ] pub fn ns_attr_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attr_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry_log_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_telemetry_log_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_attr_notice : u32 , fw_activation_notice : u32 , telemetry_log_notice : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_attr_notice : u32 = unsafe { :: std :: mem :: transmute ( ns_attr_notice ) } ; ns_attr_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let fw_activation_notice : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notice ) } ; fw_activation_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let telemetry_log_notice : u32 = unsafe { :: std :: mem :: transmute ( telemetry_log_notice ) } ; telemetry_log_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 21u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_async_event_configuration > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_async_event_configuration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_async_event_configuration > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_async_event_configuration ) ) ) ; } impl Default for spdk_nvme_feat_async_event_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_autonomous_power_state_transition { pub raw : u32 , pub bits : spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { # [ inline ] pub fn apste ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_apste ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( apste : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let apste : u32 = unsafe { :: std :: mem :: transmute ( apste ) } ; apste as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_autonomous_power_state_transition > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_autonomous_power_state_transition > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition ) ) ) ; } impl Default for spdk_nvme_feat_autonomous_power_state_transition { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_HOST_MEM_BUFFER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_mem_buffer { pub raw : u32 , pub bits : spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { # [ inline ] pub fn ehm ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ehm ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn mr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_mr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ehm : u32 , mr : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ehm : u32 = unsafe { :: std :: mem :: transmute ( ehm ) } ; ehm as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let mr : u32 = unsafe { :: std :: mem :: transmute ( mr ) } ; mr as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_mem_buffer > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_mem_buffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_mem_buffer > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_mem_buffer ) ) ) ; } impl Default for spdk_nvme_feat_host_mem_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_KEEP_ALIVE_TIMER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_keep_alive_timer { pub raw : u32 , pub bits : spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { # [ inline ] pub fn kato ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 32u8 ) as u32 ) } } # [ inline ] pub fn set_kato ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 32u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( kato : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 32u8 , { let kato : u32 = unsafe { :: std :: mem :: transmute ( kato ) } ; kato as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_keep_alive_timer > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_keep_alive_timer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_keep_alive_timer > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_keep_alive_timer ) ) ) ; } impl Default for spdk_nvme_feat_keep_alive_timer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_controlled_thermal_management { pub raw : u32 , pub bits : spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { # [ inline ] pub fn tmt2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmt1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmt2 : u32 , tmt1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmt2 : u32 = unsafe { :: std :: mem :: transmute ( tmt2 ) } ; tmt2 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let tmt1 : u32 = unsafe { :: std :: mem :: transmute ( tmt1 ) } ; tmt1 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_controlled_thermal_management > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_controlled_thermal_management > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management ) ) ) ; } impl Default for spdk_nvme_feat_host_controlled_thermal_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_non_operational_power_state_config { pub raw : u32 , pub bits : spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { # [ inline ] pub fn noppme ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_noppme ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( noppme : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let noppme : u32 = unsafe { :: std :: mem :: transmute ( noppme ) } ; noppme as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_non_operational_power_state_config > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_non_operational_power_state_config > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config ) ) ) ; } impl Default for spdk_nvme_feat_non_operational_power_state_config { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_software_progress_marker { pub raw : u32 , pub bits : spdk_nvme_feat_software_progress_marker__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_software_progress_marker__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_software_progress_marker__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_software_progress_marker__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_software_progress_marker__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { # [ inline ] pub fn pbslc ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_pbslc ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pbslc : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let pbslc : u32 = unsafe { :: std :: mem :: transmute ( pbslc ) } ; pbslc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_software_progress_marker > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_software_progress_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_software_progress_marker > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_software_progress_marker ) ) ) ; } impl Default for spdk_nvme_feat_software_progress_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_HOST_IDENTIFIER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_identifier { pub raw : u32 , pub bits : spdk_nvme_feat_host_identifier__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_identifier__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_identifier__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_identifier__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_identifier__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_identifier__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_identifier__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_host_identifier__bindgen_ty_1 { # [ inline ] pub fn exhid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_exhid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( exhid : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let exhid : u32 = unsafe { :: std :: mem :: transmute ( exhid ) } ; exhid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_identifier ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_identifier > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_identifier ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_identifier > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_identifier ) ) ) ; } impl Default for spdk_nvme_feat_host_identifier { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Firmware slot information page (\ref SPDK_NVME_LOG_FIRMWARE_SLOT) 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_firmware_page { pub afi : spdk_nvme_firmware_page__bindgen_ty_1 , pub reserved : [ u8 ; 7usize ] , pub revision : [ [ u8 ; 8usize ] ; 7usize ] , 
 /// Revisions for 7 slots (ASCII strings) 
 pub reserved2 : [ u8 ; 448usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_firmware_page__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_firmware_page__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_firmware_page__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_firmware_page__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_firmware_page__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_firmware_page__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_firmware_page__bindgen_ty_1 { # [ inline ] pub fn active_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_active_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn next_reset_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_next_reset_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved7 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved7 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( active_slot : u8 , reserved3 : u8 , next_reset_slot : u8 , reserved7 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let active_slot : u8 = unsafe { :: std :: mem :: transmute ( active_slot ) } ; active_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let next_reset_slot : u8 = unsafe { :: std :: mem :: transmute ( next_reset_slot ) } ; next_reset_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved7 : u8 = unsafe { :: std :: mem :: transmute ( reserved7 ) } ; reserved7 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_firmware_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_firmware_page > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_firmware_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_firmware_page > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_firmware_page ) ) ) ; } impl Default for spdk_nvme_firmware_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_ATTACH : spdk_nvme_ns_attach_type = 0 ; pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_DETACH : spdk_nvme_ns_attach_type = 1 ; 
 /// Namespace attachment Type Encoding 
 pub type spdk_nvme_ns_attach_type = u32 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_CREATE : spdk_nvme_ns_management_type = 0 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_DELETE : spdk_nvme_ns_management_type = 1 ; 
 /// Namespace management Type Encoding 
 pub type spdk_nvme_ns_management_type = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_list { pub ns_list : [ u32 ; 1024usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_list > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_list > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_list ) ) ) ; } impl Default for spdk_nvme_ns_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// IEEE Extended Unique Identifier 
 pub const spdk_nvme_nidt_SPDK_NVME_NIDT_EUI64 : spdk_nvme_nidt = 1 ; 
 /// Namespace GUID 
 pub const spdk_nvme_nidt_SPDK_NVME_NIDT_NGUID : spdk_nvme_nidt = 2 ; 
 /// Namespace UUID 
 pub const spdk_nvme_nidt_SPDK_NVME_NIDT_UUID : spdk_nvme_nidt = 3 ; 
 /// Namespace identification descriptor type
///
/// \sa spdk_nvme_ns_id_desc 
 pub type spdk_nvme_nidt = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_nvme_ns_id_desc { 
 /// Namespace identifier type 
 pub nidt : u8 , 
 /// Namespace identifier length (length of nid field) 
 pub nidl : u8 , pub reserved2 : u8 , pub reserved3 : u8 , 
 /// Namespace identifier 
 pub nid : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_id_desc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_id_desc > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_id_desc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_id_desc > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_id_desc ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_list { pub ctrlr_count : u16 , pub ctrlr_list : [ u16 ; 2047usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_list > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_list > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_list ) ) ) ; } impl Default for spdk_nvme_ctrlr_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE : spdk_nvme_secure_erase_setting = 0 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE : spdk_nvme_secure_erase_setting = 1 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE : spdk_nvme_secure_erase_setting = 2 ; pub type spdk_nvme_secure_erase_setting = u32 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL : spdk_nvme_pi_location = 0 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD : spdk_nvme_pi_location = 1 ; pub type spdk_nvme_pi_location = u32 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_DISABLE : spdk_nvme_pi_type = 0 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE1 : spdk_nvme_pi_type = 1 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE2 : spdk_nvme_pi_type = 2 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE3 : spdk_nvme_pi_type = 3 ; pub type spdk_nvme_pi_type = u32 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER : spdk_nvme_metadata_setting = 0 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA : spdk_nvme_metadata_setting = 1 ; pub type spdk_nvme_metadata_setting = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_format { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_format ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_format > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_format ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_format > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_format ) ) ) ; } impl spdk_nvme_format { # [ inline ] pub fn lbaf ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_lbaf ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pi ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_pi ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn pil ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pil ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ses ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ses ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( lbaf : u32 , ms : u32 , pi : u32 , pil : u32 , ses : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let lbaf : u32 = unsafe { :: std :: mem :: transmute ( lbaf ) } ; lbaf as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let pi : u32 = unsafe { :: std :: mem :: transmute ( pi ) } ; pi as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let pil : u32 = unsafe { :: std :: mem :: transmute ( pil ) } ; pil as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let ses : u32 = unsafe { :: std :: mem :: transmute ( ses ) } ; ses as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_protection_info { pub guard : u16 , pub app_tag : u16 , pub ref_tag : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvme_protection_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_protection_info > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_protection_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_protection_info > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_protection_info ) ) ) ; } 
 /// Downloaded image replaces the image specified by
/// the Firmware Slot field. This image is not activated. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_IMG : spdk_nvme_fw_commit_action = 0 ; 
 /// Downloaded image replaces the image specified by
/// the Firmware Slot field. This image is activated at the next reset. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG : spdk_nvme_fw_commit_action = 1 ; 
 /// The image specified by the Firmware Slot field is
/// activated at the next reset. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_ENABLE_IMG : spdk_nvme_fw_commit_action = 2 ; 
 /// The image specified by the Firmware Slot field is
/// requested to be activated immediately without reset. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_RUN_IMG : spdk_nvme_fw_commit_action = 3 ; 
 /// Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action 
 pub type spdk_nvme_fw_commit_action = u32 ; 
 /// Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_fw_commit { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_fw_commit ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_fw_commit > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_fw_commit ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_fw_commit > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_fw_commit ) ) ) ; } impl spdk_nvme_fw_commit { # [ inline ] pub fn fs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_fs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( fs : u32 , ca : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let fs : u32 = unsafe { :: std :: mem :: transmute ( fs ) } ; fs as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let ca : u32 = unsafe { :: std :: mem :: transmute ( ca ) } ; ca as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_capsule_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 35usize ] , pub fabric_specific : [ u8 ; 24usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_capsule_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_capsule_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_capsule_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_capsule_cmd > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_capsule_cmd ) ) ) ; } impl Default for spdk_nvmf_capsule_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_SET : spdk_nvmf_fabric_cmd_types = 0 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_CONNECT : spdk_nvmf_fabric_cmd_types = 1 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_GET : spdk_nvmf_fabric_cmd_types = 4 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_SEND : spdk_nvmf_fabric_cmd_types = 5 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_RECV : spdk_nvmf_fabric_cmd_types = 6 ; pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_START_VENDOR_SPECIFIC : spdk_nvmf_fabric_cmd_types = 192 ; pub type spdk_nvmf_fabric_cmd_types = u32 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INCOMPATIBLE_FORMAT : spdk_nvmf_fabric_cmd_status_code = 128 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_CONTROLLER_BUSY : spdk_nvmf_fabric_cmd_status_code = 129 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_PARAM : spdk_nvmf_fabric_cmd_status_code = 130 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_RESTART_DISCOVERY : spdk_nvmf_fabric_cmd_status_code = 131 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_HOST : spdk_nvmf_fabric_cmd_status_code = 132 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_LOG_RESTART_DISCOVERY : spdk_nvmf_fabric_cmd_status_code = 144 ; pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_AUTH_REQUIRED : spdk_nvmf_fabric_cmd_status_code = 145 ; pub type spdk_nvmf_fabric_cmd_status_code = u32 ; 
 /// Reliable connected 
 pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_CONNECTED : spdk_nvmf_rdma_qptype = 1 ; 
 /// Reliable datagram 
 pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_DATAGRAM : spdk_nvmf_rdma_qptype = 2 ; 
 /// RDMA Queue Pair service types 
 pub type spdk_nvmf_rdma_qptype = u32 ; 
 /// No provider specified 
 pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_NONE : spdk_nvmf_rdma_prtype = 1 ; 
 /// InfiniBand 
 pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IB : spdk_nvmf_rdma_prtype = 2 ; 
 /// RoCE v1 
 pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE : spdk_nvmf_rdma_prtype = 3 ; 
 /// RoCE v2 
 pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE2 : spdk_nvmf_rdma_prtype = 4 ; 
 /// iWARP 
 pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IWARP : spdk_nvmf_rdma_prtype = 5 ; 
 /// RDMA provider types 
 pub type spdk_nvmf_rdma_prtype = u32 ; 
 /// Sockets based endpoint addressing 
 pub const spdk_nvmf_rdma_cms_SPDK_NVMF_RDMA_CMS_RDMA_CM : spdk_nvmf_rdma_cms = 1 ; 
 /// RDMA connection management service types 
 pub type spdk_nvmf_rdma_cms = u32 ; 
 /// RDMA 
 pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_RDMA : spdk_nvmf_trtype = 1 ; 
 /// Fibre Channel 
 pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_FC : spdk_nvmf_trtype = 2 ; 
 /// Intra-host transport (loopback) 
 pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_INTRA_HOST : spdk_nvmf_trtype = 254 ; 
 /// NVMe over Fabrics transport types 
 pub type spdk_nvmf_trtype = u32 ; 
 /// IPv4 (AF_INET) 
 pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV4 : spdk_nvmf_adrfam = 1 ; 
 /// IPv6 (AF_INET6) 
 pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV6 : spdk_nvmf_adrfam = 2 ; 
 /// InfiniBand (AF_IB) 
 pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IB : spdk_nvmf_adrfam = 3 ; 
 /// Fibre Channel address family 
 pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_FC : spdk_nvmf_adrfam = 4 ; 
 /// Intra-host transport (loopback) 
 pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_INTRA_HOST : spdk_nvmf_adrfam = 254 ; 
 /// Address family types 
 pub type spdk_nvmf_adrfam = u32 ; 
 /// Discovery type for NVM subsystem 
 pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_DISCOVERY : spdk_nvmf_subtype = 1 ; 
 /// NVMe type for NVM subsystem 
 pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_NVME : spdk_nvmf_subtype = 2 ; 
 /// NVM subsystem types 
 pub type spdk_nvmf_subtype = u32 ; 
 /// Not specified 
 pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_SPECIFIED : spdk_nvmf_treq_secure_channel = 0 ; 
 /// Required 
 pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_REQUIRED : spdk_nvmf_treq_secure_channel = 1 ; 
 /// Not required 
 pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_REQUIRED : spdk_nvmf_treq_secure_channel = 2 ; 
 /// Connections shall be made over a fabric secure channel 
 pub type spdk_nvmf_treq_secure_channel = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_auth_recv_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub reserved3 : u8 , pub spsp0 : u8 , pub spsp1 : u8 , pub secp : u8 , pub al : u32 , pub reserved4 : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_auth_recv_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_auth_recv_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_auth_recv_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_auth_recv_cmd > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_auth_recv_cmd ) ) ) ; } impl Default for spdk_nvmf_fabric_auth_recv_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_auth_send_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub reserved3 : u8 , pub spsp0 : u8 , pub spsp1 : u8 , pub secp : u8 , pub tl : u32 , pub reserved4 : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_auth_send_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_auth_send_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_auth_send_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_auth_send_cmd > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_auth_send_cmd ) ) ) ; } impl Default for spdk_nvmf_fabric_auth_send_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_data { pub hostid : [ u8 ; 16usize ] , pub cntlid : u16 , pub reserved5 : [ u8 ; 238usize ] , pub subnqn : [ u8 ; 256usize ] , pub hostnqn : [ u8 ; 256usize ] , pub reserved6 : [ u8 ; 256usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_connect_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_connect_data > ( ) , 1024usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_connect_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_connect_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_connect_data ) ) ) ; } impl Default for spdk_nvmf_fabric_connect_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 19usize ] , pub sgl1 : spdk_nvme_sgl_descriptor , pub recfmt : u16 , pub qid : u16 , pub sqsize : u16 , pub cattr : u8 , pub reserved3 : u8 , pub kato : u32 , pub reserved4 : [ u8 ; 12usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_connect_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_connect_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_connect_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_connect_cmd > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_connect_cmd ) ) ) ; } impl Default for spdk_nvmf_fabric_connect_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp { pub status_code_specific : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 , pub reserved0 : u32 , pub sqhd : u16 , pub reserved1 : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 { pub success : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 , pub invalid : spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 , pub raw : u32 , _bindgen_union_align : [ u8 ; 4usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 { pub cntlid : u16 , pub authreq : u16 , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 { pub ipo : u16 , pub iattr : u8 , pub reserved : u8 , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_connect_rsp > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_connect_rsp ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_connect_rsp > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_connect_rsp ) ) ) ; } impl Default for spdk_nvmf_fabric_connect_rsp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_cmd { pub opcode : u8 , pub reserved1 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved2 : [ u8 ; 35usize ] , pub attrib : spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 , pub reserved3 : [ u8 ; 3usize ] , pub ofst : u32 , pub reserved4 : [ u8 ; 16usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 ) ) ) ; } impl spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 { # [ inline ] pub fn size ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_size ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( size : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let size : u8 = unsafe { :: std :: mem :: transmute ( size ) } ; size as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_get_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_get_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_get_cmd > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_get_cmd ) ) ) ; } impl Default for spdk_nvmf_fabric_prop_get_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_rsp { pub value : spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 , pub sqhd : u16 , pub reserved0 : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 { pub u64 : u64 , pub u32 : spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 { pub low : u32 , pub high : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_rsp ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_get_rsp > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_get_rsp ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_get_rsp > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_get_rsp ) ) ) ; } impl Default for spdk_nvmf_fabric_prop_get_rsp { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd { pub opcode : u8 , pub reserved0 : u8 , pub cid : u16 , pub fctype : u8 , pub reserved1 : [ u8 ; 35usize ] , pub attrib : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 , pub reserved2 : [ u8 ; 3usize ] , pub ofst : u32 , pub value : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 , pub reserved4 : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 ) ) ) ; } impl spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 { # [ inline ] pub fn size ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_size ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( size : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let size : u8 = unsafe { :: std :: mem :: transmute ( size ) } ; size as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 { pub u64 : u64 , pub u32 : spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 , _bindgen_union_align : [ u8 ; 8usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 { pub low : u32 , pub high : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 ) ) ) ; } impl Default for spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_fabric_prop_set_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_fabric_prop_set_cmd > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_fabric_prop_set_cmd ) ) ) ; } impl Default for spdk_nvmf_fabric_prop_set_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// RDMA transport-specific address subtype 
 # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_rdma_transport_specific_address_subtype { 
 /// RDMA QP service type (\ref spdk_nvmf_rdma_qptype) 
 pub rdma_qptype : u8 , 
 /// RDMA provider type (\ref spdk_nvmf_rdma_prtype) 
 pub rdma_prtype : u8 , 
 /// RDMA connection management service (\ref spdk_nvmf_rdma_cms) 
 pub rdma_cms : u8 , pub reserved0 : [ u8 ; 5usize ] , 
 /// RDMA partition key for AF_IB 
 pub rdma_pkey : u16 , pub reserved2 : [ u8 ; 246usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_rdma_transport_specific_address_subtype ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_rdma_transport_specific_address_subtype > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_rdma_transport_specific_address_subtype ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_rdma_transport_specific_address_subtype > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_rdma_transport_specific_address_subtype ) ) ) ; } impl Default for spdk_nvmf_rdma_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Transport-specific address subtype 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_transport_specific_address_subtype { pub raw : [ u8 ; 256usize ] , 
 /// RDMA 
 pub rdma : spdk_nvmf_rdma_transport_specific_address_subtype , _bindgen_union_align : [ u8 ; 256usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_transport_specific_address_subtype ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_transport_specific_address_subtype > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_transport_specific_address_subtype ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_transport_specific_address_subtype > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_transport_specific_address_subtype ) ) ) ; } impl Default for spdk_nvmf_transport_specific_address_subtype { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Discovery Log Page entry 
 # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvmf_discovery_log_page_entry { 
 /// Transport type (\ref spdk_nvmf_trtype) 
 pub trtype : u8 , 
 /// Address family (\ref spdk_nvmf_adrfam) 
 pub adrfam : u8 , 
 /// Subsystem type (\ref spdk_nvmf_subtype) 
 pub subtype : u8 , pub treq : spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 , 
 /// NVM subsystem port ID 
 pub portid : u16 , 
 /// Controller ID 
 pub cntlid : u16 , 
 /// Admin max SQ size 
 pub asqsz : u16 , pub reserved0 : [ u8 ; 22usize ] , 
 /// Transport service identifier 
 pub trsvcid : [ u8 ; 32usize ] , pub reserved1 : [ u8 ; 192usize ] , 
 /// NVM subsystem qualified name 
 pub subnqn : [ u8 ; 256usize ] , 
 /// Transport address 
 pub traddr : [ u8 ; 256usize ] , 
 /// Transport-specific address subtype 
 pub tsas : spdk_nvmf_transport_specific_address_subtype , } 
 /// Transport requirements 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 ) ) ) ; } impl spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 { # [ inline ] pub fn secure_channel ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_secure_channel ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( secure_channel : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let secure_channel : u8 = unsafe { :: std :: mem :: transmute ( secure_channel ) } ; secure_channel as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvmf_discovery_log_page_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_discovery_log_page_entry > ( ) , 1024usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_discovery_log_page_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_discovery_log_page_entry > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_discovery_log_page_entry ) ) ) ; } impl Default for spdk_nvmf_discovery_log_page_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] pub struct spdk_nvmf_discovery_log_page { pub genctr : u64 , pub numrec : u64 , pub recfmt : u16 , pub reserved0 : [ u8 ; 1006usize ] , pub entries : __IncompleteArrayField < spdk_nvmf_discovery_log_page_entry > , } # [ test ] fn bindgen_test_layout_spdk_nvmf_discovery_log_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_discovery_log_page > ( ) , 1024usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_discovery_log_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_discovery_log_page > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_discovery_log_page ) ) ) ; } impl Default for spdk_nvmf_discovery_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_request_private_data { pub recfmt : u16 , pub qid : u16 , pub hrqsize : u16 , pub hsqsize : u16 , pub cntlid : u16 , pub reserved : [ u8 ; 22usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_rdma_request_private_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_rdma_request_private_data > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_rdma_request_private_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_rdma_request_private_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_rdma_request_private_data ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_accept_private_data { pub recfmt : u16 , pub crqsize : u16 , pub reserved : [ u8 ; 28usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_rdma_accept_private_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_rdma_accept_private_data > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_rdma_accept_private_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_rdma_accept_private_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_rdma_accept_private_data ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvmf_rdma_reject_private_data { pub recfmt : u16 , pub sts : u16 , } # [ test ] fn bindgen_test_layout_spdk_nvmf_rdma_reject_private_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_rdma_reject_private_data > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_rdma_reject_private_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_rdma_reject_private_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_rdma_reject_private_data ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvmf_rdma_private_data { pub pd_request : spdk_nvmf_rdma_request_private_data , pub pd_accept : spdk_nvmf_rdma_accept_private_data , pub pd_reject : spdk_nvmf_rdma_reject_private_data , _bindgen_union_align : [ u8 ; 32usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvmf_rdma_private_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvmf_rdma_private_data > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvmf_rdma_private_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvmf_rdma_private_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvmf_rdma_private_data ) ) ) ; } impl Default for spdk_nvmf_rdma_private_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_PRIVATE_DATA_LENGTH : spdk_nvmf_rdma_transport_error = 1 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_RECFMT : spdk_nvmf_rdma_transport_error = 2 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_QID : spdk_nvmf_rdma_transport_error = 3 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HSQSIZE : spdk_nvmf_rdma_transport_error = 4 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HRQSIZE : spdk_nvmf_rdma_transport_error = 5 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_NO_RESOURCES : spdk_nvmf_rdma_transport_error = 6 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_IRD : spdk_nvmf_rdma_transport_error = 7 ; pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_ORD : spdk_nvmf_rdma_transport_error = 8 ; pub type spdk_nvmf_rdma_transport_error = u32 ; 
 /// \brief Opaque handle to a controller. Returned by \ref spdk_nvme_probe()'s attach_cb. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_ctrlr { _unused : [ u8 ; 0 ] , } 
 /// \brief NVMe controller initialization options.
///
/// A pointer to this structure will be provided for each probe callback from spdk_nvme_probe() to
/// allow the user to request non-default options, and the actual options enabled on the controller
/// will be provided during the attach callback. 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_opts { 
 /// Number of I/O queues to request (used to set Number of Queues feature) 
 pub num_io_queues : u32 , 
 /// Enable submission queue in controller memory buffer 
 pub use_cmb_sqs : bool , 
 /// Type of arbitration mechanism 
 pub arb_mechanism : spdk_nvme_cc_ams , 
 /// Keep alive timeout in milliseconds (0 = disabled).
    ///
    /// The NVMe library will set the Keep Alive Timer feature to this value and automatically
    /// send Keep Alive commands as needed.  The library user must call
    /// spdk_nvme_ctrlr_process_admin_completions() periodically to ensure Keep Alive commands
    /// are sent. 
 pub keep_alive_timeout_ms : u32 , 
 /// Specify the retry number when there is issue with the transport 
 pub transport_retry_count : :: std :: os :: raw :: c_int , 
 /// The queue depth of each NVMe I/O queue. 
 pub io_queue_size : u32 , 
 /// The host NQN to use when connecting to NVMe over Fabrics controllers.
    ///
    /// Unused for local PCIe-attached NVMe devices. 
 pub hostnqn : [ :: std :: os :: raw :: c_char ; 224usize ] , 
 /// The number of requests to allocate for each NVMe I/O queue.
    ///
    /// This should be at least as large as io_queue_size.
    ///
    /// A single I/O may allocate more than one request, since splitting may be necessary to
    /// conform to the device's maximum transfer size, PRP list compatibility requirements,
    /// or driver-assisted striping. 
 pub io_queue_requests : u32 , 
 /// Source address for NVMe-oF connections.
    /// Set src_addr and src_svcid to empty strings if no source address should be
    /// specified. 
 pub src_addr : [ :: std :: os :: raw :: c_char ; 257usize ] , 
 /// Source service ID (port) for NVMe-oF connections.
    /// Set src_addr and src_svcid to empty strings if no source address should be
    /// specified. 
 pub src_svcid : [ :: std :: os :: raw :: c_char ; 33usize ] , 
 /// The host identifier to use when connecting to controllers with 64-bit host ID support.
    ///
    /// Set to all zeroes to specify that no host ID should be provided to the controller. 
 pub host_id : [ u8 ; 8usize ] , 
 /// The host identifier to use when connecting to controllers with extended (128-bit) host ID support.
    ///
    /// Set to all zeroes to specify that no host ID should be provided to the controller. 
 pub extended_host_id : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_opts ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_opts > ( ) , 568usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_opts ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_opts > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_opts ) ) ) ; } impl Default for spdk_nvme_ctrlr_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// \brief Get the default options for the creation of a specific NVMe controller.
///
/// \param[out] opts Will be filled with the default option.
/// \param opts_size Must be set to sizeof(struct spdk_nvme_ctrlr_opts). 
 # [ link_name = "\u{1}_Z38spdk_nvme_ctrlr_get_default_ctrlr_opts" ] pub fn spdk_nvme_ctrlr_get_default_ctrlr_opts ( opts : * mut spdk_nvme_ctrlr_opts , opts_size : usize ) ; } 
 /// PCIe Transport (locally attached devices) 
 pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_PCIE : spdk_nvme_transport_type = 256 ; 
 /// RDMA Transport (RoCE, iWARP, etc.) 
 pub const spdk_nvme_transport_type_SPDK_NVME_TRANSPORT_RDMA : spdk_nvme_transport_type = 1 ; 
 /// NVMe library transports
///
/// NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe,
/// which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.
///
/// Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE.
/// If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated. 
 pub type spdk_nvme_transport_type = u32 ; 
 /// NVMe transport identifier.
///
/// This identifies a unique endpoint on an NVMe fabric.
///
/// A string representation of a transport ID may be converted to this type using
/// spdk_nvme_transport_id_parse(). 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_transport_id { 
 /// NVMe transport type. 
 pub trtype : spdk_nvme_transport_type , 
 /// Address family of the transport address.
    ///
    /// For PCIe, this value is ignored. 
 pub adrfam : spdk_nvmf_adrfam , 
 /// Transport address of the NVMe-oF endpoint. For transports which use IP
    /// addressing (e.g. RDMA), this should be an IP address. For PCIe, this
    /// can either be a zero length string (the whole bus) or a PCI address
    /// in the format DDDD:BB:DD.FF or DDDD.BB.DD.FF 
 pub traddr : [ :: std :: os :: raw :: c_char ; 257usize ] , 
 /// Transport service id of the NVMe-oF endpoint.  For transports which use
    /// IP addressing (e.g. RDMA), this field shoud be the port number. For PCIe,
    /// this is always a zero length string. 
 pub trsvcid : [ :: std :: os :: raw :: c_char ; 33usize ] , 
 /// Subsystem NQN of the NVMe over Fabrics endpoint. May be a zero length string. 
 pub subnqn : [ :: std :: os :: raw :: c_char ; 224usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_transport_id ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_transport_id > ( ) , 524usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_transport_id ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_transport_id > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_transport_id ) ) ) ; } impl Default for spdk_nvme_transport_id { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// Parse the string representation of a transport ID.
///
/// \param trid Output transport ID structure (must be allocated and initialized by caller).
/// \param str Input string representation of a transport ID to parse.
/// \return 0 if parsing was successful and trid is filled out, or negated errno values on failure.
///
/// str must be a zero-terminated C string containing one or more key:value pairs separated by
/// whitespace.
///
/// Key          | Value
/// ------------ | -----
/// trtype       | Transport type (e.g. PCIe, RDMA)
/// adrfam       | Address family (e.g. IPv4, IPv6)
/// traddr       | Transport address (e.g. 0000:04:00.0 for PCIe or 192.168.100.8 for RDMA)
/// trsvcid      | Transport service identifier (e.g. 4420)
/// subnqn       | Subsystem NQN
///
/// Unspecified fields of trid are left unmodified, so the caller must initialize trid (for example,
/// memset() to 0) before calling this function. 
 # [ link_name = "\u{1}_Z28spdk_nvme_transport_id_parse" ] pub fn spdk_nvme_transport_id_parse ( trid : * mut spdk_nvme_transport_id , str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Parse the string representation of a transport ID tranport type.
///
/// \param trtype Output transport type (allocated by caller).
/// \param str Input string representation of transport type (e.g. "PCIe", "RDMA")
/// \return 0 if parsing was successful and trtype is filled out, or negated errno values on failure. 
 # [ link_name = "\u{1}_Z35spdk_nvme_transport_id_parse_trtype" ] pub fn spdk_nvme_transport_id_parse_trtype ( trtype : * mut spdk_nvme_transport_type , str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Look up the string representation of a transport ID transport type.
///
/// \param trtype Transport type to convert.
/// \return Static string constant describing trtype, or NULL if trtype not found. 
 # [ link_name = "\u{1}_Z33spdk_nvme_transport_id_trtype_str" ] pub fn spdk_nvme_transport_id_trtype_str ( trtype : spdk_nvme_transport_type ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { 
 /// Look up the string representation of a transport ID address family.
///
/// \param adrfam Address family to convert.
/// \return Static string constant describing adrfam, or NULL if adrmfam not found. 
 # [ link_name = "\u{1}_Z33spdk_nvme_transport_id_adrfam_str" ] pub fn spdk_nvme_transport_id_adrfam_str ( adrfam : spdk_nvmf_adrfam ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { 
 /// Parse the string representation of a tranport ID address family.
///
/// \param adrfam Output address family (allocated by caller).
/// \param str Input string representation of address family (e.g. "IPv4", "IPv6")
/// \return 0 if parsing was successful and adrfam is filled out, or negated errno values on failure. 
 # [ link_name = "\u{1}_Z35spdk_nvme_transport_id_parse_adrfam" ] pub fn spdk_nvme_transport_id_parse_adrfam ( adrfam : * mut spdk_nvmf_adrfam , str : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Compare two transport IDs.
///
/// \param trid1 First transport ID to compare.
/// \param trid2 Second transport ID to compare.
///
/// \return 0 if trid1 == trid2, less than 0 if trid1 < trid2, greater than 0 if trid1 > trid2.
///
/// The result of this function may be used to sort transport IDs in a consistent order; however,
/// the comparison result is not guaranteed to be consistent across library versions.
///
/// This function uses a case-insensitive comparison for string fields, but it does not otherwise
/// normalize the transport ID. It is the caller's responsibility to provide the transport IDs in
/// a consistent format. 
 # [ link_name = "\u{1}_Z30spdk_nvme_transport_id_compare" ] pub fn spdk_nvme_transport_id_compare ( trid1 : * const spdk_nvme_transport_id , trid2 : * const spdk_nvme_transport_id ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.
///
/// \param trtype NVMe over Fabrics transport type to check.
///
/// \return true if trtype is supported or false if it is not supported. 
 # [ link_name = "\u{1}_Z29spdk_nvme_transport_available" ] pub fn spdk_nvme_transport_available ( trtype : spdk_nvme_transport_type ) -> bool ; } 
 /// Callback for spdk_nvme_probe() enumeration.
///
/// \param opts NVMe controller initialization options.  This structure will be populated with the
/// default values on entry, and the user callback may update any options to request a different
/// value.  The controller may not support all requested parameters, so the final values will be
/// provided during the attach callback.
/// \return true to attach to this device. 
 pub type spdk_nvme_probe_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut :: std :: os :: raw :: c_void , trid : * const spdk_nvme_transport_id , opts : * mut spdk_nvme_ctrlr_opts ) -> bool > ; 
 /// Callback for spdk_nvme_probe() to report a device that has been attached to the userspace NVMe driver.
///
/// \param opts NVMe controller initialization options that were actually used.  Options may differ
/// from the requested options from the probe call depending on what the controller supports. 
 pub type spdk_nvme_attach_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut :: std :: os :: raw :: c_void , trid : * const spdk_nvme_transport_id , ctrlr : * mut spdk_nvme_ctrlr , opts : * const spdk_nvme_ctrlr_opts ) > ; 
 /// Callback for spdk_nvme_probe() to report that a device attached to the userspace NVMe driver
/// has been removed from the system.
///
/// The controller will remain in a failed state (any new I/O submitted will fail).
///
/// The controller must be detached from the userspace driver by calling spdk_nvme_detach()
/// once the controller is no longer in use.  It is up to the library user to ensure that
/// no other threads are using the controller before calling spdk_nvme_detach().
///
/// \param ctrlr NVMe controller instance that was removed. 
 pub type spdk_nvme_remove_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut :: std :: os :: raw :: c_void , ctrlr : * mut spdk_nvme_ctrlr ) > ; extern "C" { 
 /// \brief Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver
/// to each device found if desired.
///
/// \param trid The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL,
/// this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the
/// location of an NVMe-oF discovery service.
/// \param cb_ctx Opaque value which will be passed back in cb_ctx parameter of the callbacks.
/// \param probe_cb will be called once per NVMe device found in the system.
/// \param attach_cb will be called for devices for which probe_cb returned true once that NVMe
/// controller has been attached to the userspace driver.
/// \param remove_cb will be called for devices that were attached in a previous spdk_nvme_probe()
/// call but are no longer attached to the system. Optional; specify NULL if removal notices are not
/// desired.
///
/// This function is not thread safe and should only be called from one thread at a time while no
/// other threads are actively using any NVMe devices.
///
/// If called from a secondary process, only devices that have been attached to the userspace driver
/// in the primary process will be probed.
///
/// If called more than once, only devices that are not already attached to the SPDK NVMe driver
/// will be reported.
///
/// To stop using the the controller and release its associated resources,
/// call \ref spdk_nvme_detach with the spdk_nvme_ctrlr instance from the attach_cb() function. 
 # [ link_name = "\u{1}_Z15spdk_nvme_probe" ] pub fn spdk_nvme_probe ( trid : * const spdk_nvme_transport_id , cb_ctx : * mut :: std :: os :: raw :: c_void , probe_cb : spdk_nvme_probe_cb , attach_cb : spdk_nvme_attach_cb , remove_cb : spdk_nvme_remove_cb ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Connect the NVMe driver to the device located at the given transport ID.
///
/// \param trid The transport ID indicating which device to connect. If the trtype is PCIe, this will
/// connect the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the
/// location of an NVMe-oF service.
/// \param opts NVMe controller initialization options. Default values will be used if the user does
/// not specify the options. The controller may not support all requested parameters.
/// \param opts_size Must be set to sizeof(struct spdk_nvme_ctrlr_opts), or 0 if opts is NULL.
///
/// \return pointer to the connected NVMe controller or NULL if there is any failure.
///
/// This function is not thread safe and should only be called from one thread at a time while no
/// other threads are actively using this NVMe device.
///
/// If called from a secondary process, only the device that has been attached to the userspace driver
/// in the primary process will be connected.
///
/// If connecting to multiple controllers, it is suggested to use spdk_nvme_probe() and filter the
/// requested controllers with the probe callback. For PCIe controllers, spdk_nvme_probe() will be
/// more efficient since the controller resets will happen in parallel.
///
/// To stop using the the controller and release its associated resources,
/// call \ref spdk_nvme_detach with the spdk_nvme_ctrlr instance returned by this function. 
 # [ link_name = "\u{1}_Z17spdk_nvme_connect" ] pub fn spdk_nvme_connect ( trid : * const spdk_nvme_transport_id , opts : * const spdk_nvme_ctrlr_opts , opts_size : usize ) -> * mut spdk_nvme_ctrlr ; } extern "C" { 
 /// \brief Detaches specified device returned by \ref spdk_nvme_probe()'s attach_cb from the NVMe driver.
///
/// On success, the spdk_nvme_ctrlr handle is no longer valid.
///
/// This function should be called from a single thread while no other threads
/// are actively using the NVMe device.
/// 
 # [ link_name = "\u{1}_Z16spdk_nvme_detach" ] pub fn spdk_nvme_detach ( ctrlr : * mut spdk_nvme_ctrlr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Perform a full hardware reset of the NVMe controller.
///
/// This function should be called from a single thread while no other threads
/// are actively using the NVMe device.
///
/// Any pointers returned from spdk_nvme_ctrlr_get_ns() and spdk_nvme_ns_get_data() may be invalidated
/// by calling this function.  The number of namespaces as returned by spdk_nvme_ctrlr_get_num_ns() may
/// also change. 
 # [ link_name = "\u{1}_Z21spdk_nvme_ctrlr_reset" ] pub fn spdk_nvme_ctrlr_reset ( ctrlr : * mut spdk_nvme_ctrlr ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Get the identify controller data as defined by the NVMe specification.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
/// 
 # [ link_name = "\u{1}_Z24spdk_nvme_ctrlr_get_data" ] pub fn spdk_nvme_ctrlr_get_data ( ctrlr : * mut spdk_nvme_ctrlr ) -> * const spdk_nvme_ctrlr_data ; } extern "C" { 
 /// \brief Get the NVMe controller CSTS (Status) register. 
 # [ link_name = "\u{1}_Z29spdk_nvme_ctrlr_get_regs_csts" ] pub fn spdk_nvme_ctrlr_get_regs_csts ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_csts_register ; } extern "C" { 
 /// \brief Get the NVMe controller CAP (Capabilities) register. 
 # [ link_name = "\u{1}_Z28spdk_nvme_ctrlr_get_regs_cap" ] pub fn spdk_nvme_ctrlr_get_regs_cap ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_cap_register ; } extern "C" { 
 /// \brief Get the NVMe controller VS (Version) register. 
 # [ link_name = "\u{1}_Z27spdk_nvme_ctrlr_get_regs_vs" ] pub fn spdk_nvme_ctrlr_get_regs_vs ( ctrlr : * mut spdk_nvme_ctrlr ) -> spdk_nvme_vs_register ; } extern "C" { 
 /// \brief Get the number of namespaces for the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// This is equivalent to calling spdk_nvme_ctrlr_get_data() to get the
/// spdk_nvme_ctrlr_data and then reading the nn field.
/// 
 # [ link_name = "\u{1}_Z26spdk_nvme_ctrlr_get_num_ns" ] pub fn spdk_nvme_ctrlr_get_num_ns ( ctrlr : * mut spdk_nvme_ctrlr ) -> u32 ; } extern "C" { 
 /// \brief Get the PCI device of a given NVMe controller.
///
/// \return PCI device of the NVMe controller, or NULL if not available.
///
/// This only works for local (PCIe-attached) NVMe controllers; other transports will return NULL. 
 # [ link_name = "\u{1}_Z30spdk_nvme_ctrlr_get_pci_device" ] pub fn spdk_nvme_ctrlr_get_pci_device ( ctrlr : * mut spdk_nvme_ctrlr ) -> * mut spdk_pci_device ; } extern "C" { 
 /// \brief Return true if nsid is an active ns for the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
/// 
 # [ link_name = "\u{1}_Z28spdk_nvme_ctrlr_is_active_ns" ] pub fn spdk_nvme_ctrlr_is_active_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 ) -> bool ; } extern "C" { 
 /// \brief Return the nsid of the first active namespace, 0 if there are no active namespaces.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
/// 
 # [ link_name = "\u{1}_Z35spdk_nvme_ctrlr_get_first_active_ns" ] pub fn spdk_nvme_ctrlr_get_first_active_ns ( ctrlr : * mut spdk_nvme_ctrlr ) -> u32 ; } extern "C" { 
 /// \brief Return a next active namespace given the previous ns id, 0 when there are no more active namespaces.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
/// 
 # [ link_name = "\u{1}_Z34spdk_nvme_ctrlr_get_next_active_ns" ] pub fn spdk_nvme_ctrlr_get_next_active_ns ( ctrlr : * mut spdk_nvme_ctrlr , prev_nsid : u32 ) -> u32 ; } extern "C" { 
 /// \brief Determine if a particular log page is supported by the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// \sa spdk_nvme_ctrlr_cmd_get_log_page() 
 # [ link_name = "\u{1}_Z37spdk_nvme_ctrlr_is_log_page_supported" ] pub fn spdk_nvme_ctrlr_is_log_page_supported ( ctrlr : * mut spdk_nvme_ctrlr , log_page : u8 ) -> bool ; } extern "C" { 
 /// \brief Determine if a particular feature is supported by the given NVMe controller.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// \sa spdk_nvme_ctrlr_cmd_get_feature() 
 # [ link_name = "\u{1}_Z36spdk_nvme_ctrlr_is_feature_supported" ] pub fn spdk_nvme_ctrlr_is_feature_supported ( ctrlr : * mut spdk_nvme_ctrlr , feature_code : u8 ) -> bool ; } 
 /// Signature for callback function invoked when a command is completed.
///
/// The spdk_nvme_cpl parameter contains the completion status. 
 pub type spdk_nvme_cmd_cb = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const spdk_nvme_cpl ) > ; 
 /// Signature for callback function invoked when an asynchronous error
/// request command is completed.
///
/// The aer_cb_arg parameter is set to the context specified by
/// spdk_nvme_register_aer_callback().
/// The spdk_nvme_cpl parameter contains the completion status of the
/// asynchronous event request that was completed. 
 pub type spdk_nvme_aer_cb = :: std :: option :: Option < unsafe extern "C" fn ( aer_cb_arg : * mut :: std :: os :: raw :: c_void , arg1 : * const spdk_nvme_cpl ) > ; extern "C" { # [ link_name = "\u{1}_Z37spdk_nvme_ctrlr_register_aer_callback" ] pub fn spdk_nvme_ctrlr_register_aer_callback ( ctrlr : * mut spdk_nvme_ctrlr , aer_cb_fn : spdk_nvme_aer_cb , aer_cb_arg : * mut :: std :: os :: raw :: c_void ) ; } 
 /// \brief Opaque handle to a queue pair.
///
/// I/O queue pairs may be allocated using spdk_nvme_ctrlr_alloc_io_qpair(). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_qpair { _unused : [ u8 ; 0 ] , } 
 /// Signature for the callback function invoked when a timeout is
/// detected on a request.
/// For timeouts detected on the admin queue pair, the qpair returned
/// here will be NULL. 
 pub type spdk_nvme_timeout_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut :: std :: os :: raw :: c_void , ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cid : u16 ) > ; extern "C" { 
 /// \brief Register for timeout callback on a controller.
///
/// The application can choose to register for timeout callback or not register
/// for timeout callback.
///
/// \param ctrlr NVMe controller on which to monitor for timeout.
/// \param timeout_sec Timeout value in seconds.
/// \param cb_fn A function pointer that points to the callback function
/// \param cb_arg Argument to the callback function. 
 # [ link_name = "\u{1}_Z41spdk_nvme_ctrlr_register_timeout_callback" ] pub fn spdk_nvme_ctrlr_register_timeout_callback ( ctrlr : * mut spdk_nvme_ctrlr , timeout_sec : u32 , cb_fn : spdk_nvme_timeout_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) ; } 
 /// \brief NVMe I/O queue pair initialization options.
///
/// These options may be passed to spdk_nvme_ctrlr_alloc_io_qpair() to configure queue pair
/// options at queue creation time.
///
/// The user may retrieve the default I/O queue pair creation options for a controller using
/// spdk_nvme_ctrlr_get_default_io_qpair_opts(). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_io_qpair_opts { 
 /// Queue priority for weighted round robin arbitration.  If a different arbitration
    /// method is in use, pass 0. 
 pub qprio : spdk_nvme_qprio , 
 /// The queue depth of this NVMe I/O queue. Overrides spdk_nvme_ctrlr_opts::io_queue_size. 
 pub io_queue_size : u32 , 
 /// The number of requests to allocate for this NVMe I/O queue.
    ///
    /// Overrides spdk_nvme_ctrlr_opts::io_queue_requests.
    ///
    /// This should be at least as large as io_queue_size.
    ///
    /// A single I/O may allocate more than one request, since splitting may be necessary to
    /// conform to the device's maximum transfer size, PRP list compatibility requirements,
    /// or driver-assisted striping. 
 pub io_queue_requests : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvme_io_qpair_opts ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_io_qpair_opts > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_io_qpair_opts ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_io_qpair_opts > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_io_qpair_opts ) ) ) ; } impl Default for spdk_nvme_io_qpair_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { 
 /// \brief Get the default options for I/O qpair creation for a specific NVMe controller.
///
/// \param ctrlr NVMe controller to retrieve the defaults from.
/// \param[out] opts Will be filled with the default options for spdk_nvme_ctrlr_alloc_io_qpair().
/// \param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts). 
 # [ link_name = "\u{1}_Z41spdk_nvme_ctrlr_get_default_io_qpair_opts" ] pub fn spdk_nvme_ctrlr_get_default_io_qpair_opts ( ctrlr : * mut spdk_nvme_ctrlr , opts : * mut spdk_nvme_io_qpair_opts , opts_size : usize ) ; } extern "C" { 
 /// \brief Allocate an I/O queue pair (submission and completion queue).
///
/// Each queue pair should only be used from a single thread at a time (mutual exclusion must be
/// enforced by the user).
///
/// \param ctrlr NVMe controller for which to allocate the I/O queue pair.
/// \param opts I/O qpair creation options, or NULL to use the defaults as returned by
/// spdk_nvme_ctrlr_alloc_io_qpair().
/// \param opts_size Must be set to sizeof(struct spdk_nvme_io_qpair_opts), or 0 if opts is NULL. 
 # [ link_name = "\u{1}_Z30spdk_nvme_ctrlr_alloc_io_qpair" ] pub fn spdk_nvme_ctrlr_alloc_io_qpair ( ctrlr : * mut spdk_nvme_ctrlr , opts : * const spdk_nvme_io_qpair_opts , opts_size : usize ) -> * mut spdk_nvme_qpair ; } extern "C" { 
 /// \brief Free an I/O queue pair that was allocated by spdk_nvme_ctrlr_alloc_io_qpair(). 
 # [ link_name = "\u{1}_Z29spdk_nvme_ctrlr_free_io_qpair" ] pub fn spdk_nvme_ctrlr_free_io_qpair ( qpair : * mut spdk_nvme_qpair ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Send the given NVM I/O command to the NVMe controller.
///
/// This is a low level interface for submitting I/O commands directly. Prefer
/// the spdk_nvme_ns_cmd_* functions instead. The validity of the command will
/// not be checked!
///
/// When constructing the nvme_command it is not necessary to fill out the PRP
/// list/SGL or the CID. The driver will handle both of those for you.
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z26spdk_nvme_ctrlr_cmd_io_raw" ] pub fn spdk_nvme_ctrlr_cmd_io_raw ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cmd : * mut spdk_nvme_cmd , buf : * mut :: std :: os :: raw :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Send the given NVM I/O command with metadata to the NVMe controller.
///
/// This is a low level interface for submitting I/O commands directly. Prefer
/// the spdk_nvme_ns_cmd_* functions instead. The validity of the command will
/// not be checked!
///
/// When constructing the nvme_command it is not necessary to fill out the PRP
/// list/SGL or the CID. The driver will handle both of those for you.
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z34spdk_nvme_ctrlr_cmd_io_raw_with_md" ] pub fn spdk_nvme_ctrlr_cmd_io_raw_with_md ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cmd : * mut spdk_nvme_cmd , buf : * mut :: std :: os :: raw :: c_void , len : u32 , md_buf : * mut :: std :: os :: raw :: c_void , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Process any outstanding completions for I/O submitted on a queue pair.
///
/// This call is non-blocking, i.e. it only
/// processes completions that are ready at the time of this function call. It does not
/// wait for outstanding commands to finish.
///
/// For each completed command, the request's callback function will
/// be called if specified as non-NULL when the request was submitted.
///
/// \param qpair Queue pair to check for completions.
/// \param max_completions Limit the number of completions to be processed in one call, or 0
/// for unlimited.
///
/// \return Number of completions processed (may be 0) or negative on error.
///
/// \sa spdk_nvme_cmd_cb
///
/// This function may be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// The caller must ensure that each queue pair is only used from one thread at a time. 
 # [ link_name = "\u{1}_Z35spdk_nvme_qpair_process_completions" ] pub fn spdk_nvme_qpair_process_completions ( qpair : * mut spdk_nvme_qpair , max_completions : u32 ) -> i32 ; } extern "C" { 
 /// \brief Send the given admin command to the NVMe controller.
///
/// This is a low level interface for submitting admin commands directly. Prefer
/// the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will
/// not be checked!
///
/// When constructing the nvme_command it is not necessary to fill out the PRP
/// list/SGL or the CID. The driver will handle both of those for you.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function. 
 # [ link_name = "\u{1}_Z29spdk_nvme_ctrlr_cmd_admin_raw" ] pub fn spdk_nvme_ctrlr_cmd_admin_raw ( ctrlr : * mut spdk_nvme_ctrlr , cmd : * mut spdk_nvme_cmd , buf : * mut :: std :: os :: raw :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Process any outstanding completions for admin commands.
///
/// This will process completions for admin commands submitted on any thread.
///
/// This call is non-blocking, i.e. it only processes completions that are ready
/// at the time of this function call. It does not wait for outstanding commands to
/// finish.
///
/// \return Number of completions processed (may be 0) or negative on error.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z41spdk_nvme_ctrlr_process_admin_completions" ] pub fn spdk_nvme_ctrlr_process_admin_completions ( ctrlr : * mut spdk_nvme_ctrlr ) -> i32 ; } 
 /// \brief Opaque handle to a namespace. Obtained by calling spdk_nvme_ctrlr_get_ns(). 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_nvme_ns { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// \brief Get a handle to a namespace for the given controller.
///
/// Namespaces are numbered from 1 to the total number of namespaces. There will never
/// be any gaps in the numbering. The number of namespaces is obtained by calling
/// spdk_nvme_ctrlr_get_num_ns().
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ctrlr_get_ns" ] pub fn spdk_nvme_ctrlr_get_ns ( ctrlr : * mut spdk_nvme_ctrlr , ns_id : u32 ) -> * mut spdk_nvme_ns ; } extern "C" { 
 /// \brief Get a specific log page from the NVMe controller.
///
/// \param ctrlr NVMe controller to query.
/// \param log_page The log page identifier.
/// \param nsid Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG.
/// \param payload The pointer to the payload buffer.
/// \param payload_size The size of payload buffer.
/// \param offset Offset in bytes within the log page to start retrieving log page data.
/// May only be non-zero if the controller supports extended data for Get Log Page
/// as reported in the controller data log page attributes.
/// \param cb_fn Callback function to invoke when the log page has been retrieved.
/// \param cb_arg Argument to pass to the callback function.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
///
/// \sa spdk_nvme_ctrlr_is_log_page_supported() 
 # [ link_name = "\u{1}_Z32spdk_nvme_ctrlr_cmd_get_log_page" ] pub fn spdk_nvme_ctrlr_cmd_get_log_page ( ctrlr : * mut spdk_nvme_ctrlr , log_page : u8 , nsid : u32 , payload : * mut :: std :: os :: raw :: c_void , payload_size : u32 , offset : u64 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Abort a specific previously-submitted NVMe command.
///
/// \param ctrlr NVMe controller to which the command was submitted.
/// \param qpair NVMe queue pair to which the command was submitted.
/// For admin commands, pass NULL for the qpair.
/// \param cid Command ID of the command to abort.
/// \param cb_fn Callback function to invoke when the abort has completed.
/// \param cb_arg Argument to pass to the callback function.\
///
/// \return 0 if successfully submitted, negated errno value otherwise.
///
/// \sa spdk_nvme_ctrlr_register_timeout_callback() 
 # [ link_name = "\u{1}_Z25spdk_nvme_ctrlr_cmd_abort" ] pub fn spdk_nvme_ctrlr_cmd_abort ( ctrlr : * mut spdk_nvme_ctrlr , qpair : * mut spdk_nvme_qpair , cid : u16 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Set specific feature for the given NVMe controller.
///
/// \param ctrlr NVMe controller to manipulate.
/// \param feature The feature identifier.
/// \param cdw11 as defined by the specification for this command.
/// \param cdw12 as defined by the specification for this command.
/// \param payload The pointer to the payload buffer.
/// \param payload_size The size of payload buffer.
/// \param cb_fn Callback function to invoke when the feature has been set.
/// \param cb_arg Argument to pass to the callback function.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
///
/// \sa spdk_nvme_ctrlr_cmd_get_feature() 
 # [ link_name = "\u{1}_Z31spdk_nvme_ctrlr_cmd_set_feature" ] pub fn spdk_nvme_ctrlr_cmd_set_feature ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , cdw12 : u32 , payload : * mut :: std :: os :: raw :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Get specific feature from given NVMe controller.
///
/// \param ctrlr NVMe controller to query.
/// \param feature The feature identifier.
/// \param cdw11 as defined by the specification for this command.
/// \param payload The pointer to the payload buffer.
/// \param payload_size The size of payload buffer.
/// \param cb_fn Callback function to invoke when the feature has been retrieved.
/// \param cb_arg Argument to pass to the callback function.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver.
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function.
///
/// \sa spdk_nvme_ctrlr_cmd_set_feature() 
 # [ link_name = "\u{1}_Z31spdk_nvme_ctrlr_cmd_get_feature" ] pub fn spdk_nvme_ctrlr_cmd_get_feature ( ctrlr : * mut spdk_nvme_ctrlr , feature : u8 , cdw11 : u32 , payload : * mut :: std :: os :: raw :: c_void , payload_size : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Attach the specified namespace to controllers.
///
/// \param ctrlr NVMe controller to use for command submission.
/// \param nsid Namespace identifier for namespace to attach.
/// \param payload The pointer to the controller list.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_probe().
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function. 
 # [ link_name = "\u{1}_Z25spdk_nvme_ctrlr_attach_ns" ] pub fn spdk_nvme_ctrlr_attach_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut spdk_nvme_ctrlr_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Detach the specified namespace from controllers.
///
/// \param ctrlr NVMe controller to use for command submission.
/// \param nsid Namespace ID to detach.
/// \param payload The pointer to the controller list.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_probe().
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function. 
 # [ link_name = "\u{1}_Z25spdk_nvme_ctrlr_detach_ns" ] pub fn spdk_nvme_ctrlr_detach_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , payload : * mut spdk_nvme_ctrlr_list ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Create a namespace.
///
/// \param ctrlr NVMe controller to create namespace on.
/// \param payload The pointer to the NVMe namespace data.
///
/// \return Namespace ID (>= 1) if successfully created, or 0 if the request failed.
///
/// This function is thread safe and can be called at any point after spdk_nvme_probe(). 
 # [ link_name = "\u{1}_Z25spdk_nvme_ctrlr_create_ns" ] pub fn spdk_nvme_ctrlr_create_ns ( ctrlr : * mut spdk_nvme_ctrlr , payload : * mut spdk_nvme_ns_data ) -> u32 ; } extern "C" { 
 /// \brief Delete a namespace.
///
/// \param ctrlr NVMe controller to delete namespace from.
/// \param nsid The namespace identifier.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_probe().
///
/// Call \ref spdk_nvme_ctrlr_process_admin_completions() to poll for completion
/// of commands submitted through this function. 
 # [ link_name = "\u{1}_Z25spdk_nvme_ctrlr_delete_ns" ] pub fn spdk_nvme_ctrlr_delete_ns ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Format NVM.
///
/// This function requests a low-level format of the media.
///
/// \param ctrlr NVMe controller to format.
/// \param nsid The namespace identifier.  May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces.
/// \param format The format information for the command.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request
///
/// This function is thread safe and can be called at any point after spdk_nvme_probe(). 
 # [ link_name = "\u{1}_Z22spdk_nvme_ctrlr_format" ] pub fn spdk_nvme_ctrlr_format ( ctrlr : * mut spdk_nvme_ctrlr , nsid : u32 , format : * mut spdk_nvme_format ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Download a new firmware image.
///
/// \param payload The data buffer for the firmware image.
/// \param size The data size will be downloaded.
/// \param slot The slot that the firmware image will be committed to.
/// \param commit_action The action to perform when firmware is committed.
/// \param completion_status output parameter. Contains the completion status of the firmware commit operation.
///
/// \return 0 if successfully submitted, ENOMEM if resources could not be allocated for this request,
/// -1 if the size is not multiple of 4.
///
/// This function is thread safe and can be called at any point after spdk_nvme_probe(). 
 # [ link_name = "\u{1}_Z31spdk_nvme_ctrlr_update_firmware" ] pub fn spdk_nvme_ctrlr_update_firmware ( ctrlr : * mut spdk_nvme_ctrlr , payload : * mut :: std :: os :: raw :: c_void , size : u32 , slot : :: std :: os :: raw :: c_int , commit_action : spdk_nvme_fw_commit_action , completion_status : * mut spdk_nvme_status ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Allocate an I/O buffer from the controller memory buffer (Experimental).
///
/// \param ctrlr Controller from which to allocate memory buffer.
/// \param size Size of buffer to allocate in bytes.
///
/// \return Pointer to controller memory buffer allocation, or NULL if allocation was not possible.
///
/// This function allocates registered memory which belongs to the
/// Controller Memory Buffer (CMB) of the specified NVMe
/// controller. Note that the CMB has to support the WDS and RDS
/// capabilities for the allocation to be successful. Also, due to
/// vtophys contraints the CMB must be at least 4MiB in size. Free
/// memory allocated with this function using
/// spdk_nvme_ctrlr_free_cmb_io_buffer(). 
 # [ link_name = "\u{1}_Z35spdk_nvme_ctrlr_alloc_cmb_io_buffer" ] pub fn spdk_nvme_ctrlr_alloc_cmb_io_buffer ( ctrlr : * mut spdk_nvme_ctrlr , size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { 
 /// \brief Free a controller memory I/O buffer (Experimental).
///
/// \param ctrlr Controller from which the buffer was allocated.
/// \param buf Buffer previously allocated by spdk_nvme_ctrlr_alloc_cmb_io_buffer().
/// \param size Size of buf in bytes.
///
/// Note this function is currently a NOP which is not a good thing and
/// is one reason why this and spdk_nvme_ctrlr_alloc_cmb_io_buffer()
/// are currently marked as experimental. 
 # [ link_name = "\u{1}_Z34spdk_nvme_ctrlr_free_cmb_io_buffer" ] pub fn spdk_nvme_ctrlr_free_cmb_io_buffer ( ctrlr : * mut spdk_nvme_ctrlr , buf : * mut :: std :: os :: raw :: c_void , size : usize ) ; } extern "C" { 
 /// \brief Get the identify namespace data as defined by the NVMe specification.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z21spdk_nvme_ns_get_data" ] pub fn spdk_nvme_ns_get_data ( ns : * mut spdk_nvme_ns ) -> * const spdk_nvme_ns_data ; } extern "C" { 
 /// \brief Get the namespace id (index number) from the given namespace handle.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z19spdk_nvme_ns_get_id" ] pub fn spdk_nvme_ns_get_id ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { 
 /// \brief Get the Controller with which this namespace is associated.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ns_get_ctrlr" ] pub fn spdk_nvme_ns_get_ctrlr ( ns : * mut spdk_nvme_ns ) -> * mut spdk_nvme_ctrlr ; } extern "C" { 
 /// \brief Determine whether a namespace is active.
///
/// Inactive namespaces cannot be the target of I/O commands. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ns_is_active" ] pub fn spdk_nvme_ns_is_active ( ns : * mut spdk_nvme_ns ) -> bool ; } extern "C" { 
 /// \brief Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z33spdk_nvme_ns_get_max_io_xfer_size" ] pub fn spdk_nvme_ns_get_max_io_xfer_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { 
 /// \brief Get the sector size, in bytes, of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z28spdk_nvme_ns_get_sector_size" ] pub fn spdk_nvme_ns_get_sector_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { 
 /// \brief Get the number of sectors for the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z28spdk_nvme_ns_get_num_sectors" ] pub fn spdk_nvme_ns_get_num_sectors ( ns : * mut spdk_nvme_ns ) -> u64 ; } extern "C" { 
 /// \brief Get the size, in bytes, of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z21spdk_nvme_ns_get_size" ] pub fn spdk_nvme_ns_get_size ( ns : * mut spdk_nvme_ns ) -> u64 ; } extern "C" { 
 /// \brief Get the end-to-end data protection information type of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z24spdk_nvme_ns_get_pi_type" ] pub fn spdk_nvme_ns_get_pi_type ( ns : * mut spdk_nvme_ns ) -> spdk_nvme_pi_type ; } extern "C" { 
 /// \brief Get the metadata size, in bytes, of the given namespace.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z24spdk_nvme_ns_get_md_size" ] pub fn spdk_nvme_ns_get_md_size ( ns : * mut spdk_nvme_ns ) -> u32 ; } extern "C" { 
 /// \brief True if the namespace can support extended LBA when end-to-end data protection enabled.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z34spdk_nvme_ns_supports_extended_lba" ] pub fn spdk_nvme_ns_supports_extended_lba ( ns : * mut spdk_nvme_ns ) -> bool ; } extern "C" { 
 /// \brief Determine the value returned when reading deallocated blocks.
///
/// If deallocated blocks return 0, the deallocate command can be used as a more efficient alternative
/// to the write_zeroes command, especially for large requests. 
 # [ link_name = "\u{1}_Z49spdk_nvme_ns_get_dealloc_logical_block_read_value" ] pub fn spdk_nvme_ns_get_dealloc_logical_block_read_value ( ns : * mut spdk_nvme_ns ) -> spdk_nvme_dealloc_logical_block_read_value ; } extern "C" { 
 /// \brief Get the optimal I/O boundary, in blocks, for the given namespace.
///
/// \return Optimal granularity of I/O commands, in blocks, or 0 if no optimal granularity is reported.
///
/// Read and write commands should not cross the optimal I/O boundary for best performance. 
 # [ link_name = "\u{1}_Z36spdk_nvme_ns_get_optimal_io_boundary" ] pub fn spdk_nvme_ns_get_optimal_io_boundary ( ns : * mut spdk_nvme_ns ) -> u32 ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_uuid { _unused : [ u8 ; 0 ] , } extern "C" { 
 /// Get the UUID for the given namespace.
///
/// \param ns Namespace to query.
///
/// \return Pointer to namespace UUID, or NULL if ns does not have a UUID. 
 # [ link_name = "\u{1}_Z21spdk_nvme_ns_get_uuid" ] pub fn spdk_nvme_ns_get_uuid ( ns : * const spdk_nvme_ns ) -> * const spdk_uuid ; } 
 /// < The deallocate command is supported 
 pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DEALLOCATE_SUPPORTED : spdk_nvme_ns_flags = 1 ; 
 /// < The flush command is supported 
 pub const spdk_nvme_ns_flags_SPDK_NVME_NS_FLUSH_SUPPORTED : spdk_nvme_ns_flags = 2 ; 
 /// < The reservation command is supported 
 pub const spdk_nvme_ns_flags_SPDK_NVME_NS_RESERVATION_SUPPORTED : spdk_nvme_ns_flags = 4 ; 
 /// < The write zeroes command is supported 
 pub const spdk_nvme_ns_flags_SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED : spdk_nvme_ns_flags = 8 ; 
 /// < The end-to-end data protection is supported 
 pub const spdk_nvme_ns_flags_SPDK_NVME_NS_DPS_PI_SUPPORTED : spdk_nvme_ns_flags = 16 ; 
 /// < The extended lba format is supported,
/// metadata is transferred as a contiguous
/// part of the logical block that it is associated with 
 pub const spdk_nvme_ns_flags_SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED : spdk_nvme_ns_flags = 32 ; 
 /// \brief Namespace command support flags. 
 pub type spdk_nvme_ns_flags = u32 ; extern "C" { 
 /// \brief Get the flags for the given namespace.
///
/// See spdk_nvme_ns_flags for the possible flags returned.
///
/// This function is thread safe and can be called at any point while the controller is attached to
/// the SPDK NVMe driver. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ns_get_flags" ] pub fn spdk_nvme_ns_get_flags ( ns : * mut spdk_nvme_ns ) -> u32 ; } 
 /// Restart the SGL walk to the specified offset when the command has scattered payloads.
///
/// The cb_arg parameter is the value passed to readv/writev. 
 pub type spdk_nvme_req_reset_sgl_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut :: std :: os :: raw :: c_void , offset : u32 ) > ; 
 /// Fill out *address and *length with the current SGL entry and advance to the next
/// entry for the next time the callback is invoked.
///
/// The cb_arg parameter is the value passed to readv/writev.
/// The address parameter contains the virtual address of this segment.
/// The length parameter contains the length of this physical segment.
/// The described segment must be physically contiguous. 
 pub type spdk_nvme_req_next_sge_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut :: std :: os :: raw :: c_void , address : * mut * mut :: std :: os :: raw :: c_void , length : * mut u32 ) -> :: std :: os :: raw :: c_int > ; extern "C" { 
 /// \brief Submits a write I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param lba starting LBA to write the data
/// \param lba_count length (in sectors) for the write operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
/// in spdk/nvme_spec.h, for this I/O.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ns_cmd_write" ] pub fn spdk_nvme_ns_cmd_write ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a write I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA to write the data
/// \param lba_count length (in sectors) for the write operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param reset_sgl_fn callback function to reset scattered payload
/// \param next_sge_fn callback function to iterate each scattered
/// payload memory segment
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z23spdk_nvme_ns_cmd_writev" ] pub fn spdk_nvme_ns_cmd_writev ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a write I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param metadata virtual address pointer to the metadata payload, the length
/// of metadata is specified by spdk_nvme_ns_get_md_size()
/// \param lba starting LBA to write the data
/// \param lba_count length (in sectors) for the write operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
/// in spdk/nvme_spec.h, for this I/O.
/// \param apptag_mask application tag mask.
/// \param apptag application tag to use end-to-end protection information.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z30spdk_nvme_ns_cmd_write_with_md" ] pub fn spdk_nvme_ns_cmd_write_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , metadata : * mut :: std :: os :: raw :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a write zeroes I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the write zeroes I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA for this command
/// \param lba_count length (in sectors) for the write zero operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined by the SPDK_NVME_IO_FLAGS_* entries
/// in spdk/nvme_spec.h, for this I/O.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z29spdk_nvme_ns_cmd_write_zeroes" ] pub fn spdk_nvme_ns_cmd_write_zeroes ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a read I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the read I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param lba starting LBA to read the data
/// \param lba_count length (in sectors) for the read operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z21spdk_nvme_ns_cmd_read" ] pub fn spdk_nvme_ns_cmd_read ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a read I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the read I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA to read the data
/// \param lba_count length (in sectors) for the read operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param reset_sgl_fn callback function to reset scattered payload
/// \param next_sge_fn callback function to iterate each scattered
/// payload memory segment
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ns_cmd_readv" ] pub fn spdk_nvme_ns_cmd_readv ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a read I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the read I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param metadata virtual address pointer to the metadata payload, the length
/// of metadata is specified by spdk_nvme_ns_get_md_size()
/// \param lba starting LBA to read the data
/// \param lba_count length (in sectors) for the read operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param apptag_mask application tag mask.
/// \param apptag application tag to use end-to-end protection information.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z29spdk_nvme_ns_cmd_read_with_md" ] pub fn spdk_nvme_ns_cmd_read_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , metadata : * mut :: std :: os :: raw :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a data set management request to the specified NVMe namespace. Data set
/// management operations are designed to optimize interaction with the block
/// translation layer inside the device. The most common type of operation is
/// deallocate, which is often referred to as TRIM or UNMAP.
///
/// \param ns NVMe namespace to submit the DSM request
/// \param type A bit field constructed from \ref enum spdk_nvme_dsm_attribute.
/// \param qpair I/O queue pair to submit the request
/// \param ranges An array of \ref spdk_nvme_dsm_range elements describing
/// the LBAs to operate on.
/// \param num_ranges The number of elements in the ranges array.
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, negated POSIX errno values otherwise.
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time.
///
/// This is a convenience wrapper that will automatically allocate and construct the correct
/// data buffers. Therefore, ranges does not need to be allocated from pinned memory and
/// can be placed on the stack. If a higher performance, zero-copy version of DSM is
/// required, simply build and submit a raw command using spdk_nvme_ctrlr_cmd_io_raw(). 
 # [ link_name = "\u{1}_Z35spdk_nvme_ns_cmd_dataset_management" ] pub fn spdk_nvme_ns_cmd_dataset_management ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , type_ : u32 , ranges : * const spdk_nvme_dsm_range , num_ranges : u16 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a flush request to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the flush request
/// \param qpair I/O queue pair to submit the request
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z22spdk_nvme_ns_cmd_flush" ] pub fn spdk_nvme_ns_cmd_flush ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a reservation register to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation register request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the reservation register data
/// \param ignore_key '1' the current reservation key check is disabled
/// \param action specifies the registration action
/// \param cptpl change the Persist Through Power Loss state
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z37spdk_nvme_ns_cmd_reservation_register" ] pub fn spdk_nvme_ns_cmd_reservation_register ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_register_data , ignore_key : bool , action : spdk_nvme_reservation_register_action , cptpl : spdk_nvme_reservation_register_cptpl , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a reservation release to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation release request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to current reservation key
/// \param ignore_key '1' the current reservation key check is disabled
/// \param action specifies the reservation release action
/// \param type reservation type for the namespace
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z36spdk_nvme_ns_cmd_reservation_release" ] pub fn spdk_nvme_ns_cmd_reservation_release ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_key_data , ignore_key : bool , action : spdk_nvme_reservation_release_action , type_ : spdk_nvme_reservation_type , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a reservation acquire to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation acquire request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to reservation acquire data
/// \param ignore_key '1' the current reservation key check is disabled
/// \param action specifies the reservation acquire action
/// \param type reservation type for the namespace
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z36spdk_nvme_ns_cmd_reservation_acquire" ] pub fn spdk_nvme_ns_cmd_reservation_acquire ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut spdk_nvme_reservation_acquire_data , ignore_key : bool , action : spdk_nvme_reservation_acquire_action , type_ : spdk_nvme_reservation_type , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a reservation report to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the reservation report request
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer for reservation status data
/// \param len length bytes for reservation status data structure
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z35spdk_nvme_ns_cmd_reservation_report" ] pub fn spdk_nvme_ns_cmd_reservation_report ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , len : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a compare I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the compare I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param lba starting LBA to compare the data
/// \param lba_count length (in sectors) for the compare operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z24spdk_nvme_ns_cmd_compare" ] pub fn spdk_nvme_ns_cmd_compare ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a compare I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the compare I/O
/// \param qpair I/O queue pair to submit the request
/// \param lba starting LBA to compare the data
/// \param lba_count length (in sectors) for the compare operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param reset_sgl_fn callback function to reset scattered payload
/// \param next_sge_fn callback function to iterate each scattered
/// payload memory segment
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z25spdk_nvme_ns_cmd_comparev" ] pub fn spdk_nvme_ns_cmd_comparev ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 , reset_sgl_fn : spdk_nvme_req_reset_sgl_cb , next_sge_fn : spdk_nvme_req_next_sge_cb ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// \brief Submits a compare I/O to the specified NVMe namespace.
///
/// \param ns NVMe namespace to submit the compare I/O
/// \param qpair I/O queue pair to submit the request
/// \param payload virtual address pointer to the data payload
/// \param metadata virtual address pointer to the metadata payload, the length
/// of metadata is specified by spdk_nvme_ns_get_md_size()
/// \param lba starting LBA to compare the data
/// \param lba_count length (in sectors) for the compare operation
/// \param cb_fn callback function to invoke when the I/O is completed
/// \param cb_arg argument to pass to the callback function
/// \param io_flags set flags, defined in nvme_spec.h, for this I/O
/// \param apptag_mask application tag mask.
/// \param apptag application tag to use end-to-end protection information.
///
/// \return 0 if successfully submitted, ENOMEM if an nvme_request
/// structure cannot be allocated for the I/O request
///
/// The command is submitted to a qpair allocated by spdk_nvme_ctrlr_alloc_io_qpair().
/// The user must ensure that only one thread submits I/O on a given qpair at any given time. 
 # [ link_name = "\u{1}_Z32spdk_nvme_ns_cmd_compare_with_md" ] pub fn spdk_nvme_ns_cmd_compare_with_md ( ns : * mut spdk_nvme_ns , qpair : * mut spdk_nvme_qpair , payload : * mut :: std :: os :: raw :: c_void , metadata : * mut :: std :: os :: raw :: c_void , lba : u64 , lba_count : u32 , cb_fn : spdk_nvme_cmd_cb , cb_arg : * mut :: std :: os :: raw :: c_void , io_flags : u32 , apptag_mask : u16 , apptag : u16 ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; } impl Default for __va_list_tag { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iface { pub _address : u8 , }