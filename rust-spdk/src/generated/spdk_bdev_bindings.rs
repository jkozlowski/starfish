/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
 # [ repr ( C ) ] # [ derive ( Default ) ] pub struct __IncompleteArrayField < T > ( :: std :: marker :: PhantomData < T > ) ; impl < T > __IncompleteArrayField < T > { # [ inline ] pub fn new ( ) -> Self { __IncompleteArrayField ( :: std :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ptr ( & self ) -> * const T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut_ptr ( & mut self ) -> * mut T { :: std :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_slice ( & self , len : usize ) -> & [ T ] { :: std :: slice :: from_raw_parts ( self . as_ptr ( ) , len ) } # [ inline ] pub unsafe fn as_mut_slice ( & mut self , len : usize ) -> & mut [ T ] { :: std :: slice :: from_raw_parts_mut ( self . as_mut_ptr ( ) , len ) } } impl < T > :: std :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt :: Result { fmt . write_str ( "__IncompleteArrayField" ) } } impl < T > :: std :: clone :: Clone for __IncompleteArrayField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: std :: marker :: Copy for __IncompleteArrayField < T > { } extern "C" { # [ link_name = "\u{1}_Z13__assert_fail" ] pub fn __assert_fail ( __assertion : * const :: std :: os :: raw :: c_char , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_uint , __function : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z20__assert_perror_fail" ] pub fn __assert_perror_fail ( __errnum : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_uint , __function : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z8__assert" ] pub fn __assert ( __assertion : * const :: std :: os :: raw :: c_char , __file : * const :: std :: os :: raw :: c_char , __line : :: std :: os :: raw :: c_int ) ; } pub type __u_char = :: std :: os :: raw :: c_uchar ; pub type __u_short = :: std :: os :: raw :: c_ushort ; pub type __u_int = :: std :: os :: raw :: c_uint ; pub type __u_long = :: std :: os :: raw :: c_ulong ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type __uint64_t = :: std :: os :: raw :: c_ulong ; pub type __quad_t = :: std :: os :: raw :: c_long ; pub type __u_quad_t = :: std :: os :: raw :: c_ulong ; pub type __dev_t = :: std :: os :: raw :: c_ulong ; pub type __uid_t = :: std :: os :: raw :: c_uint ; pub type __gid_t = :: std :: os :: raw :: c_uint ; pub type __ino_t = :: std :: os :: raw :: c_ulong ; pub type __ino64_t = :: std :: os :: raw :: c_ulong ; pub type __mode_t = :: std :: os :: raw :: c_uint ; pub type __nlink_t = :: std :: os :: raw :: c_ulong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = :: std :: os :: raw :: c_long ; pub type __pid_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __fsid_t { pub __val : [ :: std :: os :: raw :: c_int ; 2usize ] , } # [ test ] fn bindgen_test_layout___fsid_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __fsid_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __fsid_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __fsid_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __fsid_t ) ) ) ; } pub type __clock_t = :: std :: os :: raw :: c_long ; pub type __rlim_t = :: std :: os :: raw :: c_ulong ; pub type __rlim64_t = :: std :: os :: raw :: c_ulong ; pub type __id_t = :: std :: os :: raw :: c_uint ; pub type __time_t = :: std :: os :: raw :: c_long ; pub type __useconds_t = :: std :: os :: raw :: c_uint ; pub type __suseconds_t = :: std :: os :: raw :: c_long ; pub type __daddr_t = :: std :: os :: raw :: c_int ; pub type __key_t = :: std :: os :: raw :: c_int ; pub type __clockid_t = :: std :: os :: raw :: c_int ; pub type __timer_t = * mut :: std :: os :: raw :: c_void ; pub type __blksize_t = :: std :: os :: raw :: c_long ; pub type __blkcnt_t = :: std :: os :: raw :: c_long ; pub type __blkcnt64_t = :: std :: os :: raw :: c_long ; pub type __fsblkcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt_t = :: std :: os :: raw :: c_ulong ; pub type __fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; pub type __fsword_t = :: std :: os :: raw :: c_long ; pub type __ssize_t = :: std :: os :: raw :: c_long ; pub type __syscall_slong_t = :: std :: os :: raw :: c_long ; pub type __syscall_ulong_t = :: std :: os :: raw :: c_ulong ; pub type __loff_t = __off64_t ; pub type __qaddr_t = * mut __quad_t ; pub type __caddr_t = * mut :: std :: os :: raw :: c_char ; pub type __intptr_t = :: std :: os :: raw :: c_long ; pub type __socklen_t = :: std :: os :: raw :: c_uint ; pub const _ISupper : _bindgen_ty_1 = 256 ; pub const _ISlower : _bindgen_ty_1 = 512 ; pub const _ISalpha : _bindgen_ty_1 = 1024 ; pub const _ISdigit : _bindgen_ty_1 = 2048 ; pub const _ISxdigit : _bindgen_ty_1 = 4096 ; pub const _ISspace : _bindgen_ty_1 = 8192 ; pub const _ISprint : _bindgen_ty_1 = 16384 ; pub const _ISgraph : _bindgen_ty_1 = 32768 ; pub const _ISblank : _bindgen_ty_1 = 1 ; pub const _IScntrl : _bindgen_ty_1 = 2 ; pub const _ISpunct : _bindgen_ty_1 = 4 ; pub const _ISalnum : _bindgen_ty_1 = 8 ; pub type _bindgen_ty_1 = u32 ; extern "C" { # [ link_name = "\u{1}_Z13__ctype_b_loc" ] pub fn __ctype_b_loc ( ) -> * mut * const :: std :: os :: raw :: c_ushort ; } extern "C" { # [ link_name = "\u{1}_Z19__ctype_tolower_loc" ] pub fn __ctype_tolower_loc ( ) -> * mut * const __int32_t ; } extern "C" { # [ link_name = "\u{1}_Z19__ctype_toupper_loc" ] pub fn __ctype_toupper_loc ( ) -> * mut * const __int32_t ; } extern "C" { # [ link_name = "\u{1}_Z7isalnum" ] pub fn isalnum ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isalpha" ] pub fn isalpha ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7iscntrl" ] pub fn iscntrl ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isdigit" ] pub fn isdigit ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7islower" ] pub fn islower ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isgraph" ] pub fn isgraph ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isprint" ] pub fn isprint ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ispunct" ] pub fn ispunct ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isspace" ] pub fn isspace ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isupper" ] pub fn isupper ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8isxdigit" ] pub fn isxdigit ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tolower" ] pub fn tolower ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7toupper" ] pub fn toupper ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isblank" ] pub fn isblank ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7isascii" ] pub fn isascii ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7toascii" ] pub fn toascii ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_toupper" ] pub fn _toupper ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_tolower" ] pub fn _tolower ( arg1 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __locale_struct { pub __locales : [ * mut __locale_data ; 13usize ] , pub __ctype_b : * const :: std :: os :: raw :: c_ushort , pub __ctype_tolower : * const :: std :: os :: raw :: c_int , pub __ctype_toupper : * const :: std :: os :: raw :: c_int , pub __names : [ * const :: std :: os :: raw :: c_char ; 13usize ] , } # [ test ] fn bindgen_test_layout___locale_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __locale_struct > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( __locale_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __locale_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __locale_struct ) ) ) ; } impl Default for __locale_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __locale_t = * mut __locale_struct ; pub type locale_t = __locale_t ; extern "C" { # [ link_name = "\u{1}_Z9isalnum_l" ] pub fn isalnum_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isalpha_l" ] pub fn isalpha_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9iscntrl_l" ] pub fn iscntrl_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isdigit_l" ] pub fn isdigit_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9islower_l" ] pub fn islower_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isgraph_l" ] pub fn isgraph_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isprint_l" ] pub fn isprint_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9ispunct_l" ] pub fn ispunct_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isspace_l" ] pub fn isspace_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isupper_l" ] pub fn isupper_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10isxdigit_l" ] pub fn isxdigit_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9isblank_l" ] pub fn isblank_l ( arg1 : :: std :: os :: raw :: c_int , arg2 : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__tolower_l" ] pub fn __tolower_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tolower_l" ] pub fn tolower_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__toupper_l" ] pub fn __toupper_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9toupper_l" ] pub fn toupper_l ( __c : :: std :: os :: raw :: c_int , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16__errno_location" ] pub fn __errno_location ( ) -> * mut :: std :: os :: raw :: c_int ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_long ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_long ; pub type int_fast32_t = :: std :: os :: raw :: c_long ; pub type int_fast64_t = :: std :: os :: raw :: c_long ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast32_t = :: std :: os :: raw :: c_ulong ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulong ; pub type intmax_t = :: std :: os :: raw :: c_long ; pub type uintmax_t = :: std :: os :: raw :: c_ulong ; pub type __gwchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct imaxdiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_imaxdiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < imaxdiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( imaxdiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < imaxdiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( imaxdiv_t ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z7imaxabs" ] pub fn imaxabs ( __n : intmax_t ) -> intmax_t ; } extern "C" { # [ link_name = "\u{1}_Z7imaxdiv" ] pub fn imaxdiv ( __numer : intmax_t , __denom : intmax_t ) -> imaxdiv_t ; } extern "C" { # [ link_name = "\u{1}_Z9strtoimax" ] pub fn strtoimax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { # [ link_name = "\u{1}_Z9strtoumax" ] pub fn strtoumax ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } extern "C" { # [ link_name = "\u{1}_Z9wcstoimax" ] pub fn wcstoimax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> intmax_t ; } extern "C" { # [ link_name = "\u{1}_Z9wcstoumax" ] pub fn wcstoumax ( __nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: std :: os :: raw :: c_int ) -> uintmax_t ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; pub type wchar_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct max_align_t { pub __clang_max_align_nonce1 : :: std :: os :: raw :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : f64 , } # [ test ] fn bindgen_test_layout_max_align_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < max_align_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( max_align_t ) ) ) ; } pub type FILE = _IO_FILE ; pub type __FILE = _IO_FILE ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: std :: os :: raw :: c_uint , pub __wchb : [ :: std :: os :: raw :: c_char ; 4usize ] , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout___mbstate_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ) ) ; } impl Default for __mbstate_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; } impl Default for __mbstate_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos_t ) ) ) ; } impl Default for _G_fpos_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } # [ test ] fn bindgen_test_layout__G_fpos64_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _G_fpos64_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _G_fpos64_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _G_fpos64_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _G_fpos64_t ) ) ) ; } impl Default for _G_fpos64_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_jump_t { _unused : [ u8 ; 0 ] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_marker { pub _next : * mut _IO_marker , pub _sbuf : * mut _IO_FILE , pub _pos : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__IO_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_marker > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _IO_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_marker > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_marker ) ) ) ; } impl Default for _IO_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __codecvt_result___codecvt_ok : __codecvt_result = 0 ; pub const __codecvt_result___codecvt_partial : __codecvt_result = 1 ; pub const __codecvt_result___codecvt_error : __codecvt_result = 2 ; pub const __codecvt_result___codecvt_noconv : __codecvt_result = 3 ; pub type __codecvt_result = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [ :: std :: os :: raw :: c_char ; 1usize ] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub __pad1 : * mut :: std :: os :: raw :: c_void , pub __pad2 : * mut :: std :: os :: raw :: c_void , pub __pad3 : * mut :: std :: os :: raw :: c_void , pub __pad4 : * mut :: std :: os :: raw :: c_void , pub __pad5 : usize , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [ :: std :: os :: raw :: c_char ; 20usize ] , } # [ test ] fn bindgen_test_layout__IO_FILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _IO_FILE > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( _IO_FILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _IO_FILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _IO_FILE ) ) ) ; } impl Default for _IO_FILE { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _IO_FILE_plus { _unused : [ u8 ; 0 ] , } pub type __io_read_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize ) -> __ssize_t > ; pub type __io_write_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __buf : * const :: std :: os :: raw :: c_char , __n : usize ) -> __ssize_t > ; pub type __io_seek_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void , __pos : * mut __off64_t , __w : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; pub type __io_close_fn = :: std :: option :: Option < unsafe extern "C" fn ( __cookie : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { # [ link_name = "\u{1}_Z11__underflow" ] pub fn __underflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7__uflow" ] pub fn __uflow ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10__overflow" ] pub fn __overflow ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_getc" ] pub fn _IO_getc ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_putc" ] pub fn _IO_putc ( __c : :: std :: os :: raw :: c_int , __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_feof" ] pub fn _IO_feof ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10_IO_ferror" ] pub fn _IO_ferror ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16_IO_peekc_locked" ] pub fn _IO_peekc_locked ( __fp : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13_IO_flockfile" ] pub fn _IO_flockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z15_IO_funlockfile" ] pub fn _IO_funlockfile ( arg1 : * mut _IO_FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z16_IO_ftrylockfile" ] pub fn _IO_ftrylockfile ( arg1 : * mut _IO_FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11_IO_vfscanf" ] pub fn _IO_vfscanf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , arg4 : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12_IO_vfprintf" ] pub fn _IO_vfprintf ( arg1 : * mut _IO_FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8_IO_padn" ] pub fn _IO_padn ( arg1 : * mut _IO_FILE , arg2 : :: std :: os :: raw :: c_int , arg3 : __ssize_t ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z9_IO_sgetn" ] pub fn _IO_sgetn ( arg1 : * mut _IO_FILE , arg2 : * mut :: std :: os :: raw :: c_void , arg3 : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z11_IO_seekoff" ] pub fn _IO_seekoff ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int , arg4 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { # [ link_name = "\u{1}_Z11_IO_seekpos" ] pub fn _IO_seekpos ( arg1 : * mut _IO_FILE , arg2 : __off64_t , arg3 : :: std :: os :: raw :: c_int ) -> __off64_t ; } extern "C" { # [ link_name = "\u{1}_Z20_IO_free_backup_area" ] pub fn _IO_free_backup_area ( arg1 : * mut _IO_FILE ) ; } pub type off_t = __off_t ; pub type fpos_t = _G_fpos_t ; extern "C" { # [ link_name = "\u{1}_Z6remove" ] pub fn remove ( __filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6rename" ] pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8renameat" ] pub fn renameat ( __oldfd : :: std :: os :: raw :: c_int , __old : * const :: std :: os :: raw :: c_char , __newfd : :: std :: os :: raw :: c_int , __new : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tmpfile" ] pub fn tmpfile ( ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6tmpnam" ] pub fn tmpnam ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8tmpnam_r" ] pub fn tmpnam_r ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7tempnam" ] pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __pfx : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6fclose" ] pub fn fclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fflush" ] pub fn fflush ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15fflush_unlocked" ] pub fn fflush_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fopen" ] pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z7freopen" ] pub fn freopen ( __filename : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6fdopen" ] pub fn fdopen ( __fd : :: std :: os :: raw :: c_int , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z8fmemopen" ] pub fn fmemopen ( __s : * mut :: std :: os :: raw :: c_void , __len : usize , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z14open_memstream" ] pub fn open_memstream ( __bufloc : * mut * mut :: std :: os :: raw :: c_char , __sizeloc : * mut usize ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6setbuf" ] pub fn setbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z7setvbuf" ] pub fn setvbuf ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __modes : :: std :: os :: raw :: c_int , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9setbuffer" ] pub fn setbuffer ( __stream : * mut FILE , __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z10setlinebuf" ] pub fn setlinebuf ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z7fprintf" ] pub fn fprintf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6printf" ] pub fn printf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7sprintf" ] pub fn sprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8vfprintf" ] pub fn vfprintf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vprintf" ] pub fn vprintf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8vsprintf" ] pub fn vsprintf ( __s : * mut :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8snprintf" ] pub fn snprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9vsnprintf" ] pub fn vsnprintf ( __s : * mut :: std :: os :: raw :: c_char , __maxlen : usize , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8vdprintf" ] pub fn vdprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7dprintf" ] pub fn dprintf ( __fd : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fscanf" ] pub fn fscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5scanf" ] pub fn scanf ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6sscanf" ] pub fn sscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_fscanf" ] pub fn fscanf1 ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_scanf" ] pub fn scanf1 ( __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_sscanf" ] pub fn sscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vfscanf" ] pub fn vfscanf ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6vscanf" ] pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vsscanf" ] pub fn vsscanf ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vfscanf" ] pub fn vfscanf1 ( __s : * mut FILE , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vscanf" ] pub fn vscanf1 ( __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}__isoc99_vsscanf" ] pub fn vsscanf1 ( __s : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , __arg : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fgetc" ] pub fn fgetc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4getc" ] pub fn getc ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7getchar" ] pub fn getchar ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getc_unlocked" ] pub fn getc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16getchar_unlocked" ] pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14fgetc_unlocked" ] pub fn fgetc_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fputc" ] pub fn fputc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4putc" ] pub fn putc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7putchar" ] pub fn putchar ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14fputc_unlocked" ] pub fn fputc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13putc_unlocked" ] pub fn putc_unlocked ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16putchar_unlocked" ] pub fn putchar_unlocked ( __c : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4getw" ] pub fn getw ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4putw" ] pub fn putw ( __w : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fgets" ] pub fn fgets ( __s : * mut :: std :: os :: raw :: c_char , __n : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z10__getdelim" ] pub fn __getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z8getdelim" ] pub fn getdelim ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z7getline" ] pub fn getline ( __lineptr : * mut * mut :: std :: os :: raw :: c_char , __n : * mut usize , __stream : * mut FILE ) -> __ssize_t ; } extern "C" { # [ link_name = "\u{1}_Z5fputs" ] pub fn fputs ( __s : * const :: std :: os :: raw :: c_char , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4puts" ] pub fn puts ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6ungetc" ] pub fn ungetc ( __c : :: std :: os :: raw :: c_int , __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fread" ] pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6fwrite" ] pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __s : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z14fread_unlocked" ] pub fn fread_unlocked ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z15fwrite_unlocked" ] pub fn fwrite_unlocked ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __n : usize , __stream : * mut FILE ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z5fseek" ] pub fn fseek ( __stream : * mut FILE , __off : :: std :: os :: raw :: c_long , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5ftell" ] pub fn ftell ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z6rewind" ] pub fn rewind ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z6fseeko" ] pub fn fseeko ( __stream : * mut FILE , __off : __off_t , __whence : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6ftello" ] pub fn ftello ( __stream : * mut FILE ) -> __off_t ; } extern "C" { # [ link_name = "\u{1}_Z7fgetpos" ] pub fn fgetpos ( __stream : * mut FILE , __pos : * mut fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7fsetpos" ] pub fn fsetpos ( __stream : * mut FILE , __pos : * const fpos_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8clearerr" ] pub fn clearerr ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z4feof" ] pub fn feof ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6ferror" ] pub fn ferror ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17clearerr_unlocked" ] pub fn clearerr_unlocked ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z13feof_unlocked" ] pub fn feof_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15ferror_unlocked" ] pub fn ferror_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6perror" ] pub fn perror ( __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z6fileno" ] pub fn fileno ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15fileno_unlocked" ] pub fn fileno_unlocked ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5popen" ] pub fn popen ( __command : * const :: std :: os :: raw :: c_char , __modes : * const :: std :: os :: raw :: c_char ) -> * mut FILE ; } extern "C" { # [ link_name = "\u{1}_Z6pclose" ] pub fn pclose ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ctermid" ] pub fn ctermid ( __s : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9flockfile" ] pub fn flockfile ( __stream : * mut FILE ) ; } extern "C" { # [ link_name = "\u{1}_Z12ftrylockfile" ] pub fn ftrylockfile ( __stream : * mut FILE ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11funlockfile" ] pub fn funlockfile ( __stream : * mut FILE ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union wait { pub w_status : :: std :: os :: raw :: c_int , pub __wait_terminated : wait__bindgen_ty_1 , pub __wait_stopped : wait__bindgen_ty_2 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct wait__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; } impl wait__bindgen_ty_1 { # [ inline ] pub fn __w_termsig ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set___w_termsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn __w_coredump ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set___w_coredump ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn __w_retcode ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_retcode ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __w_termsig : :: std :: os :: raw :: c_uint , __w_coredump : :: std :: os :: raw :: c_uint , __w_retcode : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let __w_termsig : u32 = unsafe { :: std :: mem :: transmute ( __w_termsig ) } ; __w_termsig as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let __w_coredump : u32 = unsafe { :: std :: mem :: transmute ( __w_coredump ) } ; __w_coredump as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let __w_retcode : u32 = unsafe { :: std :: mem :: transmute ( __w_retcode ) } ; __w_retcode as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct wait__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; } impl wait__bindgen_ty_2 { # [ inline ] pub fn __w_stopval ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_stopval ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn __w_stopsig ( & self ) -> :: std :: os :: raw :: c_uint { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set___w_stopsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( __w_stopval : :: std :: os :: raw :: c_uint , __w_stopsig : :: std :: os :: raw :: c_uint ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let __w_stopval : u32 = unsafe { :: std :: mem :: transmute ( __w_stopval ) } ; __w_stopval as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let __w_stopsig : u32 = unsafe { :: std :: mem :: transmute ( __w_stopsig ) } ; __w_stopsig as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_wait ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait ) ) ) ; } impl Default for wait { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __WAIT_STATUS { pub __uptr : * mut wait , pub __iptr : * mut :: std :: os :: raw :: c_int , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout___WAIT_STATUS ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __WAIT_STATUS > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __WAIT_STATUS ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __WAIT_STATUS > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __WAIT_STATUS ) ) ) ; } impl Default for __WAIT_STATUS { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z22__ctype_get_mb_cur_max" ] pub fn __ctype_get_mb_cur_max ( ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z4atof" ] pub fn atof ( __nptr : * const :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z4atoi" ] pub fn atoi ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4atol" ] pub fn atol ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z5atoll" ] pub fn atoll ( __nptr : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z6strtod" ] pub fn strtod ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z6strtof" ] pub fn strtof ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f32 ; } extern "C" { # [ link_name = "\u{1}_Z7strtold" ] pub fn strtold ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z6strtol" ] pub fn strtol ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7strtoul" ] pub fn strtoul ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulong ; } extern "C" { # [ link_name = "\u{1}_Z6strtoq" ] pub fn strtoq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z7strtouq" ] pub fn strtouq ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { # [ link_name = "\u{1}_Z7strtoll" ] pub fn strtoll ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z8strtoull" ] pub fn strtoull ( __nptr : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_ulonglong ; } extern "C" { # [ link_name = "\u{1}_Z4l64a" ] pub fn l64a ( __n : :: std :: os :: raw :: c_long ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z4a64l" ] pub fn a64l ( __s : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_long ; } pub type u_char = __u_char ; pub type u_short = __u_short ; pub type u_int = __u_int ; pub type u_long = __u_long ; pub type quad_t = __quad_t ; pub type u_quad_t = __u_quad_t ; pub type fsid_t = __fsid_t ; pub type loff_t = __loff_t ; pub type ino_t = __ino_t ; pub type dev_t = __dev_t ; pub type gid_t = __gid_t ; pub type mode_t = __mode_t ; pub type nlink_t = __nlink_t ; pub type uid_t = __uid_t ; pub type pid_t = __pid_t ; pub type id_t = __id_t ; pub type daddr_t = __daddr_t ; pub type caddr_t = __caddr_t ; pub type key_t = __key_t ; pub type clock_t = __clock_t ; pub type time_t = __time_t ; pub type clockid_t = __clockid_t ; pub type timer_t = __timer_t ; pub type ulong = :: std :: os :: raw :: c_ulong ; pub type ushort = :: std :: os :: raw :: c_ushort ; pub type uint = :: std :: os :: raw :: c_uint ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulong ; pub type register_t = :: std :: os :: raw :: c_long ; pub type __sig_atomic_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __sigset_t { pub __val : [ :: std :: os :: raw :: c_ulong ; 16usize ] , } # [ test ] fn bindgen_test_layout___sigset_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigset_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __sigset_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigset_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigset_t ) ) ) ; } pub type sigset_t = __sigset_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timespec { pub tv_sec : __time_t , pub tv_nsec : __syscall_slong_t , } # [ test ] fn bindgen_test_layout_timespec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timespec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timespec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timespec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timespec ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct timeval { pub tv_sec : __time_t , pub tv_usec : __suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; } pub type suseconds_t = __suseconds_t ; pub type __fd_mask = :: std :: os :: raw :: c_long ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct fd_set { pub __fds_bits : [ __fd_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_fd_set ( ) { assert_eq ! ( :: std :: mem :: size_of :: < fd_set > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( fd_set ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < fd_set > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( fd_set ) ) ) ; } pub type fd_mask = __fd_mask ; extern "C" { # [ link_name = "\u{1}_Z6select" ] pub fn select ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * mut timeval ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7pselect" ] pub fn pselect ( __nfds : :: std :: os :: raw :: c_int , __readfds : * mut fd_set , __writefds : * mut fd_set , __exceptfds : * mut fd_set , __timeout : * const timespec , __sigmask : * const __sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13gnu_dev_major" ] pub fn gnu_dev_major ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z13gnu_dev_minor" ] pub fn gnu_dev_minor ( __dev : :: std :: os :: raw :: c_ulonglong ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z15gnu_dev_makedev" ] pub fn gnu_dev_makedev ( __major : :: std :: os :: raw :: c_uint , __minor : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_ulonglong ; } pub type blksize_t = __blksize_t ; pub type blkcnt_t = __blkcnt_t ; pub type fsblkcnt_t = __fsblkcnt_t ; pub type fsfilcnt_t = __fsfilcnt_t ; pub type pthread_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_attr_t { pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ test ] fn bindgen_test_layout_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_attr_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_attr_t ) ) ) ; } impl Default for pthread_attr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_internal_list { pub __prev : * mut __pthread_internal_list , pub __next : * mut __pthread_internal_list , } # [ test ] fn bindgen_test_layout___pthread_internal_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_internal_list > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __pthread_internal_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_internal_list > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_internal_list ) ) ) ; } impl Default for __pthread_internal_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type __pthread_list_t = __pthread_internal_list ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutex_t { pub __data : pthread_mutex_t___pthread_mutex_s , pub __size : [ :: std :: os :: raw :: c_char ; 40usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 5usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_mutex_t___pthread_mutex_s { pub __lock : :: std :: os :: raw :: c_int , pub __count : :: std :: os :: raw :: c_uint , pub __owner : :: std :: os :: raw :: c_int , pub __nusers : :: std :: os :: raw :: c_uint , pub __kind : :: std :: os :: raw :: c_int , pub __spins : :: std :: os :: raw :: c_short , pub __elision : :: std :: os :: raw :: c_short , pub __list : __pthread_list_t , } # [ test ] fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t___pthread_mutex_s > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ) ) ; } impl Default for pthread_mutex_t___pthread_mutex_s { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutex_t > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutex_t ) ) ) ; } impl Default for pthread_mutex_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_mutexattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_mutexattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ) ) ; } impl Default for pthread_mutexattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_cond_t { pub __data : pthread_cond_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 48usize ] , pub __align : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct pthread_cond_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __futex : :: std :: os :: raw :: c_uint , pub __total_seq : :: std :: os :: raw :: c_ulonglong , pub __wakeup_seq : :: std :: os :: raw :: c_ulonglong , pub __woken_seq : :: std :: os :: raw :: c_ulonglong , pub __mutex : * mut :: std :: os :: raw :: c_void , pub __nwaiters : :: std :: os :: raw :: c_uint , pub __broadcast_seq : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ) ) ; } impl Default for pthread_cond_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_cond_t ) ) ) ; } impl Default for pthread_cond_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_condattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_condattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ) ) ; } impl Default for pthread_condattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_key_t = :: std :: os :: raw :: c_uint ; pub type pthread_once_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlock_t { pub __data : pthread_rwlock_t__bindgen_ty_1 , pub __size : [ :: std :: os :: raw :: c_char ; 56usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 7usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct pthread_rwlock_t__bindgen_ty_1 { pub __lock : :: std :: os :: raw :: c_int , pub __nr_readers : :: std :: os :: raw :: c_uint , pub __readers_wakeup : :: std :: os :: raw :: c_uint , pub __writer_wakeup : :: std :: os :: raw :: c_uint , pub __nr_readers_queued : :: std :: os :: raw :: c_uint , pub __nr_writers_queued : :: std :: os :: raw :: c_uint , pub __writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __pad1 : :: std :: os :: raw :: c_ulong , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlock_t > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ) ) ; } impl Default for pthread_rwlock_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_rwlockattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 8usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ) ) ; } impl Default for pthread_rwlockattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type pthread_spinlock_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrier_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_pthread_barrier_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrier_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( pthread_barrier_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrier_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ) ) ; } impl Default for pthread_barrier_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union pthread_barrierattr_t { pub __size : [ :: std :: os :: raw :: c_char ; 4usize ] , pub __align : :: std :: os :: raw :: c_int , _bindgen_union_align : u32 , } # [ test ] fn bindgen_test_layout_pthread_barrierattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pthread_barrierattr_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ) ) ; } impl Default for pthread_barrierattr_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z6random" ] pub fn random ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7srandom" ] pub fn srandom ( __seed : :: std :: os :: raw :: c_uint ) ; } extern "C" { # [ link_name = "\u{1}_Z9initstate" ] pub fn initstate ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8setstate" ] pub fn setstate ( __statebuf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct random_data { pub fptr : * mut i32 , pub rptr : * mut i32 , pub state : * mut i32 , pub rand_type : :: std :: os :: raw :: c_int , pub rand_deg : :: std :: os :: raw :: c_int , pub rand_sep : :: std :: os :: raw :: c_int , pub end_ptr : * mut i32 , } # [ test ] fn bindgen_test_layout_random_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < random_data > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( random_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < random_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( random_data ) ) ) ; } impl Default for random_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z8random_r" ] pub fn random_r ( __buf : * mut random_data , __result : * mut i32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9srandom_r" ] pub fn srandom_r ( __seed : :: std :: os :: raw :: c_uint , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11initstate_r" ] pub fn initstate_r ( __seed : :: std :: os :: raw :: c_uint , __statebuf : * mut :: std :: os :: raw :: c_char , __statelen : usize , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10setstate_r" ] pub fn setstate_r ( __statebuf : * mut :: std :: os :: raw :: c_char , __buf : * mut random_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4rand" ] pub fn rand ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5srand" ] pub fn srand ( __seed : :: std :: os :: raw :: c_uint ) ; } extern "C" { # [ link_name = "\u{1}_Z6rand_r" ] pub fn rand_r ( __seed : * mut :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7drand48" ] pub fn drand48 ( ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z7erand48" ] pub fn erand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z7lrand48" ] pub fn lrand48 ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7nrand48" ] pub fn nrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7mrand48" ] pub fn mrand48 ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7jrand48" ] pub fn jrand48 ( __xsubi : * mut :: std :: os :: raw :: c_ushort ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7srand48" ] pub fn srand48 ( __seedval : :: std :: os :: raw :: c_long ) ; } extern "C" { # [ link_name = "\u{1}_Z6seed48" ] pub fn seed48 ( __seed16v : * mut :: std :: os :: raw :: c_ushort ) -> * mut :: std :: os :: raw :: c_ushort ; } extern "C" { # [ link_name = "\u{1}_Z7lcong48" ] pub fn lcong48 ( __param : * mut :: std :: os :: raw :: c_ushort ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct drand48_data { pub __x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __old_x : [ :: std :: os :: raw :: c_ushort ; 3usize ] , pub __c : :: std :: os :: raw :: c_ushort , pub __init : :: std :: os :: raw :: c_ushort , pub __a : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_drand48_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < drand48_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( drand48_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < drand48_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( drand48_data ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z9drand48_r" ] pub fn drand48_r ( __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9erand48_r" ] pub fn erand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut f64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9lrand48_r" ] pub fn lrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9nrand48_r" ] pub fn nrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9mrand48_r" ] pub fn mrand48_r ( __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9jrand48_r" ] pub fn jrand48_r ( __xsubi : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data , __result : * mut :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9srand48_r" ] pub fn srand48_r ( __seedval : :: std :: os :: raw :: c_long , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8seed48_r" ] pub fn seed48_r ( __seed16v : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9lcong48_r" ] pub fn lcong48_r ( __param : * mut :: std :: os :: raw :: c_ushort , __buffer : * mut drand48_data ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6malloc" ] pub fn malloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6calloc" ] pub fn calloc ( __nmemb : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7realloc" ] pub fn realloc ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z4free" ] pub fn free ( __ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}_Z5cfree" ] pub fn cfree ( __ptr : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}_Z6alloca" ] pub fn alloca ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6valloc" ] pub fn valloc ( __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z14posix_memalign" ] pub fn posix_memalign ( __memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13aligned_alloc" ] pub fn aligned_alloc ( __alignment : usize , __size : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z5abort" ] pub fn abort ( ) ; } extern "C" { # [ link_name = "\u{1}_Z6atexit" ] pub fn atexit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13at_quick_exit" ] pub fn at_quick_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7on_exit" ] pub fn on_exit ( __func : :: std :: option :: Option < unsafe extern "C" fn ( __status : :: std :: os :: raw :: c_int , __arg : * mut :: std :: os :: raw :: c_void ) > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4exit" ] pub fn exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10quick_exit" ] pub fn quick_exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z5_Exit" ] pub fn _Exit ( __status : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z6getenv" ] pub fn getenv ( __name : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6putenv" ] pub fn putenv ( __string : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setenv" ] pub fn setenv ( __name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __replace : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8unsetenv" ] pub fn unsetenv ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8clearenv" ] pub fn clearenv ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6mktemp" ] pub fn mktemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7mkstemp" ] pub fn mkstemp ( __template : * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mkstemps" ] pub fn mkstemps ( __template : * mut :: std :: os :: raw :: c_char , __suffixlen : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mkdtemp" ] pub fn mkdtemp ( __template : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6system" ] pub fn system ( __command : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8realpath" ] pub fn realpath ( __name : * const :: std :: os :: raw :: c_char , __resolved : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } pub type __compar_fn_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" { # [ link_name = "\u{1}_Z7bsearch" ] pub fn bsearch ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z5qsort" ] pub fn qsort ( __base : * mut :: std :: os :: raw :: c_void , __nmemb : usize , __size : usize , __compar : __compar_fn_t ) ; } extern "C" { # [ link_name = "\u{1}_Z3abs" ] pub fn abs ( __x : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4labs" ] pub fn labs ( __x : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z5llabs" ] pub fn llabs ( __x : :: std :: os :: raw :: c_longlong ) -> :: std :: os :: raw :: c_longlong ; } extern "C" { # [ link_name = "\u{1}_Z3div" ] pub fn div ( __numer : :: std :: os :: raw :: c_int , __denom : :: std :: os :: raw :: c_int ) -> div_t ; } extern "C" { # [ link_name = "\u{1}_Z4ldiv" ] pub fn ldiv ( __numer : :: std :: os :: raw :: c_long , __denom : :: std :: os :: raw :: c_long ) -> ldiv_t ; } extern "C" { # [ link_name = "\u{1}_Z5lldiv" ] pub fn lldiv ( __numer : :: std :: os :: raw :: c_longlong , __denom : :: std :: os :: raw :: c_longlong ) -> lldiv_t ; } extern "C" { # [ link_name = "\u{1}_Z4ecvt" ] pub fn ecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z4fcvt" ] pub fn fcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z4gcvt" ] pub fn gcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5qecvt" ] pub fn qecvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5qfcvt" ] pub fn qfcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5qgcvt" ] pub fn qgcvt ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6ecvt_r" ] pub fn ecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fcvt_r" ] pub fn fcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7qecvt_r" ] pub fn qecvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7qfcvt_r" ] pub fn qfcvt_r ( __value : f64 , __ndigit : :: std :: os :: raw :: c_int , __decpt : * mut :: std :: os :: raw :: c_int , __sign : * mut :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5mblen" ] pub fn mblen ( __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6mbtowc" ] pub fn mbtowc ( __pwc : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6wctomb" ] pub fn wctomb ( __s : * mut :: std :: os :: raw :: c_char , __wchar : wchar_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mbstowcs" ] pub fn mbstowcs ( __pwcs : * mut wchar_t , __s : * const :: std :: os :: raw :: c_char , __n : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z8wcstombs" ] pub fn wcstombs ( __s : * mut :: std :: os :: raw :: c_char , __pwcs : * const wchar_t , __n : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z7rpmatch" ] pub fn rpmatch ( __response : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9getsubopt" ] pub fn getsubopt ( __optionp : * mut * mut :: std :: os :: raw :: c_char , __tokens : * const * mut :: std :: os :: raw :: c_char , __valuep : * mut * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10getloadavg" ] pub fn getloadavg ( __loadavg : * mut f64 , __nelem : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6memcpy" ] pub fn memcpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7memmove" ] pub fn memmove ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7memccpy" ] pub fn memccpy ( __dest : * mut :: std :: os :: raw :: c_void , __src : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6memset" ] pub fn memset ( __s : * mut :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6memcmp" ] pub fn memcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6memchr" ] pub fn memchr ( __s : * const :: std :: os :: raw :: c_void , __c : :: std :: os :: raw :: c_int , __n : usize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6strcpy" ] pub fn strcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strncpy" ] pub fn strncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strcat" ] pub fn strcat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strncat" ] pub fn strncat ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strcmp" ] pub fn strcmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7strncmp" ] pub fn strncmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7strcoll" ] pub fn strcoll ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7strxfrm" ] pub fn strxfrm ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z9strcoll_l" ] pub fn strcoll_l ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __l : __locale_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9strxfrm_l" ] pub fn strxfrm_l ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize , __l : __locale_t ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6strdup" ] pub fn strdup ( __s : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strndup" ] pub fn strndup ( __string : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strchr" ] pub fn strchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strrchr" ] pub fn strrchr ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7strcspn" ] pub fn strcspn ( __s : * const :: std :: os :: raw :: c_char , __reject : * const :: std :: os :: raw :: c_char ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6strspn" ] pub fn strspn ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z7strpbrk" ] pub fn strpbrk ( __s : * const :: std :: os :: raw :: c_char , __accept : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strstr" ] pub fn strstr ( __haystack : * const :: std :: os :: raw :: c_char , __needle : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strtok" ] pub fn strtok ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z10__strtok_r" ] pub fn __strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8strtok_r" ] pub fn strtok_r ( __s : * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char , __save_ptr : * mut * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6strlen" ] pub fn strlen ( __s : * const :: std :: os :: raw :: c_char ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z7strnlen" ] pub fn strnlen ( __string : * const :: std :: os :: raw :: c_char , __maxlen : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z8strerror" ] pub fn strerror ( __errnum : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}__xpg_strerror_r" ] pub fn strerror_r ( __errnum : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10strerror_l" ] pub fn strerror_l ( __errnum : :: std :: os :: raw :: c_int , __l : __locale_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7__bzero" ] pub fn __bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z5bcopy" ] pub fn bcopy ( __src : * const :: std :: os :: raw :: c_void , __dest : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z5bzero" ] pub fn bzero ( __s : * mut :: std :: os :: raw :: c_void , __n : usize ) ; } extern "C" { # [ link_name = "\u{1}_Z4bcmp" ] pub fn bcmp ( __s1 : * const :: std :: os :: raw :: c_void , __s2 : * const :: std :: os :: raw :: c_void , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5index" ] pub fn index ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6rindex" ] pub fn rindex ( __s : * const :: std :: os :: raw :: c_char , __c : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z3ffs" ] pub fn ffs ( __i : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10strcasecmp" ] pub fn strcasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11strncasecmp" ] pub fn strncasecmp ( __s1 : * const :: std :: os :: raw :: c_char , __s2 : * const :: std :: os :: raw :: c_char , __n : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6strsep" ] pub fn strsep ( __stringp : * mut * mut :: std :: os :: raw :: c_char , __delim : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9strsignal" ] pub fn strsignal ( __sig : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z8__stpcpy" ] pub fn __stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z6stpcpy" ] pub fn stpcpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9__stpncpy" ] pub fn __stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7stpncpy" ] pub fn stpncpy ( __dest : * mut :: std :: os :: raw :: c_char , __src : * const :: std :: os :: raw :: c_char , __n : usize ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct tm { pub tm_sec : :: std :: os :: raw :: c_int , pub tm_min : :: std :: os :: raw :: c_int , pub tm_hour : :: std :: os :: raw :: c_int , pub tm_mday : :: std :: os :: raw :: c_int , pub tm_mon : :: std :: os :: raw :: c_int , pub tm_year : :: std :: os :: raw :: c_int , pub tm_wday : :: std :: os :: raw :: c_int , pub tm_yday : :: std :: os :: raw :: c_int , pub tm_isdst : :: std :: os :: raw :: c_int , pub tm_gmtoff : :: std :: os :: raw :: c_long , pub tm_zone : * const :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_tm ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tm > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( tm ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tm > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( tm ) ) ) ; } impl Default for tm { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct itimerspec { pub it_interval : timespec , pub it_value : timespec , } # [ test ] fn bindgen_test_layout_itimerspec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < itimerspec > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( itimerspec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < itimerspec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( itimerspec ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z5clock" ] pub fn clock ( ) -> clock_t ; } extern "C" { # [ link_name = "\u{1}_Z4time" ] pub fn time ( __timer : * mut time_t ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z8difftime" ] pub fn difftime ( __time1 : time_t , __time0 : time_t ) -> f64 ; } extern "C" { # [ link_name = "\u{1}_Z6mktime" ] pub fn mktime ( __tp : * mut tm ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z8strftime" ] pub fn strftime ( __s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z10strftime_l" ] pub fn strftime_l ( __s : * mut :: std :: os :: raw :: c_char , __maxsize : usize , __format : * const :: std :: os :: raw :: c_char , __tp : * const tm , __loc : __locale_t ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6gmtime" ] pub fn gmtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z9localtime" ] pub fn localtime ( __timer : * const time_t ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z8gmtime_r" ] pub fn gmtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z11localtime_r" ] pub fn localtime_r ( __timer : * const time_t , __tp : * mut tm ) -> * mut tm ; } extern "C" { # [ link_name = "\u{1}_Z7asctime" ] pub fn asctime ( __tp : * const tm ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5ctime" ] pub fn ctime ( __timer : * const time_t ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9asctime_r" ] pub fn asctime_r ( __tp : * const tm , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z7ctime_r" ] pub fn ctime_r ( __timer : * const time_t , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5tzset" ] pub fn tzset ( ) ; } extern "C" { # [ link_name = "\u{1}_Z5stime" ] pub fn stime ( __when : * const time_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6timegm" ] pub fn timegm ( __tp : * mut tm ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z9timelocal" ] pub fn timelocal ( __tp : * mut tm ) -> time_t ; } extern "C" { # [ link_name = "\u{1}_Z6dysize" ] pub fn dysize ( __year : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9nanosleep" ] pub fn nanosleep ( __requested_time : * const timespec , __remaining : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12clock_getres" ] pub fn clock_getres ( __clock_id : clockid_t , __res : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13clock_gettime" ] pub fn clock_gettime ( __clock_id : clockid_t , __tp : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13clock_settime" ] pub fn clock_settime ( __clock_id : clockid_t , __tp : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15clock_nanosleep" ] pub fn clock_nanosleep ( __clock_id : clockid_t , __flags : :: std :: os :: raw :: c_int , __req : * const timespec , __rem : * mut timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19clock_getcpuclockid" ] pub fn clock_getcpuclockid ( __pid : pid_t , __clock_id : * mut clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12timer_create" ] pub fn timer_create ( __clock_id : clockid_t , __evp : * mut sigevent , __timerid : * mut timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12timer_delete" ] pub fn timer_delete ( __timerid : timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13timer_settime" ] pub fn timer_settime ( __timerid : timer_t , __flags : :: std :: os :: raw :: c_int , __value : * const itimerspec , __ovalue : * mut itimerspec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13timer_gettime" ] pub fn timer_gettime ( __timerid : timer_t , __value : * mut itimerspec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16timer_getoverrun" ] pub fn timer_getoverrun ( __timerid : timer_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12timespec_get" ] pub fn timespec_get ( __ts : * mut timespec , __base : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct iovec { pub iov_base : * mut :: std :: os :: raw :: c_void , pub iov_len : usize , } # [ test ] fn bindgen_test_layout_iovec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < iovec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( iovec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < iovec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( iovec ) ) ) ; } impl Default for iovec { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z5readv" ] pub fn readv ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6writev" ] pub fn writev ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6preadv" ] pub fn preadv ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int , __offset : __off_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z7pwritev" ] pub fn pwritev ( __fd : :: std :: os :: raw :: c_int , __iovec : * const iovec , __count : :: std :: os :: raw :: c_int , __offset : __off_t ) -> isize ; } pub type socklen_t = __socklen_t ; pub const __socket_type_SOCK_STREAM : __socket_type = 1 ; pub const __socket_type_SOCK_DGRAM : __socket_type = 2 ; pub const __socket_type_SOCK_RAW : __socket_type = 3 ; pub const __socket_type_SOCK_RDM : __socket_type = 4 ; pub const __socket_type_SOCK_SEQPACKET : __socket_type = 5 ; pub const __socket_type_SOCK_DCCP : __socket_type = 6 ; pub const __socket_type_SOCK_PACKET : __socket_type = 10 ; pub const __socket_type_SOCK_CLOEXEC : __socket_type = 524288 ; pub const __socket_type_SOCK_NONBLOCK : __socket_type = 2048 ; pub type __socket_type = u32 ; pub type sa_family_t = :: std :: os :: raw :: c_ushort ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr { pub sa_family : sa_family_t , pub sa_data : [ :: std :: os :: raw :: c_char ; 14usize ] , } # [ test ] fn bindgen_test_layout_sockaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sockaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( sockaddr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_storage { pub ss_family : sa_family_t , pub __ss_padding : [ :: std :: os :: raw :: c_char ; 118usize ] , pub __ss_align : :: std :: os :: raw :: c_ulong , } # [ test ] fn bindgen_test_layout_sockaddr_storage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_storage > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( sockaddr_storage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_storage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_storage ) ) ) ; } impl Default for sockaddr_storage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const MSG_OOB : _bindgen_ty_2 = 1 ; pub const MSG_PEEK : _bindgen_ty_2 = 2 ; pub const MSG_DONTROUTE : _bindgen_ty_2 = 4 ; pub const MSG_CTRUNC : _bindgen_ty_2 = 8 ; pub const MSG_PROXY : _bindgen_ty_2 = 16 ; pub const MSG_TRUNC : _bindgen_ty_2 = 32 ; pub const MSG_DONTWAIT : _bindgen_ty_2 = 64 ; pub const MSG_EOR : _bindgen_ty_2 = 128 ; pub const MSG_WAITALL : _bindgen_ty_2 = 256 ; pub const MSG_FIN : _bindgen_ty_2 = 512 ; pub const MSG_SYN : _bindgen_ty_2 = 1024 ; pub const MSG_CONFIRM : _bindgen_ty_2 = 2048 ; pub const MSG_RST : _bindgen_ty_2 = 4096 ; pub const MSG_ERRQUEUE : _bindgen_ty_2 = 8192 ; pub const MSG_NOSIGNAL : _bindgen_ty_2 = 16384 ; pub const MSG_MORE : _bindgen_ty_2 = 32768 ; pub const MSG_WAITFORONE : _bindgen_ty_2 = 65536 ; pub const MSG_FASTOPEN : _bindgen_ty_2 = 536870912 ; pub const MSG_CMSG_CLOEXEC : _bindgen_ty_2 = 1073741824 ; pub type _bindgen_ty_2 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct msghdr { pub msg_name : * mut :: std :: os :: raw :: c_void , pub msg_namelen : socklen_t , pub msg_iov : * mut iovec , pub msg_iovlen : usize , pub msg_control : * mut :: std :: os :: raw :: c_void , pub msg_controllen : usize , pub msg_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_msghdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < msghdr > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( msghdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < msghdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( msghdr ) ) ) ; } impl Default for msghdr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct cmsghdr { pub cmsg_len : usize , pub cmsg_level : :: std :: os :: raw :: c_int , pub cmsg_type : :: std :: os :: raw :: c_int , pub __cmsg_data : __IncompleteArrayField < :: std :: os :: raw :: c_uchar > , } # [ test ] fn bindgen_test_layout_cmsghdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < cmsghdr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( cmsghdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < cmsghdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( cmsghdr ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z13__cmsg_nxthdr" ] pub fn __cmsg_nxthdr ( __mhdr : * mut msghdr , __cmsg : * mut cmsghdr ) -> * mut cmsghdr ; } pub const SCM_RIGHTS : _bindgen_ty_3 = 1 ; pub type _bindgen_ty_3 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct linger { pub l_onoff : :: std :: os :: raw :: c_int , pub l_linger : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_linger ( ) { assert_eq ! ( :: std :: mem :: size_of :: < linger > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( linger ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < linger > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( linger ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct osockaddr { pub sa_family : :: std :: os :: raw :: c_ushort , pub sa_data : [ :: std :: os :: raw :: c_uchar ; 14usize ] , } # [ test ] fn bindgen_test_layout_osockaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < osockaddr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( osockaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < osockaddr > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( osockaddr ) ) ) ; } pub const SHUT_RD : _bindgen_ty_4 = 0 ; pub const SHUT_WR : _bindgen_ty_4 = 1 ; pub const SHUT_RDWR : _bindgen_ty_4 = 2 ; pub type _bindgen_ty_4 = u32 ; extern "C" { # [ link_name = "\u{1}_Z6socket" ] pub fn socket ( __domain : :: std :: os :: raw :: c_int , __type : :: std :: os :: raw :: c_int , __protocol : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10socketpair" ] pub fn socketpair ( __domain : :: std :: os :: raw :: c_int , __type : :: std :: os :: raw :: c_int , __protocol : :: std :: os :: raw :: c_int , __fds : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4bind" ] pub fn bind ( __fd : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getsockname" ] pub fn getsockname ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7connect" ] pub fn connect ( __fd : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __len : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getpeername" ] pub fn getpeername ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4send" ] pub fn send ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z4recv" ] pub fn recv ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6sendto" ] pub fn sendto ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int , __addr : * const sockaddr , __addr_len : socklen_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z8recvfrom" ] pub fn recvfrom ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __n : usize , __flags : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z7sendmsg" ] pub fn sendmsg ( __fd : :: std :: os :: raw :: c_int , __message : * const msghdr , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z7recvmsg" ] pub fn recvmsg ( __fd : :: std :: os :: raw :: c_int , __message : * mut msghdr , __flags : :: std :: os :: raw :: c_int ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z10getsockopt" ] pub fn getsockopt ( __fd : :: std :: os :: raw :: c_int , __level : :: std :: os :: raw :: c_int , __optname : :: std :: os :: raw :: c_int , __optval : * mut :: std :: os :: raw :: c_void , __optlen : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10setsockopt" ] pub fn setsockopt ( __fd : :: std :: os :: raw :: c_int , __level : :: std :: os :: raw :: c_int , __optname : :: std :: os :: raw :: c_int , __optval : * const :: std :: os :: raw :: c_void , __optlen : socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6listen" ] pub fn listen ( __fd : :: std :: os :: raw :: c_int , __n : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6accept" ] pub fn accept ( __fd : :: std :: os :: raw :: c_int , __addr : * mut sockaddr , __addr_len : * mut socklen_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8shutdown" ] pub fn shutdown ( __fd : :: std :: os :: raw :: c_int , __how : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sockatmark" ] pub fn sockatmark ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8isfdtype" ] pub fn isfdtype ( __fd : :: std :: os :: raw :: c_int , __fdtype : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type in_addr_t = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_addr { pub s_addr : in_addr_t , } # [ test ] fn bindgen_test_layout_in_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in_addr > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( in_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in_addr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ip_opts { pub ip_dst : in_addr , pub ip_opts : [ :: std :: os :: raw :: c_char ; 40usize ] , } # [ test ] fn bindgen_test_layout_ip_opts ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_opts > ( ) , 44usize , concat ! ( "Size of: " , stringify ! ( ip_opts ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_opts > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_opts ) ) ) ; } impl Default for ip_opts { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreqn { pub imr_multiaddr : in_addr , pub imr_address : in_addr , pub imr_ifindex : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_ip_mreqn ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreqn > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ip_mreqn ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreqn > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreqn ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct in_pktinfo { pub ipi_ifindex : :: std :: os :: raw :: c_int , pub ipi_spec_dst : in_addr , pub ipi_addr : in_addr , } # [ test ] fn bindgen_test_layout_in_pktinfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in_pktinfo > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( in_pktinfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in_pktinfo > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in_pktinfo ) ) ) ; } pub const IPPROTO_IP : _bindgen_ty_5 = 0 ; pub const IPPROTO_ICMP : _bindgen_ty_5 = 1 ; pub const IPPROTO_IGMP : _bindgen_ty_5 = 2 ; pub const IPPROTO_IPIP : _bindgen_ty_5 = 4 ; pub const IPPROTO_TCP : _bindgen_ty_5 = 6 ; pub const IPPROTO_EGP : _bindgen_ty_5 = 8 ; pub const IPPROTO_PUP : _bindgen_ty_5 = 12 ; pub const IPPROTO_UDP : _bindgen_ty_5 = 17 ; pub const IPPROTO_IDP : _bindgen_ty_5 = 22 ; pub const IPPROTO_TP : _bindgen_ty_5 = 29 ; pub const IPPROTO_DCCP : _bindgen_ty_5 = 33 ; pub const IPPROTO_IPV6 : _bindgen_ty_5 = 41 ; pub const IPPROTO_RSVP : _bindgen_ty_5 = 46 ; pub const IPPROTO_GRE : _bindgen_ty_5 = 47 ; pub const IPPROTO_ESP : _bindgen_ty_5 = 50 ; pub const IPPROTO_AH : _bindgen_ty_5 = 51 ; pub const IPPROTO_MTP : _bindgen_ty_5 = 92 ; pub const IPPROTO_BEETPH : _bindgen_ty_5 = 94 ; pub const IPPROTO_ENCAP : _bindgen_ty_5 = 98 ; pub const IPPROTO_PIM : _bindgen_ty_5 = 103 ; pub const IPPROTO_COMP : _bindgen_ty_5 = 108 ; pub const IPPROTO_SCTP : _bindgen_ty_5 = 132 ; pub const IPPROTO_UDPLITE : _bindgen_ty_5 = 136 ; pub const IPPROTO_RAW : _bindgen_ty_5 = 255 ; pub const IPPROTO_MAX : _bindgen_ty_5 = 256 ; pub type _bindgen_ty_5 = u32 ; pub const IPPROTO_HOPOPTS : _bindgen_ty_6 = 0 ; pub const IPPROTO_ROUTING : _bindgen_ty_6 = 43 ; pub const IPPROTO_FRAGMENT : _bindgen_ty_6 = 44 ; pub const IPPROTO_ICMPV6 : _bindgen_ty_6 = 58 ; pub const IPPROTO_NONE : _bindgen_ty_6 = 59 ; pub const IPPROTO_DSTOPTS : _bindgen_ty_6 = 60 ; pub const IPPROTO_MH : _bindgen_ty_6 = 135 ; pub type _bindgen_ty_6 = u32 ; pub type in_port_t = u16 ; pub const IPPORT_ECHO : _bindgen_ty_7 = 7 ; pub const IPPORT_DISCARD : _bindgen_ty_7 = 9 ; pub const IPPORT_SYSTAT : _bindgen_ty_7 = 11 ; pub const IPPORT_DAYTIME : _bindgen_ty_7 = 13 ; pub const IPPORT_NETSTAT : _bindgen_ty_7 = 15 ; pub const IPPORT_FTP : _bindgen_ty_7 = 21 ; pub const IPPORT_TELNET : _bindgen_ty_7 = 23 ; pub const IPPORT_SMTP : _bindgen_ty_7 = 25 ; pub const IPPORT_TIMESERVER : _bindgen_ty_7 = 37 ; pub const IPPORT_NAMESERVER : _bindgen_ty_7 = 42 ; pub const IPPORT_WHOIS : _bindgen_ty_7 = 43 ; pub const IPPORT_MTP : _bindgen_ty_7 = 57 ; pub const IPPORT_TFTP : _bindgen_ty_7 = 69 ; pub const IPPORT_RJE : _bindgen_ty_7 = 77 ; pub const IPPORT_FINGER : _bindgen_ty_7 = 79 ; pub const IPPORT_TTYLINK : _bindgen_ty_7 = 87 ; pub const IPPORT_SUPDUP : _bindgen_ty_7 = 95 ; pub const IPPORT_EXECSERVER : _bindgen_ty_7 = 512 ; pub const IPPORT_LOGINSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_CMDSERVER : _bindgen_ty_7 = 514 ; pub const IPPORT_EFSSERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_BIFFUDP : _bindgen_ty_7 = 512 ; pub const IPPORT_WHOSERVER : _bindgen_ty_7 = 513 ; pub const IPPORT_ROUTESERVER : _bindgen_ty_7 = 520 ; pub const IPPORT_RESERVED : _bindgen_ty_7 = 1024 ; pub const IPPORT_USERRESERVED : _bindgen_ty_7 = 5000 ; pub type _bindgen_ty_7 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct in6_addr { pub __in6_u : in6_addr__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union in6_addr__bindgen_ty_1 { pub __u6_addr8 : [ u8 ; 16usize ] , pub __u6_addr16 : [ u16 ; 8usize ] , pub __u6_addr32 : [ u32 ; 4usize ] , _bindgen_union_align : [ u32 ; 4usize ] , } # [ test ] fn bindgen_test_layout_in6_addr__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in6_addr__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in6_addr__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ) ) ; } impl Default for in6_addr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_in6_addr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < in6_addr > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( in6_addr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < in6_addr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( in6_addr ) ) ) ; } impl Default for in6_addr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sockaddr_in { pub sin_family : sa_family_t , pub sin_port : in_port_t , pub sin_addr : in_addr , pub sin_zero : [ :: std :: os :: raw :: c_uchar ; 8usize ] , } # [ test ] fn bindgen_test_layout_sockaddr_in ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_in > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sockaddr_in ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_in > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_in ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_in6 { pub sin6_family : sa_family_t , pub sin6_port : in_port_t , pub sin6_flowinfo : u32 , pub sin6_addr : in6_addr , pub sin6_scope_id : u32 , } # [ test ] fn bindgen_test_layout_sockaddr_in6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_in6 > ( ) , 28usize , concat ! ( "Size of: " , stringify ! ( sockaddr_in6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_in6 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_in6 ) ) ) ; } impl Default for sockaddr_in6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , } # [ test ] fn bindgen_test_layout_ip_mreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreq > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ip_mreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreq > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreq ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_mreq_source { pub imr_multiaddr : in_addr , pub imr_interface : in_addr , pub imr_sourceaddr : in_addr , } # [ test ] fn bindgen_test_layout_ip_mreq_source ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_mreq_source > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( ip_mreq_source ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_mreq_source > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_mreq_source ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ipv6_mreq { pub ipv6mr_multiaddr : in6_addr , pub ipv6mr_interface : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_ipv6_mreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ipv6_mreq > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ipv6_mreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ipv6_mreq > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ipv6_mreq ) ) ) ; } impl Default for ipv6_mreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_req { pub gr_interface : u32 , pub gr_group : sockaddr_storage , } # [ test ] fn bindgen_test_layout_group_req ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_req > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( group_req ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_req > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_req ) ) ) ; } impl Default for group_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_source_req { pub gsr_interface : u32 , pub gsr_group : sockaddr_storage , pub gsr_source : sockaddr_storage , } # [ test ] fn bindgen_test_layout_group_source_req ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_source_req > ( ) , 264usize , concat ! ( "Size of: " , stringify ! ( group_source_req ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_source_req > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_source_req ) ) ) ; } impl Default for group_source_req { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ip_msfilter { pub imsf_multiaddr : in_addr , pub imsf_interface : in_addr , pub imsf_fmode : u32 , pub imsf_numsrc : u32 , pub imsf_slist : [ in_addr ; 1usize ] , } # [ test ] fn bindgen_test_layout_ip_msfilter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ip_msfilter > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( ip_msfilter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ip_msfilter > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( ip_msfilter ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct group_filter { pub gf_interface : u32 , pub gf_group : sockaddr_storage , pub gf_fmode : u32 , pub gf_numsrc : u32 , pub gf_slist : [ sockaddr_storage ; 1usize ] , } # [ test ] fn bindgen_test_layout_group_filter ( ) { assert_eq ! ( :: std :: mem :: size_of :: < group_filter > ( ) , 272usize , concat ! ( "Size of: " , stringify ! ( group_filter ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < group_filter > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( group_filter ) ) ) ; } impl Default for group_filter { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z5ntohl" ] pub fn ntohl ( __netlong : u32 ) -> u32 ; } extern "C" { # [ link_name = "\u{1}_Z5ntohs" ] pub fn ntohs ( __netshort : u16 ) -> u16 ; } extern "C" { # [ link_name = "\u{1}_Z5htonl" ] pub fn htonl ( __hostlong : u32 ) -> u32 ; } extern "C" { # [ link_name = "\u{1}_Z5htons" ] pub fn htons ( __hostshort : u16 ) -> u16 ; } extern "C" { # [ link_name = "\u{1}_Z12bindresvport" ] pub fn bindresvport ( __sockfd : :: std :: os :: raw :: c_int , __sock_in : * mut sockaddr_in ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13bindresvport6" ] pub fn bindresvport6 ( __sockfd : :: std :: os :: raw :: c_int , __sock_in : * mut sockaddr_in6 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9inet_addr" ] pub fn inet_addr ( __cp : * const :: std :: os :: raw :: c_char ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z10inet_lnaof" ] pub fn inet_lnaof ( __in : in_addr ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z13inet_makeaddr" ] pub fn inet_makeaddr ( __net : in_addr_t , __host : in_addr_t ) -> in_addr ; } extern "C" { # [ link_name = "\u{1}_Z10inet_netof" ] pub fn inet_netof ( __in : in_addr ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z12inet_network" ] pub fn inet_network ( __cp : * const :: std :: os :: raw :: c_char ) -> in_addr_t ; } extern "C" { # [ link_name = "\u{1}_Z9inet_ntoa" ] pub fn inet_ntoa ( __in : in_addr ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9inet_pton" ] pub fn inet_pton ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9inet_ntop" ] pub fn inet_ntop ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_void , __buf : * mut :: std :: os :: raw :: c_char , __len : socklen_t ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9inet_aton" ] pub fn inet_aton ( __cp : * const :: std :: os :: raw :: c_char , __inp : * mut in_addr ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9inet_neta" ] pub fn inet_neta ( __net : in_addr_t , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z13inet_net_ntop" ] pub fn inet_net_ntop ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_void , __bits : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z13inet_net_pton" ] pub fn inet_net_pton ( __af : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14inet_nsap_addr" ] pub fn inet_nsap_addr ( __cp : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_uchar , __len : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z14inet_nsap_ntoa" ] pub fn inet_nsap_ntoa ( __len : :: std :: os :: raw :: c_int , __cp : * const :: std :: os :: raw :: c_uchar , __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct dirent { pub d_ino : __ino_t , pub d_off : __off_t , pub d_reclen : :: std :: os :: raw :: c_ushort , pub d_type : :: std :: os :: raw :: c_uchar , pub d_name : [ :: std :: os :: raw :: c_char ; 256usize ] , } # [ test ] fn bindgen_test_layout_dirent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < dirent > ( ) , 280usize , concat ! ( "Size of: " , stringify ! ( dirent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < dirent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( dirent ) ) ) ; } impl Default for dirent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const DT_UNKNOWN : _bindgen_ty_8 = 0 ; pub const DT_FIFO : _bindgen_ty_8 = 1 ; pub const DT_CHR : _bindgen_ty_8 = 2 ; pub const DT_DIR : _bindgen_ty_8 = 4 ; pub const DT_BLK : _bindgen_ty_8 = 6 ; pub const DT_REG : _bindgen_ty_8 = 8 ; pub const DT_LNK : _bindgen_ty_8 = 10 ; pub const DT_SOCK : _bindgen_ty_8 = 12 ; pub const DT_WHT : _bindgen_ty_8 = 14 ; pub type _bindgen_ty_8 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __dirstream { _unused : [ u8 ; 0 ] , } pub type DIR = __dirstream ; extern "C" { # [ link_name = "\u{1}_Z7opendir" ] pub fn opendir ( __name : * const :: std :: os :: raw :: c_char ) -> * mut DIR ; } extern "C" { # [ link_name = "\u{1}_Z9fdopendir" ] pub fn fdopendir ( __fd : :: std :: os :: raw :: c_int ) -> * mut DIR ; } extern "C" { # [ link_name = "\u{1}_Z8closedir" ] pub fn closedir ( __dirp : * mut DIR ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7readdir" ] pub fn readdir ( __dirp : * mut DIR ) -> * mut dirent ; } extern "C" { # [ link_name = "\u{1}_Z9readdir_r" ] pub fn readdir_r ( __dirp : * mut DIR , __entry : * mut dirent , __result : * mut * mut dirent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9rewinddir" ] pub fn rewinddir ( __dirp : * mut DIR ) ; } extern "C" { # [ link_name = "\u{1}_Z7seekdir" ] pub fn seekdir ( __dirp : * mut DIR , __pos : :: std :: os :: raw :: c_long ) ; } extern "C" { # [ link_name = "\u{1}_Z7telldir" ] pub fn telldir ( __dirp : * mut DIR ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z5dirfd" ] pub fn dirfd ( __dirp : * mut DIR ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7scandir" ] pub fn scandir ( __dir : * const :: std :: os :: raw :: c_char , __namelist : * mut * mut * mut dirent , __selector : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const dirent ) -> :: std :: os :: raw :: c_int > , __cmp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut * const dirent , arg2 : * mut * const dirent ) -> :: std :: os :: raw :: c_int > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9alphasort" ] pub fn alphasort ( __e1 : * mut * const dirent , __e2 : * mut * const dirent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getdirentries" ] pub fn getdirentries ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __nbytes : usize , __basep : * mut __off_t ) -> __ssize_t ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct flock { pub l_type : :: std :: os :: raw :: c_short , pub l_whence : :: std :: os :: raw :: c_short , pub l_start : __off_t , pub l_len : __off_t , pub l_pid : __pid_t , } # [ test ] fn bindgen_test_layout_flock ( ) { assert_eq ! ( :: std :: mem :: size_of :: < flock > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( flock ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < flock > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( flock ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct stat { pub st_dev : __dev_t , pub st_ino : __ino_t , pub st_nlink : __nlink_t , pub st_mode : __mode_t , pub st_uid : __uid_t , pub st_gid : __gid_t , pub __pad0 : :: std :: os :: raw :: c_int , pub st_rdev : __dev_t , pub st_size : __off_t , pub st_blksize : __blksize_t , pub st_blocks : __blkcnt_t , pub st_atim : timespec , pub st_mtim : timespec , pub st_ctim : timespec , pub __unused : [ __syscall_slong_t ; 3usize ] , } # [ test ] fn bindgen_test_layout_stat ( ) { assert_eq ! ( :: std :: mem :: size_of :: < stat > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( stat ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < stat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( stat ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z5fcntl" ] pub fn fcntl ( __fd : :: std :: os :: raw :: c_int , __cmd : :: std :: os :: raw :: c_int , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4open" ] pub fn open ( __file : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6openat" ] pub fn openat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5creat" ] pub fn creat ( __file : * const :: std :: os :: raw :: c_char , __mode : mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5lockf" ] pub fn lockf ( __fd : :: std :: os :: raw :: c_int , __cmd : :: std :: os :: raw :: c_int , __len : off_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13posix_fadvise" ] pub fn posix_fadvise ( __fd : :: std :: os :: raw :: c_int , __offset : off_t , __len : off_t , __advise : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15posix_fallocate" ] pub fn posix_fallocate ( __fd : :: std :: os :: raw :: c_int , __offset : off_t , __len : off_t ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddrs { pub ifa_next : * mut ifaddrs , pub ifa_name : * mut :: std :: os :: raw :: c_char , pub ifa_flags : :: std :: os :: raw :: c_uint , pub ifa_addr : * mut sockaddr , pub ifa_netmask : * mut sockaddr , pub ifa_ifu : ifaddrs__bindgen_ty_1 , pub ifa_data : * mut :: std :: os :: raw :: c_void , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddrs__bindgen_ty_1 { pub ifu_broadaddr : * mut sockaddr , pub ifu_dstaddr : * mut sockaddr , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_ifaddrs__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddrs__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ifaddrs__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddrs__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifaddrs__bindgen_ty_1 ) ) ) ; } impl Default for ifaddrs__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifaddrs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddrs > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( ifaddrs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddrs > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifaddrs ) ) ) ; } impl Default for ifaddrs { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z10getifaddrs" ] pub fn getifaddrs ( __ifap : * mut * mut ifaddrs ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11freeifaddrs" ] pub fn freeifaddrs ( __ifa : * mut ifaddrs ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rpcent { pub r_name : * mut :: std :: os :: raw :: c_char , pub r_aliases : * mut * mut :: std :: os :: raw :: c_char , pub r_number : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_rpcent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rpcent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( rpcent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rpcent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rpcent ) ) ) ; } impl Default for rpcent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z9setrpcent" ] pub fn setrpcent ( __stayopen : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z9endrpcent" ] pub fn endrpcent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z12getrpcbyname" ] pub fn getrpcbyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut rpcent ; } extern "C" { # [ link_name = "\u{1}_Z14getrpcbynumber" ] pub fn getrpcbynumber ( __number : :: std :: os :: raw :: c_int ) -> * mut rpcent ; } extern "C" { # [ link_name = "\u{1}_Z9getrpcent" ] pub fn getrpcent ( ) -> * mut rpcent ; } extern "C" { # [ link_name = "\u{1}_Z14getrpcbyname_r" ] pub fn getrpcbyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut rpcent , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16getrpcbynumber_r" ] pub fn getrpcbynumber_r ( __number : :: std :: os :: raw :: c_int , __result_buf : * mut rpcent , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getrpcent_r" ] pub fn getrpcent_r ( __result_buf : * mut rpcent , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut rpcent ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct netent { pub n_name : * mut :: std :: os :: raw :: c_char , pub n_aliases : * mut * mut :: std :: os :: raw :: c_char , pub n_addrtype : :: std :: os :: raw :: c_int , pub n_net : u32 , } # [ test ] fn bindgen_test_layout_netent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < netent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( netent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < netent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( netent ) ) ) ; } impl Default for netent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z18__h_errno_location" ] pub fn __h_errno_location ( ) -> * mut :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6herror" ] pub fn herror ( __str : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z9hstrerror" ] pub fn hstrerror ( __err_num : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct hostent { pub h_name : * mut :: std :: os :: raw :: c_char , pub h_aliases : * mut * mut :: std :: os :: raw :: c_char , pub h_addrtype : :: std :: os :: raw :: c_int , pub h_length : :: std :: os :: raw :: c_int , pub h_addr_list : * mut * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_hostent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < hostent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( hostent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < hostent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( hostent ) ) ) ; } impl Default for hostent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z10sethostent" ] pub fn sethostent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10endhostent" ] pub fn endhostent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z10gethostent" ] pub fn gethostent ( ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z13gethostbyaddr" ] pub fn gethostbyaddr ( __addr : * const :: std :: os :: raw :: c_void , __len : __socklen_t , __type : :: std :: os :: raw :: c_int ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z13gethostbyname" ] pub fn gethostbyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z14gethostbyname2" ] pub fn gethostbyname2 ( __name : * const :: std :: os :: raw :: c_char , __af : :: std :: os :: raw :: c_int ) -> * mut hostent ; } extern "C" { # [ link_name = "\u{1}_Z12gethostent_r" ] pub fn gethostent_r ( __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15gethostbyaddr_r" ] pub fn gethostbyaddr_r ( __addr : * const :: std :: os :: raw :: c_void , __len : __socklen_t , __type : :: std :: os :: raw :: c_int , __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15gethostbyname_r" ] pub fn gethostbyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16gethostbyname2_r" ] pub fn gethostbyname2_r ( __name : * const :: std :: os :: raw :: c_char , __af : :: std :: os :: raw :: c_int , __result_buf : * mut hostent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut hostent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9setnetent" ] pub fn setnetent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z9endnetent" ] pub fn endnetent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z9getnetent" ] pub fn getnetent ( ) -> * mut netent ; } extern "C" { # [ link_name = "\u{1}_Z12getnetbyaddr" ] pub fn getnetbyaddr ( __net : u32 , __type : :: std :: os :: raw :: c_int ) -> * mut netent ; } extern "C" { # [ link_name = "\u{1}_Z12getnetbyname" ] pub fn getnetbyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut netent ; } extern "C" { # [ link_name = "\u{1}_Z11getnetent_r" ] pub fn getnetent_r ( __result_buf : * mut netent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14getnetbyaddr_r" ] pub fn getnetbyaddr_r ( __net : u32 , __type : :: std :: os :: raw :: c_int , __result_buf : * mut netent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14getnetbyname_r" ] pub fn getnetbyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut netent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut netent , __h_errnop : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct servent { pub s_name : * mut :: std :: os :: raw :: c_char , pub s_aliases : * mut * mut :: std :: os :: raw :: c_char , pub s_port : :: std :: os :: raw :: c_int , pub s_proto : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_servent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < servent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( servent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < servent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( servent ) ) ) ; } impl Default for servent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z10setservent" ] pub fn setservent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10endservent" ] pub fn endservent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z10getservent" ] pub fn getservent ( ) -> * mut servent ; } extern "C" { # [ link_name = "\u{1}_Z13getservbyname" ] pub fn getservbyname ( __name : * const :: std :: os :: raw :: c_char , __proto : * const :: std :: os :: raw :: c_char ) -> * mut servent ; } extern "C" { # [ link_name = "\u{1}_Z13getservbyport" ] pub fn getservbyport ( __port : :: std :: os :: raw :: c_int , __proto : * const :: std :: os :: raw :: c_char ) -> * mut servent ; } extern "C" { # [ link_name = "\u{1}_Z12getservent_r" ] pub fn getservent_r ( __result_buf : * mut servent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut servent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15getservbyname_r" ] pub fn getservbyname_r ( __name : * const :: std :: os :: raw :: c_char , __proto : * const :: std :: os :: raw :: c_char , __result_buf : * mut servent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut servent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15getservbyport_r" ] pub fn getservbyport_r ( __port : :: std :: os :: raw :: c_int , __proto : * const :: std :: os :: raw :: c_char , __result_buf : * mut servent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut servent ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct protoent { pub p_name : * mut :: std :: os :: raw :: c_char , pub p_aliases : * mut * mut :: std :: os :: raw :: c_char , pub p_proto : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_protoent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < protoent > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( protoent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < protoent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( protoent ) ) ) ; } impl Default for protoent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z11setprotoent" ] pub fn setprotoent ( __stay_open : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z11endprotoent" ] pub fn endprotoent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z11getprotoent" ] pub fn getprotoent ( ) -> * mut protoent ; } extern "C" { # [ link_name = "\u{1}_Z14getprotobyname" ] pub fn getprotobyname ( __name : * const :: std :: os :: raw :: c_char ) -> * mut protoent ; } extern "C" { # [ link_name = "\u{1}_Z16getprotobynumber" ] pub fn getprotobynumber ( __proto : :: std :: os :: raw :: c_int ) -> * mut protoent ; } extern "C" { # [ link_name = "\u{1}_Z13getprotoent_r" ] pub fn getprotoent_r ( __result_buf : * mut protoent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16getprotobyname_r" ] pub fn getprotobyname_r ( __name : * const :: std :: os :: raw :: c_char , __result_buf : * mut protoent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18getprotobynumber_r" ] pub fn getprotobynumber_r ( __proto : :: std :: os :: raw :: c_int , __result_buf : * mut protoent , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize , __result : * mut * mut protoent ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11setnetgrent" ] pub fn setnetgrent ( __netgroup : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11endnetgrent" ] pub fn endnetgrent ( ) ; } extern "C" { # [ link_name = "\u{1}_Z11getnetgrent" ] pub fn getnetgrent ( __hostp : * mut * mut :: std :: os :: raw :: c_char , __userp : * mut * mut :: std :: os :: raw :: c_char , __domainp : * mut * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7innetgr" ] pub fn innetgr ( __netgroup : * const :: std :: os :: raw :: c_char , __host : * const :: std :: os :: raw :: c_char , __user : * const :: std :: os :: raw :: c_char , __domain : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getnetgrent_r" ] pub fn getnetgrent_r ( __hostp : * mut * mut :: std :: os :: raw :: c_char , __userp : * mut * mut :: std :: os :: raw :: c_char , __domainp : * mut * mut :: std :: os :: raw :: c_char , __buffer : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4rcmd" ] pub fn rcmd ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_ushort , __locuser : * const :: std :: os :: raw :: c_char , __remuser : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7rcmd_af" ] pub fn rcmd_af ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_ushort , __locuser : * const :: std :: os :: raw :: c_char , __remuser : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5rexec" ] pub fn rexec ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __pass : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8rexec_af" ] pub fn rexec_af ( __ahost : * mut * mut :: std :: os :: raw :: c_char , __rport : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __pass : * const :: std :: os :: raw :: c_char , __cmd : * const :: std :: os :: raw :: c_char , __fd2p : * mut :: std :: os :: raw :: c_int , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ruserok" ] pub fn ruserok ( __rhost : * const :: std :: os :: raw :: c_char , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10ruserok_af" ] pub fn ruserok_af ( __rhost : * const :: std :: os :: raw :: c_char , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8iruserok" ] pub fn iruserok ( __raddr : u32 , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11iruserok_af" ] pub fn iruserok_af ( __raddr : * const :: std :: os :: raw :: c_void , __suser : :: std :: os :: raw :: c_int , __remuser : * const :: std :: os :: raw :: c_char , __locuser : * const :: std :: os :: raw :: c_char , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9rresvport" ] pub fn rresvport ( __alport : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12rresvport_af" ] pub fn rresvport_af ( __alport : * mut :: std :: os :: raw :: c_int , __af : sa_family_t ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct addrinfo { pub ai_flags : :: std :: os :: raw :: c_int , pub ai_family : :: std :: os :: raw :: c_int , pub ai_socktype : :: std :: os :: raw :: c_int , pub ai_protocol : :: std :: os :: raw :: c_int , pub ai_addrlen : socklen_t , pub ai_addr : * mut sockaddr , pub ai_canonname : * mut :: std :: os :: raw :: c_char , pub ai_next : * mut addrinfo , } # [ test ] fn bindgen_test_layout_addrinfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < addrinfo > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( addrinfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < addrinfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( addrinfo ) ) ) ; } impl Default for addrinfo { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z11getaddrinfo" ] pub fn getaddrinfo ( __name : * const :: std :: os :: raw :: c_char , __service : * const :: std :: os :: raw :: c_char , __req : * const addrinfo , __pai : * mut * mut addrinfo ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12freeaddrinfo" ] pub fn freeaddrinfo ( __ai : * mut addrinfo ) ; } extern "C" { # [ link_name = "\u{1}_Z12gai_strerror" ] pub fn gai_strerror ( __ecode : :: std :: os :: raw :: c_int ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z11getnameinfo" ] pub fn getnameinfo ( __sa : * const sockaddr , __salen : socklen_t , __host : * mut :: std :: os :: raw :: c_char , __hostlen : socklen_t , __serv : * mut :: std :: os :: raw :: c_char , __servlen : socklen_t , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type nfds_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct pollfd { pub fd : :: std :: os :: raw :: c_int , pub events : :: std :: os :: raw :: c_short , pub revents : :: std :: os :: raw :: c_short , } # [ test ] fn bindgen_test_layout_pollfd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < pollfd > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( pollfd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < pollfd > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( pollfd ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z4poll" ] pub fn poll ( __fds : * mut pollfd , __nfds : nfds_t , __timeout : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct sched_param { pub __sched_priority : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sched_param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sched_param > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( sched_param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sched_param > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( sched_param ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __sched_param { pub __sched_priority : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___sched_param ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sched_param > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( __sched_param ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sched_param > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __sched_param ) ) ) ; } pub type __cpu_mask = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct cpu_set_t { pub __bits : [ __cpu_mask ; 16usize ] , } # [ test ] fn bindgen_test_layout_cpu_set_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < cpu_set_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( cpu_set_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < cpu_set_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( cpu_set_t ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z16__sched_cpucount" ] pub fn __sched_cpucount ( __setsize : usize , __setp : * const cpu_set_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z16__sched_cpualloc" ] pub fn __sched_cpualloc ( __count : usize ) -> * mut cpu_set_t ; } extern "C" { # [ link_name = "\u{1}_Z15__sched_cpufree" ] pub fn __sched_cpufree ( __set : * mut cpu_set_t ) ; } extern "C" { # [ link_name = "\u{1}_Z14sched_setparam" ] pub fn sched_setparam ( __pid : __pid_t , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14sched_getparam" ] pub fn sched_getparam ( __pid : __pid_t , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18sched_setscheduler" ] pub fn sched_setscheduler ( __pid : __pid_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18sched_getscheduler" ] pub fn sched_getscheduler ( __pid : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sched_yield" ] pub fn sched_yield ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22sched_get_priority_max" ] pub fn sched_get_priority_max ( __algorithm : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22sched_get_priority_min" ] pub fn sched_get_priority_min ( __algorithm : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21sched_rr_get_interval" ] pub fn sched_rr_get_interval ( __pid : __pid_t , __t : * mut timespec ) -> :: std :: os :: raw :: c_int ; } pub type __jmp_buf = [ :: std :: os :: raw :: c_long ; 8usize ] ; pub const PTHREAD_CREATE_JOINABLE : _bindgen_ty_9 = 0 ; pub const PTHREAD_CREATE_DETACHED : _bindgen_ty_9 = 1 ; pub type _bindgen_ty_9 = u32 ; pub const PTHREAD_MUTEX_TIMED_NP : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE_NP : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK_NP : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_ADAPTIVE_NP : _bindgen_ty_10 = 3 ; pub const PTHREAD_MUTEX_NORMAL : _bindgen_ty_10 = 0 ; pub const PTHREAD_MUTEX_RECURSIVE : _bindgen_ty_10 = 1 ; pub const PTHREAD_MUTEX_ERRORCHECK : _bindgen_ty_10 = 2 ; pub const PTHREAD_MUTEX_DEFAULT : _bindgen_ty_10 = 0 ; pub type _bindgen_ty_10 = u32 ; pub const PTHREAD_MUTEX_STALLED : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_STALLED_NP : _bindgen_ty_11 = 0 ; pub const PTHREAD_MUTEX_ROBUST : _bindgen_ty_11 = 1 ; pub const PTHREAD_MUTEX_ROBUST_NP : _bindgen_ty_11 = 1 ; pub type _bindgen_ty_11 = u32 ; pub const PTHREAD_PRIO_NONE : _bindgen_ty_12 = 0 ; pub const PTHREAD_PRIO_INHERIT : _bindgen_ty_12 = 1 ; pub const PTHREAD_PRIO_PROTECT : _bindgen_ty_12 = 2 ; pub type _bindgen_ty_12 = u32 ; pub const PTHREAD_RWLOCK_PREFER_READER_NP : _bindgen_ty_13 = 0 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NP : _bindgen_ty_13 = 1 ; pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP : _bindgen_ty_13 = 2 ; pub const PTHREAD_RWLOCK_DEFAULT_NP : _bindgen_ty_13 = 0 ; pub type _bindgen_ty_13 = u32 ; pub const PTHREAD_INHERIT_SCHED : _bindgen_ty_14 = 0 ; pub const PTHREAD_EXPLICIT_SCHED : _bindgen_ty_14 = 1 ; pub type _bindgen_ty_14 = u32 ; pub const PTHREAD_SCOPE_SYSTEM : _bindgen_ty_15 = 0 ; pub const PTHREAD_SCOPE_PROCESS : _bindgen_ty_15 = 1 ; pub type _bindgen_ty_15 = u32 ; pub const PTHREAD_PROCESS_PRIVATE : _bindgen_ty_16 = 0 ; pub const PTHREAD_PROCESS_SHARED : _bindgen_ty_16 = 1 ; pub type _bindgen_ty_16 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _pthread_cleanup_buffer { pub __routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __arg : * mut :: std :: os :: raw :: c_void , pub __canceltype : :: std :: os :: raw :: c_int , pub __prev : * mut _pthread_cleanup_buffer , } # [ test ] fn bindgen_test_layout__pthread_cleanup_buffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _pthread_cleanup_buffer > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _pthread_cleanup_buffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ) ) ; } impl Default for _pthread_cleanup_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const PTHREAD_CANCEL_ENABLE : _bindgen_ty_17 = 0 ; pub const PTHREAD_CANCEL_DISABLE : _bindgen_ty_17 = 1 ; pub type _bindgen_ty_17 = u32 ; pub const PTHREAD_CANCEL_DEFERRED : _bindgen_ty_18 = 0 ; pub const PTHREAD_CANCEL_ASYNCHRONOUS : _bindgen_ty_18 = 1 ; pub type _bindgen_ty_18 = u32 ; extern "C" { # [ link_name = "\u{1}_Z14pthread_create" ] pub fn pthread_create ( __newthread : * mut pthread_t , __attr : * const pthread_attr_t , __start_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> * mut :: std :: os :: raw :: c_void > , __arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_exit" ] pub fn pthread_exit ( __retval : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_join" ] pub fn pthread_join ( __th : pthread_t , __thread_return : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14pthread_detach" ] pub fn pthread_detach ( __th : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_self" ] pub fn pthread_self ( ) -> pthread_t ; } extern "C" { # [ link_name = "\u{1}_Z13pthread_equal" ] pub fn pthread_equal ( __thread1 : pthread_t , __thread2 : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_attr_init" ] pub fn pthread_attr_init ( __attr : * mut pthread_attr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_attr_destroy" ] pub fn pthread_attr_destroy ( __attr : * mut pthread_attr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_getdetachstate" ] pub fn pthread_attr_getdetachstate ( __attr : * const pthread_attr_t , __detachstate : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_setdetachstate" ] pub fn pthread_attr_setdetachstate ( __attr : * mut pthread_attr_t , __detachstate : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_getguardsize" ] pub fn pthread_attr_getguardsize ( __attr : * const pthread_attr_t , __guardsize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_setguardsize" ] pub fn pthread_attr_setguardsize ( __attr : * mut pthread_attr_t , __guardsize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_attr_getschedparam" ] pub fn pthread_attr_getschedparam ( __attr : * const pthread_attr_t , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_attr_setschedparam" ] pub fn pthread_attr_setschedparam ( __attr : * mut pthread_attr_t , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_getschedpolicy" ] pub fn pthread_attr_getschedpolicy ( __attr : * const pthread_attr_t , __policy : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_attr_setschedpolicy" ] pub fn pthread_attr_setschedpolicy ( __attr : * mut pthread_attr_t , __policy : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_attr_getinheritsched" ] pub fn pthread_attr_getinheritsched ( __attr : * const pthread_attr_t , __inherit : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_attr_setinheritsched" ] pub fn pthread_attr_setinheritsched ( __attr : * mut pthread_attr_t , __inherit : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_getscope" ] pub fn pthread_attr_getscope ( __attr : * const pthread_attr_t , __scope : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_setscope" ] pub fn pthread_attr_setscope ( __attr : * mut pthread_attr_t , __scope : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_getstackaddr" ] pub fn pthread_attr_getstackaddr ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_setstackaddr" ] pub fn pthread_attr_setstackaddr ( __attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_getstacksize" ] pub fn pthread_attr_getstacksize ( __attr : * const pthread_attr_t , __stacksize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_attr_setstacksize" ] pub fn pthread_attr_setstacksize ( __attr : * mut pthread_attr_t , __stacksize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_getstack" ] pub fn pthread_attr_getstack ( __attr : * const pthread_attr_t , __stackaddr : * mut * mut :: std :: os :: raw :: c_void , __stacksize : * mut usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_attr_setstack" ] pub fn pthread_attr_setstack ( __attr : * mut pthread_attr_t , __stackaddr : * mut :: std :: os :: raw :: c_void , __stacksize : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_setschedparam" ] pub fn pthread_setschedparam ( __target_thread : pthread_t , __policy : :: std :: os :: raw :: c_int , __param : * const sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_getschedparam" ] pub fn pthread_getschedparam ( __target_thread : pthread_t , __policy : * mut :: std :: os :: raw :: c_int , __param : * mut sched_param ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_setschedprio" ] pub fn pthread_setschedprio ( __target_thread : pthread_t , __prio : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_once" ] pub fn pthread_once ( __once_control : * mut pthread_once_t , __init_routine : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_setcancelstate" ] pub fn pthread_setcancelstate ( __state : :: std :: os :: raw :: c_int , __oldstate : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_setcanceltype" ] pub fn pthread_setcanceltype ( __type : :: std :: os :: raw :: c_int , __oldtype : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14pthread_cancel" ] pub fn pthread_cancel ( __th : pthread_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_testcancel" ] pub fn pthread_testcancel ( ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_unwind_buf_t { pub __cancel_jmp_buf : [ __pthread_unwind_buf_t__bindgen_ty_1 ; 1usize ] , pub __pad : [ * mut :: std :: os :: raw :: c_void ; 4usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __pthread_unwind_buf_t__bindgen_ty_1 { pub __cancel_jmp_buf : __jmp_buf , pub __mask_was_saved : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) , 72usize , concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_unwind_buf_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_unwind_buf_t__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout___pthread_unwind_buf_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_unwind_buf_t > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_unwind_buf_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ) ) ; } impl Default for __pthread_unwind_buf_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __pthread_cleanup_frame { pub __cancel_routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __cancel_arg : * mut :: std :: os :: raw :: c_void , pub __do_it : :: std :: os :: raw :: c_int , pub __cancel_type : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___pthread_cleanup_frame ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __pthread_cleanup_frame > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __pthread_cleanup_frame ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __pthread_cleanup_frame > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ) ) ; } impl Default for __pthread_cleanup_frame { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z25__pthread_register_cancel" ] pub fn __pthread_register_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { # [ link_name = "\u{1}_Z27__pthread_unregister_cancel" ] pub fn __pthread_unregister_cancel ( __buf : * mut __pthread_unwind_buf_t ) ; } extern "C" { # [ link_name = "\u{1}_Z21__pthread_unwind_next" ] pub fn __pthread_unwind_next ( __buf : * mut __pthread_unwind_buf_t ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __jmp_buf_tag { _unused : [ u8 ; 0 ] , } extern "C" { # [ link_name = "\u{1}_Z11__sigsetjmp" ] pub fn __sigsetjmp ( __env : * mut __jmp_buf_tag , __savemask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_mutex_init" ] pub fn pthread_mutex_init ( __mutex : * mut pthread_mutex_t , __mutexattr : * const pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_mutex_destroy" ] pub fn pthread_mutex_destroy ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_mutex_trylock" ] pub fn pthread_mutex_trylock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_mutex_lock" ] pub fn pthread_mutex_lock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23pthread_mutex_timedlock" ] pub fn pthread_mutex_timedlock ( __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_mutex_unlock" ] pub fn pthread_mutex_unlock ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutex_getprioceiling" ] pub fn pthread_mutex_getprioceiling ( __mutex : * const pthread_mutex_t , __prioceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutex_setprioceiling" ] pub fn pthread_mutex_setprioceiling ( __mutex : * mut pthread_mutex_t , __prioceiling : :: std :: os :: raw :: c_int , __old_ceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_mutex_consistent" ] pub fn pthread_mutex_consistent ( __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_mutexattr_init" ] pub fn pthread_mutexattr_init ( __attr : * mut pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_mutexattr_destroy" ] pub fn pthread_mutexattr_destroy ( __attr : * mut pthread_mutexattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutexattr_getpshared" ] pub fn pthread_mutexattr_getpshared ( __attr : * const pthread_mutexattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28pthread_mutexattr_setpshared" ] pub fn pthread_mutexattr_setpshared ( __attr : * mut pthread_mutexattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_mutexattr_gettype" ] pub fn pthread_mutexattr_gettype ( __attr : * const pthread_mutexattr_t , __kind : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_mutexattr_settype" ] pub fn pthread_mutexattr_settype ( __attr : * mut pthread_mutexattr_t , __kind : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_mutexattr_getprotocol" ] pub fn pthread_mutexattr_getprotocol ( __attr : * const pthread_mutexattr_t , __protocol : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_mutexattr_setprotocol" ] pub fn pthread_mutexattr_setprotocol ( __attr : * mut pthread_mutexattr_t , __protocol : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z32pthread_mutexattr_getprioceiling" ] pub fn pthread_mutexattr_getprioceiling ( __attr : * const pthread_mutexattr_t , __prioceiling : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z32pthread_mutexattr_setprioceiling" ] pub fn pthread_mutexattr_setprioceiling ( __attr : * mut pthread_mutexattr_t , __prioceiling : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_mutexattr_getrobust" ] pub fn pthread_mutexattr_getrobust ( __attr : * const pthread_mutexattr_t , __robustness : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_mutexattr_setrobust" ] pub fn pthread_mutexattr_setrobust ( __attr : * mut pthread_mutexattr_t , __robustness : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_rwlock_init" ] pub fn pthread_rwlock_init ( __rwlock : * mut pthread_rwlock_t , __attr : * const pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_rwlock_destroy" ] pub fn pthread_rwlock_destroy ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_rwlock_rdlock" ] pub fn pthread_rwlock_rdlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_rwlock_tryrdlock" ] pub fn pthread_rwlock_tryrdlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_rwlock_timedrdlock" ] pub fn pthread_rwlock_timedrdlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_rwlock_wrlock" ] pub fn pthread_rwlock_wrlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_rwlock_trywrlock" ] pub fn pthread_rwlock_trywrlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_rwlock_timedwrlock" ] pub fn pthread_rwlock_timedwrlock ( __rwlock : * mut pthread_rwlock_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_rwlock_unlock" ] pub fn pthread_rwlock_unlock ( __rwlock : * mut pthread_rwlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23pthread_rwlockattr_init" ] pub fn pthread_rwlockattr_init ( __attr : * mut pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26pthread_rwlockattr_destroy" ] pub fn pthread_rwlockattr_destroy ( __attr : * mut pthread_rwlockattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_getpshared" ] pub fn pthread_rwlockattr_getpshared ( __attr : * const pthread_rwlockattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_setpshared" ] pub fn pthread_rwlockattr_setpshared ( __attr : * mut pthread_rwlockattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_getkind_np" ] pub fn pthread_rwlockattr_getkind_np ( __attr : * const pthread_rwlockattr_t , __pref : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z29pthread_rwlockattr_setkind_np" ] pub fn pthread_rwlockattr_setkind_np ( __attr : * mut pthread_rwlockattr_t , __pref : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_cond_init" ] pub fn pthread_cond_init ( __cond : * mut pthread_cond_t , __cond_attr : * const pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_cond_destroy" ] pub fn pthread_cond_destroy ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_cond_signal" ] pub fn pthread_cond_signal ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_cond_broadcast" ] pub fn pthread_cond_broadcast ( __cond : * mut pthread_cond_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_cond_wait" ] pub fn pthread_cond_wait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22pthread_cond_timedwait" ] pub fn pthread_cond_timedwait ( __cond : * mut pthread_cond_t , __mutex : * mut pthread_mutex_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_condattr_init" ] pub fn pthread_condattr_init ( __attr : * mut pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_condattr_destroy" ] pub fn pthread_condattr_destroy ( __attr : * mut pthread_condattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_condattr_getpshared" ] pub fn pthread_condattr_getpshared ( __attr : * const pthread_condattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_condattr_setpshared" ] pub fn pthread_condattr_setpshared ( __attr : * mut pthread_condattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_condattr_getclock" ] pub fn pthread_condattr_getclock ( __attr : * const pthread_condattr_t , __clock_id : * mut __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25pthread_condattr_setclock" ] pub fn pthread_condattr_setclock ( __attr : * mut pthread_condattr_t , __clock_id : __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_spin_init" ] pub fn pthread_spin_init ( __lock : * mut pthread_spinlock_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_spin_destroy" ] pub fn pthread_spin_destroy ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z17pthread_spin_lock" ] pub fn pthread_spin_lock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_spin_trylock" ] pub fn pthread_spin_trylock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_spin_unlock" ] pub fn pthread_spin_unlock ( __lock : * mut pthread_spinlock_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_barrier_init" ] pub fn pthread_barrier_init ( __barrier : * mut pthread_barrier_t , __attr : * const pthread_barrierattr_t , __count : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23pthread_barrier_destroy" ] pub fn pthread_barrier_destroy ( __barrier : * mut pthread_barrier_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20pthread_barrier_wait" ] pub fn pthread_barrier_wait ( __barrier : * mut pthread_barrier_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24pthread_barrierattr_init" ] pub fn pthread_barrierattr_init ( __attr : * mut pthread_barrierattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27pthread_barrierattr_destroy" ] pub fn pthread_barrierattr_destroy ( __attr : * mut pthread_barrierattr_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z30pthread_barrierattr_getpshared" ] pub fn pthread_barrierattr_getpshared ( __attr : * const pthread_barrierattr_t , __pshared : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z30pthread_barrierattr_setpshared" ] pub fn pthread_barrierattr_setpshared ( __attr : * mut pthread_barrierattr_t , __pshared : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_key_create" ] pub fn pthread_key_create ( __key : * mut pthread_key_t , __destr_function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z18pthread_key_delete" ] pub fn pthread_key_delete ( __key : pthread_key_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_getspecific" ] pub fn pthread_getspecific ( __key : pthread_key_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z19pthread_setspecific" ] pub fn pthread_setspecific ( __key : pthread_key_t , __pointer : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21pthread_getcpuclockid" ] pub fn pthread_getcpuclockid ( __thread_id : pthread_t , __clock_id : * mut __clockid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z14pthread_atfork" ] pub fn pthread_atfork ( __prepare : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __parent : :: std :: option :: Option < unsafe extern "C" fn ( ) > , __child : :: std :: option :: Option < unsafe extern "C" fn ( ) > ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sem_t { pub __size : [ :: std :: os :: raw :: c_char ; 32usize ] , pub __align : :: std :: os :: raw :: c_long , _bindgen_union_align : [ u64 ; 4usize ] , } # [ test ] fn bindgen_test_layout_sem_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sem_t > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( sem_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sem_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sem_t ) ) ) ; } impl Default for sem_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z8sem_init" ] pub fn sem_init ( __sem : * mut sem_t , __pshared : :: std :: os :: raw :: c_int , __value : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sem_destroy" ] pub fn sem_destroy ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sem_open" ] pub fn sem_open ( __name : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , ... ) -> * mut sem_t ; } extern "C" { # [ link_name = "\u{1}_Z9sem_close" ] pub fn sem_close ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sem_unlink" ] pub fn sem_unlink ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sem_wait" ] pub fn sem_wait ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13sem_timedwait" ] pub fn sem_timedwait ( __sem : * mut sem_t , __abstime : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sem_trywait" ] pub fn sem_trywait ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sem_post" ] pub fn sem_post ( __sem : * mut sem_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12sem_getvalue" ] pub fn sem_getvalue ( __sem : * mut sem_t , __sval : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13__sigismember" ] pub fn __sigismember ( arg1 : * const __sigset_t , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__sigaddset" ] pub fn __sigaddset ( arg1 : * mut __sigset_t , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11__sigdelset" ] pub fn __sigdelset ( arg1 : * mut __sigset_t , arg2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } pub type sig_atomic_t = __sig_atomic_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigval { pub sival_int : :: std :: os :: raw :: c_int , pub sival_ptr : * mut :: std :: os :: raw :: c_void , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigval > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigval ) ) ) ; } impl Default for sigval { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type sigval_t = sigval ; pub type __sigchld_clock_t = __clock_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t { pub si_signo : :: std :: os :: raw :: c_int , pub si_errno : :: std :: os :: raw :: c_int , pub si_code : :: std :: os :: raw :: c_int , pub _sifields : siginfo_t__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union siginfo_t__bindgen_ty_1 { pub _pad : [ :: std :: os :: raw :: c_int ; 28usize ] , pub _kill : siginfo_t__bindgen_ty_1__bindgen_ty_1 , pub _timer : siginfo_t__bindgen_ty_1__bindgen_ty_2 , pub _rt : siginfo_t__bindgen_ty_1__bindgen_ty_3 , pub _sigchld : siginfo_t__bindgen_ty_1__bindgen_ty_4 , pub _sigfault : siginfo_t__bindgen_ty_1__bindgen_ty_5 , pub _sigpoll : siginfo_t__bindgen_ty_1__bindgen_ty_6 , pub _sigsys : siginfo_t__bindgen_ty_1__bindgen_ty_7 , _bindgen_union_align : [ u64 ; 14usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid : __pid_t , pub si_uid : __uid_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid : :: std :: os :: raw :: c_int , pub si_overrun : :: std :: os :: raw :: c_int , pub si_sigval : sigval_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_sigval : sigval_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid : __pid_t , pub si_uid : __uid_t , pub si_status : :: std :: os :: raw :: c_int , pub si_utime : __sigchld_clock_t , pub si_stime : __sigchld_clock_t , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band : :: std :: os :: raw :: c_long , pub si_fd : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr : * mut :: std :: os :: raw :: c_void , pub _syscall : :: std :: os :: raw :: c_int , pub _arch : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_siginfo_t__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t__bindgen_ty_1 > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ) ) ; } impl Default for siginfo_t__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_siginfo_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < siginfo_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( siginfo_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < siginfo_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( siginfo_t ) ) ) ; } impl Default for siginfo_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const SI_ASYNCNL : _bindgen_ty_19 = -60 ; pub const SI_TKILL : _bindgen_ty_19 = -6 ; pub const SI_SIGIO : _bindgen_ty_19 = -5 ; pub const SI_ASYNCIO : _bindgen_ty_19 = -4 ; pub const SI_MESGQ : _bindgen_ty_19 = -3 ; pub const SI_TIMER : _bindgen_ty_19 = -2 ; pub const SI_QUEUE : _bindgen_ty_19 = -1 ; pub const SI_USER : _bindgen_ty_19 = 0 ; pub const SI_KERNEL : _bindgen_ty_19 = 128 ; pub type _bindgen_ty_19 = i32 ; pub const ILL_ILLOPC : _bindgen_ty_20 = 1 ; pub const ILL_ILLOPN : _bindgen_ty_20 = 2 ; pub const ILL_ILLADR : _bindgen_ty_20 = 3 ; pub const ILL_ILLTRP : _bindgen_ty_20 = 4 ; pub const ILL_PRVOPC : _bindgen_ty_20 = 5 ; pub const ILL_PRVREG : _bindgen_ty_20 = 6 ; pub const ILL_COPROC : _bindgen_ty_20 = 7 ; pub const ILL_BADSTK : _bindgen_ty_20 = 8 ; pub type _bindgen_ty_20 = u32 ; pub const FPE_INTDIV : _bindgen_ty_21 = 1 ; pub const FPE_INTOVF : _bindgen_ty_21 = 2 ; pub const FPE_FLTDIV : _bindgen_ty_21 = 3 ; pub const FPE_FLTOVF : _bindgen_ty_21 = 4 ; pub const FPE_FLTUND : _bindgen_ty_21 = 5 ; pub const FPE_FLTRES : _bindgen_ty_21 = 6 ; pub const FPE_FLTINV : _bindgen_ty_21 = 7 ; pub const FPE_FLTSUB : _bindgen_ty_21 = 8 ; pub type _bindgen_ty_21 = u32 ; pub const SEGV_MAPERR : _bindgen_ty_22 = 1 ; pub const SEGV_ACCERR : _bindgen_ty_22 = 2 ; pub type _bindgen_ty_22 = u32 ; pub const BUS_ADRALN : _bindgen_ty_23 = 1 ; pub const BUS_ADRERR : _bindgen_ty_23 = 2 ; pub const BUS_OBJERR : _bindgen_ty_23 = 3 ; pub type _bindgen_ty_23 = u32 ; pub const TRAP_BRKPT : _bindgen_ty_24 = 1 ; pub const TRAP_TRACE : _bindgen_ty_24 = 2 ; pub type _bindgen_ty_24 = u32 ; pub const CLD_EXITED : _bindgen_ty_25 = 1 ; pub const CLD_KILLED : _bindgen_ty_25 = 2 ; pub const CLD_DUMPED : _bindgen_ty_25 = 3 ; pub const CLD_TRAPPED : _bindgen_ty_25 = 4 ; pub const CLD_STOPPED : _bindgen_ty_25 = 5 ; pub const CLD_CONTINUED : _bindgen_ty_25 = 6 ; pub type _bindgen_ty_25 = u32 ; pub const POLL_IN : _bindgen_ty_26 = 1 ; pub const POLL_OUT : _bindgen_ty_26 = 2 ; pub const POLL_MSG : _bindgen_ty_26 = 3 ; pub const POLL_ERR : _bindgen_ty_26 = 4 ; pub const POLL_PRI : _bindgen_ty_26 = 5 ; pub const POLL_HUP : _bindgen_ty_26 = 6 ; pub type _bindgen_ty_26 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigevent { pub sigev_value : sigval_t , pub sigev_signo : :: std :: os :: raw :: c_int , pub sigev_notify : :: std :: os :: raw :: c_int , pub _sigev_un : sigevent__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigevent__bindgen_ty_1 { pub _pad : [ :: std :: os :: raw :: c_int ; 12usize ] , pub _tid : __pid_t , pub _sigev_thread : sigevent__bindgen_ty_1__bindgen_ty_1 , _bindgen_union_align : [ u64 ; 6usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : sigval_t ) > , pub _attribute : * mut pthread_attr_t , } # [ test ] fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigevent__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent__bindgen_ty_1 > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ) ) ; } impl Default for sigevent__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigevent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( sigevent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent ) ) ) ; } impl Default for sigevent { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type sigevent_t = sigevent ; pub const SIGEV_SIGNAL : _bindgen_ty_27 = 0 ; pub const SIGEV_NONE : _bindgen_ty_27 = 1 ; pub const SIGEV_THREAD : _bindgen_ty_27 = 2 ; pub const SIGEV_THREAD_ID : _bindgen_ty_27 = 4 ; pub type _bindgen_ty_27 = u32 ; pub type __sighandler_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > ; extern "C" { # [ link_name = "\u{1}_Z13__sysv_signal" ] pub fn __sysv_signal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { # [ link_name = "\u{1}_Z6signal" ] pub fn signal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { # [ link_name = "\u{1}_Z4kill" ] pub fn kill ( __pid : __pid_t , __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6killpg" ] pub fn killpg ( __pgrp : __pid_t , __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5raise" ] pub fn raise ( __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ssignal" ] pub fn ssignal ( __sig : :: std :: os :: raw :: c_int , __handler : __sighandler_t ) -> __sighandler_t ; } extern "C" { # [ link_name = "\u{1}_Z7gsignal" ] pub fn gsignal ( __sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7psignal" ] pub fn psignal ( __sig : :: std :: os :: raw :: c_int , __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z8psiginfo" ] pub fn psiginfo ( __pinfo : * const siginfo_t , __s : * const :: std :: os :: raw :: c_char ) ; } extern "C" { # [ link_name = "\u{1}_Z10__sigpause" ] pub fn __sigpause ( __sig_or_mask : :: std :: os :: raw :: c_int , __is_sig : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sigblock" ] pub fn sigblock ( __mask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigsetmask" ] pub fn sigsetmask ( __mask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10siggetmask" ] pub fn siggetmask ( ) -> :: std :: os :: raw :: c_int ; } pub type sig_t = __sighandler_t ; extern "C" { # [ link_name = "\u{1}_Z11sigemptyset" ] pub fn sigemptyset ( __set : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigfillset" ] pub fn sigfillset ( __set : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sigaddset" ] pub fn sigaddset ( __set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sigdelset" ] pub fn sigdelset ( __set : * mut sigset_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sigismember" ] pub fn sigismember ( __set : * const sigset_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigaction { pub __sigaction_handler : sigaction__bindgen_ty_1 , pub sa_mask : __sigset_t , pub sa_flags : :: std :: os :: raw :: c_int , pub sa_restorer : :: std :: option :: Option < unsafe extern "C" fn ( ) > , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigaction__bindgen_ty_1 { pub sa_handler : __sighandler_t , pub sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut siginfo_t , arg3 : * mut :: std :: os :: raw :: c_void ) > , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigaction__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ) ) ; } impl Default for sigaction__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigaction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( sigaction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction ) ) ) ; } impl Default for sigaction { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z11sigprocmask" ] pub fn sigprocmask ( __how : :: std :: os :: raw :: c_int , __set : * const sigset_t , __oset : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigsuspend" ] pub fn sigsuspend ( __set : * const sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sigaction" ] pub fn sigaction ( __sig : :: std :: os :: raw :: c_int , __act : * const sigaction , __oact : * mut sigaction ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10sigpending" ] pub fn sigpending ( __set : * mut sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7sigwait" ] pub fn sigwait ( __set : * const sigset_t , __sig : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sigwaitinfo" ] pub fn sigwaitinfo ( __set : * const sigset_t , __info : * mut siginfo_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12sigtimedwait" ] pub fn sigtimedwait ( __set : * const sigset_t , __info : * mut siginfo_t , __timeout : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8sigqueue" ] pub fn sigqueue ( __pid : __pid_t , __sig : :: std :: os :: raw :: c_int , __val : sigval ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigvec { pub sv_handler : __sighandler_t , pub sv_mask : :: std :: os :: raw :: c_int , pub sv_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigvec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigvec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigvec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigvec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigvec ) ) ) ; } impl Default for sigvec { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z6sigvec" ] pub fn sigvec ( __sig : :: std :: os :: raw :: c_int , __vec : * const sigvec , __ovec : * mut sigvec ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpx_sw_bytes { pub magic1 : __uint32_t , pub extended_size : __uint32_t , pub xstate_bv : __uint64_t , pub xstate_size : __uint32_t , pub padding : [ __uint32_t ; 7usize ] , } # [ test ] fn bindgen_test_layout__fpx_sw_bytes ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpx_sw_bytes > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _fpx_sw_bytes ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpx_sw_bytes > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _fpx_sw_bytes ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout__fpreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpreg > ( ) , 10usize , concat ! ( "Size of: " , stringify ! ( _fpreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _fpreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpxreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , pub padding : [ :: std :: os :: raw :: c_ushort ; 3usize ] , } # [ test ] fn bindgen_test_layout__fpxreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpxreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _fpxreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpxreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _fpxreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ test ] fn bindgen_test_layout__xmmreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmmreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _xmmreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmmreg > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _xmmreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _fpxreg ; 8usize ] , pub _xmm : [ _xmmreg ; 16usize ] , pub padding : [ __uint32_t ; 24usize ] , } # [ test ] fn bindgen_test_layout__fpstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _fpstate > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( _fpstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _fpstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _fpstate ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigcontext { pub r8 : __uint64_t , pub r9 : __uint64_t , pub r10 : __uint64_t , pub r11 : __uint64_t , pub r12 : __uint64_t , pub r13 : __uint64_t , pub r14 : __uint64_t , pub r15 : __uint64_t , pub rdi : __uint64_t , pub rsi : __uint64_t , pub rbp : __uint64_t , pub rbx : __uint64_t , pub rdx : __uint64_t , pub rax : __uint64_t , pub rcx : __uint64_t , pub rsp : __uint64_t , pub rip : __uint64_t , pub eflags : __uint64_t , pub cs : :: std :: os :: raw :: c_ushort , pub gs : :: std :: os :: raw :: c_ushort , pub fs : :: std :: os :: raw :: c_ushort , pub __pad0 : :: std :: os :: raw :: c_ushort , pub err : __uint64_t , pub trapno : __uint64_t , pub oldmask : __uint64_t , pub cr2 : __uint64_t , pub __bindgen_anon_1 : sigcontext__bindgen_ty_1 , pub __reserved1 : [ __uint64_t ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigcontext__bindgen_ty_1 { pub fpstate : * mut _fpstate , pub __fpstate_word : __uint64_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigcontext__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigcontext__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigcontext__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ) ) ; } impl Default for sigcontext__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_sigcontext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigcontext > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( sigcontext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigcontext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigcontext ) ) ) ; } impl Default for sigcontext { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _xsave_hdr { pub xstate_bv : __uint64_t , pub reserved1 : [ __uint64_t ; 2usize ] , pub reserved2 : [ __uint64_t ; 5usize ] , } # [ test ] fn bindgen_test_layout__xsave_hdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xsave_hdr > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( _xsave_hdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xsave_hdr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xsave_hdr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _ymmh_state { pub ymmh_space : [ __uint32_t ; 64usize ] , } # [ test ] fn bindgen_test_layout__ymmh_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _ymmh_state > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( _ymmh_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _ymmh_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _ymmh_state ) ) ) ; } impl Default for _ymmh_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _xstate { pub fpstate : _fpstate , pub xstate_hdr : _xsave_hdr , pub ymmh : _ymmh_state , } # [ test ] fn bindgen_test_layout__xstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xstate > ( ) , 832usize , concat ! ( "Size of: " , stringify ! ( _xstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xstate ) ) ) ; } impl Default for _xstate { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z9sigreturn" ] pub fn sigreturn ( __scp : * mut sigcontext ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12siginterrupt" ] pub fn siginterrupt ( __sig : :: std :: os :: raw :: c_int , __interrupt : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_onstack : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigstack > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigstack ) ) ) ; } impl Default for sigstack { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const SS_ONSTACK : _bindgen_ty_28 = 1 ; pub const SS_DISABLE : _bindgen_ty_28 = 2 ; pub type _bindgen_ty_28 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigaltstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_flags : :: std :: os :: raw :: c_int , pub ss_size : usize , } # [ test ] fn bindgen_test_layout_sigaltstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaltstack > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( sigaltstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaltstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaltstack ) ) ) ; } impl Default for sigaltstack { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type stack_t = sigaltstack ; pub type greg_t = :: std :: os :: raw :: c_longlong ; pub type gregset_t = [ greg_t ; 23usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpxreg { pub significand : [ :: std :: os :: raw :: c_ushort ; 4usize ] , pub exponent : :: std :: os :: raw :: c_ushort , pub padding : [ :: std :: os :: raw :: c_ushort ; 3usize ] , } # [ test ] fn bindgen_test_layout__libc_fpxreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_fpxreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _libc_fpxreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_fpxreg > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( _libc_fpxreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_xmmreg { pub element : [ __uint32_t ; 4usize ] , } # [ test ] fn bindgen_test_layout__libc_xmmreg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_xmmreg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _libc_xmmreg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_xmmreg > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( _libc_xmmreg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct _libc_fpstate { pub cwd : __uint16_t , pub swd : __uint16_t , pub ftw : __uint16_t , pub fop : __uint16_t , pub rip : __uint64_t , pub rdp : __uint64_t , pub mxcsr : __uint32_t , pub mxcr_mask : __uint32_t , pub _st : [ _libc_fpxreg ; 8usize ] , pub _xmm : [ _libc_xmmreg ; 16usize ] , pub padding : [ __uint32_t ; 24usize ] , } # [ test ] fn bindgen_test_layout__libc_fpstate ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _libc_fpstate > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( _libc_fpstate ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _libc_fpstate > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _libc_fpstate ) ) ) ; } pub type fpregset_t = * mut _libc_fpstate ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct mcontext_t { pub gregs : gregset_t , pub fpregs : fpregset_t , pub __reserved1 : [ :: std :: os :: raw :: c_ulonglong ; 8usize ] , } # [ test ] fn bindgen_test_layout_mcontext_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < mcontext_t > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( mcontext_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < mcontext_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( mcontext_t ) ) ) ; } impl Default for mcontext_t { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ucontext { pub uc_flags : :: std :: os :: raw :: c_ulong , pub uc_link : * mut ucontext , pub uc_stack : stack_t , pub uc_mcontext : mcontext_t , pub uc_sigmask : __sigset_t , pub __fpregs_mem : _libc_fpstate , } # [ test ] fn bindgen_test_layout_ucontext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ucontext > ( ) , 936usize , concat ! ( "Size of: " , stringify ! ( ucontext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ucontext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ucontext ) ) ) ; } impl Default for ucontext { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub type ucontext_t = ucontext ; extern "C" { # [ link_name = "\u{1}_Z8sigstack" ] pub fn sigstack ( __ss : * mut sigstack , __oss : * mut sigstack ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sigaltstack" ] pub fn sigaltstack ( __ss : * const sigaltstack , __oss : * mut sigaltstack ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z15pthread_sigmask" ] pub fn pthread_sigmask ( __how : :: std :: os :: raw :: c_int , __newmask : * const __sigset_t , __oldmask : * mut __sigset_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12pthread_kill" ] pub fn pthread_kill ( __threadid : pthread_t , __signo : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23__libc_current_sigrtmin" ] pub fn __libc_current_sigrtmin ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23__libc_current_sigrtmax" ] pub fn __libc_current_sigrtmax ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8closelog" ] pub fn closelog ( ) ; } extern "C" { # [ link_name = "\u{1}_Z7openlog" ] pub fn openlog ( __ident : * const :: std :: os :: raw :: c_char , __option : :: std :: os :: raw :: c_int , __facility : :: std :: os :: raw :: c_int ) ; } extern "C" { # [ link_name = "\u{1}_Z10setlogmask" ] pub fn setlogmask ( __mask : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6syslog" ] pub fn syslog ( __pri : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , ... ) ; } extern "C" { # [ link_name = "\u{1}_Z7vsyslog" ] pub fn vsyslog ( __pri : :: std :: os :: raw :: c_int , __fmt : * const :: std :: os :: raw :: c_char , __ap : * mut __va_list_tag ) ; } pub type cc_t = :: std :: os :: raw :: c_uchar ; pub type speed_t = :: std :: os :: raw :: c_uint ; pub type tcflag_t = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termios { pub c_iflag : tcflag_t , pub c_oflag : tcflag_t , pub c_cflag : tcflag_t , pub c_lflag : tcflag_t , pub c_line : cc_t , pub c_cc : [ cc_t ; 32usize ] , pub c_ispeed : speed_t , pub c_ospeed : speed_t , } # [ test ] fn bindgen_test_layout_termios ( ) { assert_eq ! ( :: std :: mem :: size_of :: < termios > ( ) , 60usize , concat ! ( "Size of: " , stringify ! ( termios ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < termios > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( termios ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z11cfgetospeed" ] pub fn cfgetospeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { # [ link_name = "\u{1}_Z11cfgetispeed" ] pub fn cfgetispeed ( __termios_p : * const termios ) -> speed_t ; } extern "C" { # [ link_name = "\u{1}_Z11cfsetospeed" ] pub fn cfsetospeed ( __termios_p : * mut termios , __speed : speed_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11cfsetispeed" ] pub fn cfsetispeed ( __termios_p : * mut termios , __speed : speed_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10cfsetspeed" ] pub fn cfsetspeed ( __termios_p : * mut termios , __speed : speed_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tcgetattr" ] pub fn tcgetattr ( __fd : :: std :: os :: raw :: c_int , __termios_p : * mut termios ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tcsetattr" ] pub fn tcsetattr ( __fd : :: std :: os :: raw :: c_int , __optional_actions : :: std :: os :: raw :: c_int , __termios_p : * const termios ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9cfmakeraw" ] pub fn cfmakeraw ( __termios_p : * mut termios ) ; } extern "C" { # [ link_name = "\u{1}_Z11tcsendbreak" ] pub fn tcsendbreak ( __fd : :: std :: os :: raw :: c_int , __duration : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tcdrain" ] pub fn tcdrain ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7tcflush" ] pub fn tcflush ( __fd : :: std :: os :: raw :: c_int , __queue_selector : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6tcflow" ] pub fn tcflow ( __fd : :: std :: os :: raw :: c_int , __action : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8tcgetsid" ] pub fn tcgetsid ( __fd : :: std :: os :: raw :: c_int ) -> __pid_t ; } pub type useconds_t = __useconds_t ; extern "C" { # [ link_name = "\u{1}_Z6access" ] pub fn access ( __name : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9faccessat" ] pub fn faccessat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __type : :: std :: os :: raw :: c_int , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5lseek" ] pub fn lseek ( __fd : :: std :: os :: raw :: c_int , __offset : __off_t , __whence : :: std :: os :: raw :: c_int ) -> __off_t ; } extern "C" { # [ link_name = "\u{1}_Z5close" ] pub fn close ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4read" ] pub fn read ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z5write" ] pub fn write ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z5pread" ] pub fn pread ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize , __offset : __off_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6pwrite" ] pub fn pwrite ( __fd : :: std :: os :: raw :: c_int , __buf : * const :: std :: os :: raw :: c_void , __n : usize , __offset : __off_t ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z4pipe" ] pub fn pipe ( __pipedes : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5alarm" ] pub fn alarm ( __seconds : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z5sleep" ] pub fn sleep ( __seconds : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z6ualarm" ] pub fn ualarm ( __value : __useconds_t , __interval : __useconds_t ) -> __useconds_t ; } extern "C" { # [ link_name = "\u{1}_Z6usleep" ] pub fn usleep ( __useconds : __useconds_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5pause" ] pub fn pause ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5chown" ] pub fn chown ( __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fchown" ] pub fn fchown ( __fd : :: std :: os :: raw :: c_int , __owner : __uid_t , __group : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6lchown" ] pub fn lchown ( __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8fchownat" ] pub fn fchownat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __owner : __uid_t , __group : __gid_t , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5chdir" ] pub fn chdir ( __path : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fchdir" ] pub fn fchdir ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6getcwd" ] pub fn getcwd ( __buf : * mut :: std :: os :: raw :: c_char , __size : usize ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5getwd" ] pub fn getwd ( __buf : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z3dup" ] pub fn dup ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4dup2" ] pub fn dup2 ( __fd : :: std :: os :: raw :: c_int , __fd2 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execve" ] pub fn execve ( __path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7fexecve" ] pub fn fexecve ( __fd : :: std :: os :: raw :: c_int , __argv : * const * mut :: std :: os :: raw :: c_char , __envp : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5execv" ] pub fn execv ( __path : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execle" ] pub fn execle ( __path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5execl" ] pub fn execl ( __path : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execvp" ] pub fn execvp ( __file : * const :: std :: os :: raw :: c_char , __argv : * const * mut :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6execlp" ] pub fn execlp ( __file : * const :: std :: os :: raw :: c_char , __arg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4nice" ] pub fn nice ( __inc : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5_exit" ] pub fn _exit ( __status : :: std :: os :: raw :: c_int ) ; } pub const _PC_LINK_MAX : _bindgen_ty_29 = 0 ; pub const _PC_MAX_CANON : _bindgen_ty_29 = 1 ; pub const _PC_MAX_INPUT : _bindgen_ty_29 = 2 ; pub const _PC_NAME_MAX : _bindgen_ty_29 = 3 ; pub const _PC_PATH_MAX : _bindgen_ty_29 = 4 ; pub const _PC_PIPE_BUF : _bindgen_ty_29 = 5 ; pub const _PC_CHOWN_RESTRICTED : _bindgen_ty_29 = 6 ; pub const _PC_NO_TRUNC : _bindgen_ty_29 = 7 ; pub const _PC_VDISABLE : _bindgen_ty_29 = 8 ; pub const _PC_SYNC_IO : _bindgen_ty_29 = 9 ; pub const _PC_ASYNC_IO : _bindgen_ty_29 = 10 ; pub const _PC_PRIO_IO : _bindgen_ty_29 = 11 ; pub const _PC_SOCK_MAXBUF : _bindgen_ty_29 = 12 ; pub const _PC_FILESIZEBITS : _bindgen_ty_29 = 13 ; pub const _PC_REC_INCR_XFER_SIZE : _bindgen_ty_29 = 14 ; pub const _PC_REC_MAX_XFER_SIZE : _bindgen_ty_29 = 15 ; pub const _PC_REC_MIN_XFER_SIZE : _bindgen_ty_29 = 16 ; pub const _PC_REC_XFER_ALIGN : _bindgen_ty_29 = 17 ; pub const _PC_ALLOC_SIZE_MIN : _bindgen_ty_29 = 18 ; pub const _PC_SYMLINK_MAX : _bindgen_ty_29 = 19 ; pub const _PC_2_SYMLINKS : _bindgen_ty_29 = 20 ; pub type _bindgen_ty_29 = u32 ; pub const _SC_ARG_MAX : _bindgen_ty_30 = 0 ; pub const _SC_CHILD_MAX : _bindgen_ty_30 = 1 ; pub const _SC_CLK_TCK : _bindgen_ty_30 = 2 ; pub const _SC_NGROUPS_MAX : _bindgen_ty_30 = 3 ; pub const _SC_OPEN_MAX : _bindgen_ty_30 = 4 ; pub const _SC_STREAM_MAX : _bindgen_ty_30 = 5 ; pub const _SC_TZNAME_MAX : _bindgen_ty_30 = 6 ; pub const _SC_JOB_CONTROL : _bindgen_ty_30 = 7 ; pub const _SC_SAVED_IDS : _bindgen_ty_30 = 8 ; pub const _SC_REALTIME_SIGNALS : _bindgen_ty_30 = 9 ; pub const _SC_PRIORITY_SCHEDULING : _bindgen_ty_30 = 10 ; pub const _SC_TIMERS : _bindgen_ty_30 = 11 ; pub const _SC_ASYNCHRONOUS_IO : _bindgen_ty_30 = 12 ; pub const _SC_PRIORITIZED_IO : _bindgen_ty_30 = 13 ; pub const _SC_SYNCHRONIZED_IO : _bindgen_ty_30 = 14 ; pub const _SC_FSYNC : _bindgen_ty_30 = 15 ; pub const _SC_MAPPED_FILES : _bindgen_ty_30 = 16 ; pub const _SC_MEMLOCK : _bindgen_ty_30 = 17 ; pub const _SC_MEMLOCK_RANGE : _bindgen_ty_30 = 18 ; pub const _SC_MEMORY_PROTECTION : _bindgen_ty_30 = 19 ; pub const _SC_MESSAGE_PASSING : _bindgen_ty_30 = 20 ; pub const _SC_SEMAPHORES : _bindgen_ty_30 = 21 ; pub const _SC_SHARED_MEMORY_OBJECTS : _bindgen_ty_30 = 22 ; pub const _SC_AIO_LISTIO_MAX : _bindgen_ty_30 = 23 ; pub const _SC_AIO_MAX : _bindgen_ty_30 = 24 ; pub const _SC_AIO_PRIO_DELTA_MAX : _bindgen_ty_30 = 25 ; pub const _SC_DELAYTIMER_MAX : _bindgen_ty_30 = 26 ; pub const _SC_MQ_OPEN_MAX : _bindgen_ty_30 = 27 ; pub const _SC_MQ_PRIO_MAX : _bindgen_ty_30 = 28 ; pub const _SC_VERSION : _bindgen_ty_30 = 29 ; pub const _SC_PAGESIZE : _bindgen_ty_30 = 30 ; pub const _SC_RTSIG_MAX : _bindgen_ty_30 = 31 ; pub const _SC_SEM_NSEMS_MAX : _bindgen_ty_30 = 32 ; pub const _SC_SEM_VALUE_MAX : _bindgen_ty_30 = 33 ; pub const _SC_SIGQUEUE_MAX : _bindgen_ty_30 = 34 ; pub const _SC_TIMER_MAX : _bindgen_ty_30 = 35 ; pub const _SC_BC_BASE_MAX : _bindgen_ty_30 = 36 ; pub const _SC_BC_DIM_MAX : _bindgen_ty_30 = 37 ; pub const _SC_BC_SCALE_MAX : _bindgen_ty_30 = 38 ; pub const _SC_BC_STRING_MAX : _bindgen_ty_30 = 39 ; pub const _SC_COLL_WEIGHTS_MAX : _bindgen_ty_30 = 40 ; pub const _SC_EQUIV_CLASS_MAX : _bindgen_ty_30 = 41 ; pub const _SC_EXPR_NEST_MAX : _bindgen_ty_30 = 42 ; pub const _SC_LINE_MAX : _bindgen_ty_30 = 43 ; pub const _SC_RE_DUP_MAX : _bindgen_ty_30 = 44 ; pub const _SC_CHARCLASS_NAME_MAX : _bindgen_ty_30 = 45 ; pub const _SC_2_VERSION : _bindgen_ty_30 = 46 ; pub const _SC_2_C_BIND : _bindgen_ty_30 = 47 ; pub const _SC_2_C_DEV : _bindgen_ty_30 = 48 ; pub const _SC_2_FORT_DEV : _bindgen_ty_30 = 49 ; pub const _SC_2_FORT_RUN : _bindgen_ty_30 = 50 ; pub const _SC_2_SW_DEV : _bindgen_ty_30 = 51 ; pub const _SC_2_LOCALEDEF : _bindgen_ty_30 = 52 ; pub const _SC_PII : _bindgen_ty_30 = 53 ; pub const _SC_PII_XTI : _bindgen_ty_30 = 54 ; pub const _SC_PII_SOCKET : _bindgen_ty_30 = 55 ; pub const _SC_PII_INTERNET : _bindgen_ty_30 = 56 ; pub const _SC_PII_OSI : _bindgen_ty_30 = 57 ; pub const _SC_POLL : _bindgen_ty_30 = 58 ; pub const _SC_SELECT : _bindgen_ty_30 = 59 ; pub const _SC_UIO_MAXIOV : _bindgen_ty_30 = 60 ; pub const _SC_IOV_MAX : _bindgen_ty_30 = 60 ; pub const _SC_PII_INTERNET_STREAM : _bindgen_ty_30 = 61 ; pub const _SC_PII_INTERNET_DGRAM : _bindgen_ty_30 = 62 ; pub const _SC_PII_OSI_COTS : _bindgen_ty_30 = 63 ; pub const _SC_PII_OSI_CLTS : _bindgen_ty_30 = 64 ; pub const _SC_PII_OSI_M : _bindgen_ty_30 = 65 ; pub const _SC_T_IOV_MAX : _bindgen_ty_30 = 66 ; pub const _SC_THREADS : _bindgen_ty_30 = 67 ; pub const _SC_THREAD_SAFE_FUNCTIONS : _bindgen_ty_30 = 68 ; pub const _SC_GETGR_R_SIZE_MAX : _bindgen_ty_30 = 69 ; pub const _SC_GETPW_R_SIZE_MAX : _bindgen_ty_30 = 70 ; pub const _SC_LOGIN_NAME_MAX : _bindgen_ty_30 = 71 ; pub const _SC_TTY_NAME_MAX : _bindgen_ty_30 = 72 ; pub const _SC_THREAD_DESTRUCTOR_ITERATIONS : _bindgen_ty_30 = 73 ; pub const _SC_THREAD_KEYS_MAX : _bindgen_ty_30 = 74 ; pub const _SC_THREAD_STACK_MIN : _bindgen_ty_30 = 75 ; pub const _SC_THREAD_THREADS_MAX : _bindgen_ty_30 = 76 ; pub const _SC_THREAD_ATTR_STACKADDR : _bindgen_ty_30 = 77 ; pub const _SC_THREAD_ATTR_STACKSIZE : _bindgen_ty_30 = 78 ; pub const _SC_THREAD_PRIORITY_SCHEDULING : _bindgen_ty_30 = 79 ; pub const _SC_THREAD_PRIO_INHERIT : _bindgen_ty_30 = 80 ; pub const _SC_THREAD_PRIO_PROTECT : _bindgen_ty_30 = 81 ; pub const _SC_THREAD_PROCESS_SHARED : _bindgen_ty_30 = 82 ; pub const _SC_NPROCESSORS_CONF : _bindgen_ty_30 = 83 ; pub const _SC_NPROCESSORS_ONLN : _bindgen_ty_30 = 84 ; pub const _SC_PHYS_PAGES : _bindgen_ty_30 = 85 ; pub const _SC_AVPHYS_PAGES : _bindgen_ty_30 = 86 ; pub const _SC_ATEXIT_MAX : _bindgen_ty_30 = 87 ; pub const _SC_PASS_MAX : _bindgen_ty_30 = 88 ; pub const _SC_XOPEN_VERSION : _bindgen_ty_30 = 89 ; pub const _SC_XOPEN_XCU_VERSION : _bindgen_ty_30 = 90 ; pub const _SC_XOPEN_UNIX : _bindgen_ty_30 = 91 ; pub const _SC_XOPEN_CRYPT : _bindgen_ty_30 = 92 ; pub const _SC_XOPEN_ENH_I18N : _bindgen_ty_30 = 93 ; pub const _SC_XOPEN_SHM : _bindgen_ty_30 = 94 ; pub const _SC_2_CHAR_TERM : _bindgen_ty_30 = 95 ; pub const _SC_2_C_VERSION : _bindgen_ty_30 = 96 ; pub const _SC_2_UPE : _bindgen_ty_30 = 97 ; pub const _SC_XOPEN_XPG2 : _bindgen_ty_30 = 98 ; pub const _SC_XOPEN_XPG3 : _bindgen_ty_30 = 99 ; pub const _SC_XOPEN_XPG4 : _bindgen_ty_30 = 100 ; pub const _SC_CHAR_BIT : _bindgen_ty_30 = 101 ; pub const _SC_CHAR_MAX : _bindgen_ty_30 = 102 ; pub const _SC_CHAR_MIN : _bindgen_ty_30 = 103 ; pub const _SC_INT_MAX : _bindgen_ty_30 = 104 ; pub const _SC_INT_MIN : _bindgen_ty_30 = 105 ; pub const _SC_LONG_BIT : _bindgen_ty_30 = 106 ; pub const _SC_WORD_BIT : _bindgen_ty_30 = 107 ; pub const _SC_MB_LEN_MAX : _bindgen_ty_30 = 108 ; pub const _SC_NZERO : _bindgen_ty_30 = 109 ; pub const _SC_SSIZE_MAX : _bindgen_ty_30 = 110 ; pub const _SC_SCHAR_MAX : _bindgen_ty_30 = 111 ; pub const _SC_SCHAR_MIN : _bindgen_ty_30 = 112 ; pub const _SC_SHRT_MAX : _bindgen_ty_30 = 113 ; pub const _SC_SHRT_MIN : _bindgen_ty_30 = 114 ; pub const _SC_UCHAR_MAX : _bindgen_ty_30 = 115 ; pub const _SC_UINT_MAX : _bindgen_ty_30 = 116 ; pub const _SC_ULONG_MAX : _bindgen_ty_30 = 117 ; pub const _SC_USHRT_MAX : _bindgen_ty_30 = 118 ; pub const _SC_NL_ARGMAX : _bindgen_ty_30 = 119 ; pub const _SC_NL_LANGMAX : _bindgen_ty_30 = 120 ; pub const _SC_NL_MSGMAX : _bindgen_ty_30 = 121 ; pub const _SC_NL_NMAX : _bindgen_ty_30 = 122 ; pub const _SC_NL_SETMAX : _bindgen_ty_30 = 123 ; pub const _SC_NL_TEXTMAX : _bindgen_ty_30 = 124 ; pub const _SC_XBS5_ILP32_OFF32 : _bindgen_ty_30 = 125 ; pub const _SC_XBS5_ILP32_OFFBIG : _bindgen_ty_30 = 126 ; pub const _SC_XBS5_LP64_OFF64 : _bindgen_ty_30 = 127 ; pub const _SC_XBS5_LPBIG_OFFBIG : _bindgen_ty_30 = 128 ; pub const _SC_XOPEN_LEGACY : _bindgen_ty_30 = 129 ; pub const _SC_XOPEN_REALTIME : _bindgen_ty_30 = 130 ; pub const _SC_XOPEN_REALTIME_THREADS : _bindgen_ty_30 = 131 ; pub const _SC_ADVISORY_INFO : _bindgen_ty_30 = 132 ; pub const _SC_BARRIERS : _bindgen_ty_30 = 133 ; pub const _SC_BASE : _bindgen_ty_30 = 134 ; pub const _SC_C_LANG_SUPPORT : _bindgen_ty_30 = 135 ; pub const _SC_C_LANG_SUPPORT_R : _bindgen_ty_30 = 136 ; pub const _SC_CLOCK_SELECTION : _bindgen_ty_30 = 137 ; pub const _SC_CPUTIME : _bindgen_ty_30 = 138 ; pub const _SC_THREAD_CPUTIME : _bindgen_ty_30 = 139 ; pub const _SC_DEVICE_IO : _bindgen_ty_30 = 140 ; pub const _SC_DEVICE_SPECIFIC : _bindgen_ty_30 = 141 ; pub const _SC_DEVICE_SPECIFIC_R : _bindgen_ty_30 = 142 ; pub const _SC_FD_MGMT : _bindgen_ty_30 = 143 ; pub const _SC_FIFO : _bindgen_ty_30 = 144 ; pub const _SC_PIPE : _bindgen_ty_30 = 145 ; pub const _SC_FILE_ATTRIBUTES : _bindgen_ty_30 = 146 ; pub const _SC_FILE_LOCKING : _bindgen_ty_30 = 147 ; pub const _SC_FILE_SYSTEM : _bindgen_ty_30 = 148 ; pub const _SC_MONOTONIC_CLOCK : _bindgen_ty_30 = 149 ; pub const _SC_MULTI_PROCESS : _bindgen_ty_30 = 150 ; pub const _SC_SINGLE_PROCESS : _bindgen_ty_30 = 151 ; pub const _SC_NETWORKING : _bindgen_ty_30 = 152 ; pub const _SC_READER_WRITER_LOCKS : _bindgen_ty_30 = 153 ; pub const _SC_SPIN_LOCKS : _bindgen_ty_30 = 154 ; pub const _SC_REGEXP : _bindgen_ty_30 = 155 ; pub const _SC_REGEX_VERSION : _bindgen_ty_30 = 156 ; pub const _SC_SHELL : _bindgen_ty_30 = 157 ; pub const _SC_SIGNALS : _bindgen_ty_30 = 158 ; pub const _SC_SPAWN : _bindgen_ty_30 = 159 ; pub const _SC_SPORADIC_SERVER : _bindgen_ty_30 = 160 ; pub const _SC_THREAD_SPORADIC_SERVER : _bindgen_ty_30 = 161 ; pub const _SC_SYSTEM_DATABASE : _bindgen_ty_30 = 162 ; pub const _SC_SYSTEM_DATABASE_R : _bindgen_ty_30 = 163 ; pub const _SC_TIMEOUTS : _bindgen_ty_30 = 164 ; pub const _SC_TYPED_MEMORY_OBJECTS : _bindgen_ty_30 = 165 ; pub const _SC_USER_GROUPS : _bindgen_ty_30 = 166 ; pub const _SC_USER_GROUPS_R : _bindgen_ty_30 = 167 ; pub const _SC_2_PBS : _bindgen_ty_30 = 168 ; pub const _SC_2_PBS_ACCOUNTING : _bindgen_ty_30 = 169 ; pub const _SC_2_PBS_LOCATE : _bindgen_ty_30 = 170 ; pub const _SC_2_PBS_MESSAGE : _bindgen_ty_30 = 171 ; pub const _SC_2_PBS_TRACK : _bindgen_ty_30 = 172 ; pub const _SC_SYMLOOP_MAX : _bindgen_ty_30 = 173 ; pub const _SC_STREAMS : _bindgen_ty_30 = 174 ; pub const _SC_2_PBS_CHECKPOINT : _bindgen_ty_30 = 175 ; pub const _SC_V6_ILP32_OFF32 : _bindgen_ty_30 = 176 ; pub const _SC_V6_ILP32_OFFBIG : _bindgen_ty_30 = 177 ; pub const _SC_V6_LP64_OFF64 : _bindgen_ty_30 = 178 ; pub const _SC_V6_LPBIG_OFFBIG : _bindgen_ty_30 = 179 ; pub const _SC_HOST_NAME_MAX : _bindgen_ty_30 = 180 ; pub const _SC_TRACE : _bindgen_ty_30 = 181 ; pub const _SC_TRACE_EVENT_FILTER : _bindgen_ty_30 = 182 ; pub const _SC_TRACE_INHERIT : _bindgen_ty_30 = 183 ; pub const _SC_TRACE_LOG : _bindgen_ty_30 = 184 ; pub const _SC_LEVEL1_ICACHE_SIZE : _bindgen_ty_30 = 185 ; pub const _SC_LEVEL1_ICACHE_ASSOC : _bindgen_ty_30 = 186 ; pub const _SC_LEVEL1_ICACHE_LINESIZE : _bindgen_ty_30 = 187 ; pub const _SC_LEVEL1_DCACHE_SIZE : _bindgen_ty_30 = 188 ; pub const _SC_LEVEL1_DCACHE_ASSOC : _bindgen_ty_30 = 189 ; pub const _SC_LEVEL1_DCACHE_LINESIZE : _bindgen_ty_30 = 190 ; pub const _SC_LEVEL2_CACHE_SIZE : _bindgen_ty_30 = 191 ; pub const _SC_LEVEL2_CACHE_ASSOC : _bindgen_ty_30 = 192 ; pub const _SC_LEVEL2_CACHE_LINESIZE : _bindgen_ty_30 = 193 ; pub const _SC_LEVEL3_CACHE_SIZE : _bindgen_ty_30 = 194 ; pub const _SC_LEVEL3_CACHE_ASSOC : _bindgen_ty_30 = 195 ; pub const _SC_LEVEL3_CACHE_LINESIZE : _bindgen_ty_30 = 196 ; pub const _SC_LEVEL4_CACHE_SIZE : _bindgen_ty_30 = 197 ; pub const _SC_LEVEL4_CACHE_ASSOC : _bindgen_ty_30 = 198 ; pub const _SC_LEVEL4_CACHE_LINESIZE : _bindgen_ty_30 = 199 ; pub const _SC_IPV6 : _bindgen_ty_30 = 235 ; pub const _SC_RAW_SOCKETS : _bindgen_ty_30 = 236 ; pub const _SC_V7_ILP32_OFF32 : _bindgen_ty_30 = 237 ; pub const _SC_V7_ILP32_OFFBIG : _bindgen_ty_30 = 238 ; pub const _SC_V7_LP64_OFF64 : _bindgen_ty_30 = 239 ; pub const _SC_V7_LPBIG_OFFBIG : _bindgen_ty_30 = 240 ; pub const _SC_SS_REPL_MAX : _bindgen_ty_30 = 241 ; pub const _SC_TRACE_EVENT_NAME_MAX : _bindgen_ty_30 = 242 ; pub const _SC_TRACE_NAME_MAX : _bindgen_ty_30 = 243 ; pub const _SC_TRACE_SYS_MAX : _bindgen_ty_30 = 244 ; pub const _SC_TRACE_USER_EVENT_MAX : _bindgen_ty_30 = 245 ; pub const _SC_XOPEN_STREAMS : _bindgen_ty_30 = 246 ; pub const _SC_THREAD_ROBUST_PRIO_INHERIT : _bindgen_ty_30 = 247 ; pub const _SC_THREAD_ROBUST_PRIO_PROTECT : _bindgen_ty_30 = 248 ; pub type _bindgen_ty_30 = u32 ; pub const _CS_PATH : _bindgen_ty_31 = 0 ; pub const _CS_V6_WIDTH_RESTRICTED_ENVS : _bindgen_ty_31 = 1 ; pub const _CS_GNU_LIBC_VERSION : _bindgen_ty_31 = 2 ; pub const _CS_GNU_LIBPTHREAD_VERSION : _bindgen_ty_31 = 3 ; pub const _CS_V5_WIDTH_RESTRICTED_ENVS : _bindgen_ty_31 = 4 ; pub const _CS_V7_WIDTH_RESTRICTED_ENVS : _bindgen_ty_31 = 5 ; pub const _CS_LFS_CFLAGS : _bindgen_ty_31 = 1000 ; pub const _CS_LFS_LDFLAGS : _bindgen_ty_31 = 1001 ; pub const _CS_LFS_LIBS : _bindgen_ty_31 = 1002 ; pub const _CS_LFS_LINTFLAGS : _bindgen_ty_31 = 1003 ; pub const _CS_LFS64_CFLAGS : _bindgen_ty_31 = 1004 ; pub const _CS_LFS64_LDFLAGS : _bindgen_ty_31 = 1005 ; pub const _CS_LFS64_LIBS : _bindgen_ty_31 = 1006 ; pub const _CS_LFS64_LINTFLAGS : _bindgen_ty_31 = 1007 ; pub const _CS_XBS5_ILP32_OFF32_CFLAGS : _bindgen_ty_31 = 1100 ; pub const _CS_XBS5_ILP32_OFF32_LDFLAGS : _bindgen_ty_31 = 1101 ; pub const _CS_XBS5_ILP32_OFF32_LIBS : _bindgen_ty_31 = 1102 ; pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS : _bindgen_ty_31 = 1103 ; pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS : _bindgen_ty_31 = 1104 ; pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1105 ; pub const _CS_XBS5_ILP32_OFFBIG_LIBS : _bindgen_ty_31 = 1106 ; pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1107 ; pub const _CS_XBS5_LP64_OFF64_CFLAGS : _bindgen_ty_31 = 1108 ; pub const _CS_XBS5_LP64_OFF64_LDFLAGS : _bindgen_ty_31 = 1109 ; pub const _CS_XBS5_LP64_OFF64_LIBS : _bindgen_ty_31 = 1110 ; pub const _CS_XBS5_LP64_OFF64_LINTFLAGS : _bindgen_ty_31 = 1111 ; pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_31 = 1112 ; pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1113 ; pub const _CS_XBS5_LPBIG_OFFBIG_LIBS : _bindgen_ty_31 = 1114 ; pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1115 ; pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS : _bindgen_ty_31 = 1116 ; pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS : _bindgen_ty_31 = 1117 ; pub const _CS_POSIX_V6_ILP32_OFF32_LIBS : _bindgen_ty_31 = 1118 ; pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS : _bindgen_ty_31 = 1119 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS : _bindgen_ty_31 = 1120 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1121 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS : _bindgen_ty_31 = 1122 ; pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1123 ; pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS : _bindgen_ty_31 = 1124 ; pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS : _bindgen_ty_31 = 1125 ; pub const _CS_POSIX_V6_LP64_OFF64_LIBS : _bindgen_ty_31 = 1126 ; pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS : _bindgen_ty_31 = 1127 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_31 = 1128 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1129 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS : _bindgen_ty_31 = 1130 ; pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1131 ; pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS : _bindgen_ty_31 = 1132 ; pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS : _bindgen_ty_31 = 1133 ; pub const _CS_POSIX_V7_ILP32_OFF32_LIBS : _bindgen_ty_31 = 1134 ; pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS : _bindgen_ty_31 = 1135 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS : _bindgen_ty_31 = 1136 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1137 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS : _bindgen_ty_31 = 1138 ; pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1139 ; pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS : _bindgen_ty_31 = 1140 ; pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS : _bindgen_ty_31 = 1141 ; pub const _CS_POSIX_V7_LP64_OFF64_LIBS : _bindgen_ty_31 = 1142 ; pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS : _bindgen_ty_31 = 1143 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS : _bindgen_ty_31 = 1144 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS : _bindgen_ty_31 = 1145 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS : _bindgen_ty_31 = 1146 ; pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS : _bindgen_ty_31 = 1147 ; pub const _CS_V6_ENV : _bindgen_ty_31 = 1148 ; pub const _CS_V7_ENV : _bindgen_ty_31 = 1149 ; pub type _bindgen_ty_31 = u32 ; extern "C" { # [ link_name = "\u{1}_Z8pathconf" ] pub fn pathconf ( __path : * const :: std :: os :: raw :: c_char , __name : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z9fpathconf" ] pub fn fpathconf ( __fd : :: std :: os :: raw :: c_int , __name : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7sysconf" ] pub fn sysconf ( __name : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z7confstr" ] pub fn confstr ( __name : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> usize ; } extern "C" { # [ link_name = "\u{1}_Z6getpid" ] pub fn getpid ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getppid" ] pub fn getppid ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getpgrp" ] pub fn getpgrp ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z9__getpgid" ] pub fn __getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getpgid" ] pub fn getpgid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7setpgid" ] pub fn setpgid ( __pid : __pid_t , __pgid : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7setpgrp" ] pub fn setpgrp ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setsid" ] pub fn setsid ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z6getsid" ] pub fn getsid ( __pid : __pid_t ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z6getuid" ] pub fn getuid ( ) -> __uid_t ; } extern "C" { # [ link_name = "\u{1}_Z7geteuid" ] pub fn geteuid ( ) -> __uid_t ; } extern "C" { # [ link_name = "\u{1}_Z6getgid" ] pub fn getgid ( ) -> __gid_t ; } extern "C" { # [ link_name = "\u{1}_Z7getegid" ] pub fn getegid ( ) -> __gid_t ; } extern "C" { # [ link_name = "\u{1}_Z9getgroups" ] pub fn getgroups ( __size : :: std :: os :: raw :: c_int , __list : * mut __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setuid" ] pub fn setuid ( __uid : __uid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8setreuid" ] pub fn setreuid ( __ruid : __uid_t , __euid : __uid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7seteuid" ] pub fn seteuid ( __uid : __uid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6setgid" ] pub fn setgid ( __gid : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8setregid" ] pub fn setregid ( __rgid : __gid_t , __egid : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7setegid" ] pub fn setegid ( __gid : __gid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4fork" ] pub fn fork ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z5vfork" ] pub fn vfork ( ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7ttyname" ] pub fn ttyname ( __fd : :: std :: os :: raw :: c_int ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z9ttyname_r" ] pub fn ttyname_r ( __fd : :: std :: os :: raw :: c_int , __buf : * mut :: std :: os :: raw :: c_char , __buflen : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6isatty" ] pub fn isatty ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7ttyslot" ] pub fn ttyslot ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4link" ] pub fn link ( __from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6linkat" ] pub fn linkat ( __fromfd : :: std :: os :: raw :: c_int , __from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7symlink" ] pub fn symlink ( __from : * const :: std :: os :: raw :: c_char , __to : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8readlink" ] pub fn readlink ( __path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z9symlinkat" ] pub fn symlinkat ( __from : * const :: std :: os :: raw :: c_char , __tofd : :: std :: os :: raw :: c_int , __to : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10readlinkat" ] pub fn readlinkat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __buf : * mut :: std :: os :: raw :: c_char , __len : usize ) -> isize ; } extern "C" { # [ link_name = "\u{1}_Z6unlink" ] pub fn unlink ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8unlinkat" ] pub fn unlinkat ( __fd : :: std :: os :: raw :: c_int , __name : * const :: std :: os :: raw :: c_char , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5rmdir" ] pub fn rmdir ( __path : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9tcgetpgrp" ] pub fn tcgetpgrp ( __fd : :: std :: os :: raw :: c_int ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z9tcsetpgrp" ] pub fn tcsetpgrp ( __fd : :: std :: os :: raw :: c_int , __pgrp_id : __pid_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8getlogin" ] pub fn getlogin ( ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z10getlogin_r" ] pub fn getlogin_r ( __name : * mut :: std :: os :: raw :: c_char , __name_len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8setlogin" ] pub fn setlogin ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6getopt" ] pub fn getopt ( ___argc : :: std :: os :: raw :: c_int , ___argv : * const * mut :: std :: os :: raw :: c_char , __shortopts : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11gethostname" ] pub fn gethostname ( __name : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11sethostname" ] pub fn sethostname ( __name : * const :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9sethostid" ] pub fn sethostid ( __id : :: std :: os :: raw :: c_long ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getdomainname" ] pub fn getdomainname ( __name : * mut :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13setdomainname" ] pub fn setdomainname ( __name : * const :: std :: os :: raw :: c_char , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7vhangup" ] pub fn vhangup ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6revoke" ] pub fn revoke ( __file : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6profil" ] pub fn profil ( __sample_buffer : * mut :: std :: os :: raw :: c_ushort , __size : usize , __offset : usize , __scale : :: std :: os :: raw :: c_uint ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4acct" ] pub fn acct ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z12getusershell" ] pub fn getusershell ( ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z12endusershell" ] pub fn endusershell ( ) ; } extern "C" { # [ link_name = "\u{1}_Z12setusershell" ] pub fn setusershell ( ) ; } extern "C" { # [ link_name = "\u{1}_Z6daemon" ] pub fn daemon ( __nochdir : :: std :: os :: raw :: c_int , __noclose : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6chroot" ] pub fn chroot ( __path : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7getpass" ] pub fn getpass ( __prompt : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z5fsync" ] pub fn fsync ( __fd : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9gethostid" ] pub fn gethostid ( ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z4sync" ] pub fn sync ( ) ; } extern "C" { # [ link_name = "\u{1}_Z11getpagesize" ] pub fn getpagesize ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13getdtablesize" ] pub fn getdtablesize ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8truncate" ] pub fn truncate ( __file : * const :: std :: os :: raw :: c_char , __length : __off_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9ftruncate" ] pub fn ftruncate ( __fd : :: std :: os :: raw :: c_int , __length : __off_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z3brk" ] pub fn brk ( __addr : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4sbrk" ] pub fn sbrk ( __delta : isize ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z7syscall" ] pub fn syscall ( __sysno : :: std :: os :: raw :: c_long , ... ) -> :: std :: os :: raw :: c_long ; } extern "C" { # [ link_name = "\u{1}_Z9fdatasync" ] pub fn fdatasync ( __fildes : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct if_nameindex { pub if_index : :: std :: os :: raw :: c_uint , pub if_name : * mut :: std :: os :: raw :: c_char , } # [ test ] fn bindgen_test_layout_if_nameindex ( ) { assert_eq ! ( :: std :: mem :: size_of :: < if_nameindex > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( if_nameindex ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < if_nameindex > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( if_nameindex ) ) ) ; } impl Default for if_nameindex { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const IFF_UP : _bindgen_ty_32 = 1 ; pub const IFF_BROADCAST : _bindgen_ty_32 = 2 ; pub const IFF_DEBUG : _bindgen_ty_32 = 4 ; pub const IFF_LOOPBACK : _bindgen_ty_32 = 8 ; pub const IFF_POINTOPOINT : _bindgen_ty_32 = 16 ; pub const IFF_NOTRAILERS : _bindgen_ty_32 = 32 ; pub const IFF_RUNNING : _bindgen_ty_32 = 64 ; pub const IFF_NOARP : _bindgen_ty_32 = 128 ; pub const IFF_PROMISC : _bindgen_ty_32 = 256 ; pub const IFF_ALLMULTI : _bindgen_ty_32 = 512 ; pub const IFF_MASTER : _bindgen_ty_32 = 1024 ; pub const IFF_SLAVE : _bindgen_ty_32 = 2048 ; pub const IFF_MULTICAST : _bindgen_ty_32 = 4096 ; pub const IFF_PORTSEL : _bindgen_ty_32 = 8192 ; pub const IFF_AUTOMEDIA : _bindgen_ty_32 = 16384 ; pub const IFF_DYNAMIC : _bindgen_ty_32 = 32768 ; pub type _bindgen_ty_32 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifaddr { pub ifa_addr : sockaddr , pub ifa_ifu : ifaddr__bindgen_ty_1 , pub ifa_ifp : * mut iface , pub ifa_next : * mut ifaddr , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifaddr__bindgen_ty_1 { pub ifu_broadaddr : sockaddr , pub ifu_dstaddr : sockaddr , _bindgen_union_align : [ u16 ; 8usize ] , } # [ test ] fn bindgen_test_layout_ifaddr__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddr__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ifaddr__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddr__bindgen_ty_1 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( ifaddr__bindgen_ty_1 ) ) ) ; } impl Default for ifaddr__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifaddr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifaddr > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( ifaddr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifaddr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifaddr ) ) ) ; } impl Default for ifaddr { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct ifmap { pub mem_start : :: std :: os :: raw :: c_ulong , pub mem_end : :: std :: os :: raw :: c_ulong , pub base_addr : :: std :: os :: raw :: c_ushort , pub irq : :: std :: os :: raw :: c_uchar , pub dma : :: std :: os :: raw :: c_uchar , pub port : :: std :: os :: raw :: c_uchar , } # [ test ] fn bindgen_test_layout_ifmap ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifmap > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( ifmap ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifmap > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifmap ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifreq { pub ifr_ifrn : ifreq__bindgen_ty_1 , pub ifr_ifru : ifreq__bindgen_ty_2 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_1 { pub ifrn_name : [ :: std :: os :: raw :: c_char ; 16usize ] , _bindgen_union_align : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_ifreq__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifreq__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifreq__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( ifreq__bindgen_ty_1 ) ) ) ; } impl Default for ifreq__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifreq__bindgen_ty_2 { pub ifru_addr : sockaddr , pub ifru_dstaddr : sockaddr , pub ifru_broadaddr : sockaddr , pub ifru_netmask : sockaddr , pub ifru_hwaddr : sockaddr , pub ifru_flags : :: std :: os :: raw :: c_short , pub ifru_ivalue : :: std :: os :: raw :: c_int , pub ifru_mtu : :: std :: os :: raw :: c_int , pub ifru_map : ifmap , pub ifru_slave : [ :: std :: os :: raw :: c_char ; 16usize ] , pub ifru_newname : [ :: std :: os :: raw :: c_char ; 16usize ] , pub ifru_data : __caddr_t , _bindgen_union_align : [ u64 ; 3usize ] , } # [ test ] fn bindgen_test_layout_ifreq__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifreq__bindgen_ty_2 > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifreq__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifreq__bindgen_ty_2 ) ) ) ; } impl Default for ifreq__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifreq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifreq > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( ifreq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifreq > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifreq ) ) ) ; } impl Default for ifreq { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct ifconf { pub ifc_len : :: std :: os :: raw :: c_int , pub ifc_ifcu : ifconf__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union ifconf__bindgen_ty_1 { pub ifcu_buf : __caddr_t , pub ifcu_req : * mut ifreq , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_ifconf__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifconf__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( ifconf__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifconf__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifconf__bindgen_ty_1 ) ) ) ; } impl Default for ifconf__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_ifconf ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ifconf > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ifconf ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ifconf > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ifconf ) ) ) ; } impl Default for ifconf { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z14if_nametoindex" ] pub fn if_nametoindex ( __ifname : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_uint ; } extern "C" { # [ link_name = "\u{1}_Z14if_indextoname" ] pub fn if_indextoname ( __ifindex : :: std :: os :: raw :: c_uint , __ifname : * mut :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z12if_nameindex" ] pub fn if_nameindex ( ) -> * mut if_nameindex ; } extern "C" { # [ link_name = "\u{1}_Z16if_freenameindex" ] pub fn if_freenameindex ( __ptr : * mut if_nameindex ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcphdr { pub source : u_int16_t , pub dest : u_int16_t , pub seq : u_int32_t , pub ack_seq : u_int32_t , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub window : u_int16_t , pub check : u_int16_t , pub urg_ptr : u_int16_t , } # [ test ] fn bindgen_test_layout_tcphdr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcphdr > ( ) , 20usize , concat ! ( "Size of: " , stringify ! ( tcphdr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcphdr > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( tcphdr ) ) ) ; } impl tcphdr { # [ inline ] pub fn res1 ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_res1 ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn doff ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_doff ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn fin ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_fin ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn syn ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_syn ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rst ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_rst ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn psh ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_psh ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ack ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ack ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 1u8 , val as u64 ) } } # [ inline ] pub fn urg ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 13usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_urg ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 13usize , 1u8 , val as u64 ) } } # [ inline ] pub fn res2 ( & self ) -> u_int16_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_res2 ( & mut self , val : u_int16_t ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( res1 : u_int16_t , doff : u_int16_t , fin : u_int16_t , syn : u_int16_t , rst : u_int16_t , psh : u_int16_t , ack : u_int16_t , urg : u_int16_t , res2 : u_int16_t ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let res1 : u16 = unsafe { :: std :: mem :: transmute ( res1 ) } ; res1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let doff : u16 = unsafe { :: std :: mem :: transmute ( doff ) } ; doff as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let fin : u16 = unsafe { :: std :: mem :: transmute ( fin ) } ; fin as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let syn : u16 = unsafe { :: std :: mem :: transmute ( syn ) } ; syn as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let rst : u16 = unsafe { :: std :: mem :: transmute ( rst ) } ; rst as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 1u8 , { let psh : u16 = unsafe { :: std :: mem :: transmute ( psh ) } ; psh as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 1u8 , { let ack : u16 = unsafe { :: std :: mem :: transmute ( ack ) } ; ack as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 1u8 , { let urg : u16 = unsafe { :: std :: mem :: transmute ( urg ) } ; urg as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let res2 : u16 = unsafe { :: std :: mem :: transmute ( res2 ) } ; res2 as u64 } ) ; __bindgen_bitfield_unit } } pub const TCP_ESTABLISHED : _bindgen_ty_33 = 1 ; pub const TCP_SYN_SENT : _bindgen_ty_33 = 2 ; pub const TCP_SYN_RECV : _bindgen_ty_33 = 3 ; pub const TCP_FIN_WAIT1 : _bindgen_ty_33 = 4 ; pub const TCP_FIN_WAIT2 : _bindgen_ty_33 = 5 ; pub const TCP_TIME_WAIT : _bindgen_ty_33 = 6 ; pub const TCP_CLOSE : _bindgen_ty_33 = 7 ; pub const TCP_CLOSE_WAIT : _bindgen_ty_33 = 8 ; pub const TCP_LAST_ACK : _bindgen_ty_33 = 9 ; pub const TCP_LISTEN : _bindgen_ty_33 = 10 ; pub const TCP_CLOSING : _bindgen_ty_33 = 11 ; pub type _bindgen_ty_33 = u32 ; pub const tcp_ca_state_TCP_CA_Open : tcp_ca_state = 0 ; pub const tcp_ca_state_TCP_CA_Disorder : tcp_ca_state = 1 ; pub const tcp_ca_state_TCP_CA_CWR : tcp_ca_state = 2 ; pub const tcp_ca_state_TCP_CA_Recovery : tcp_ca_state = 3 ; pub const tcp_ca_state_TCP_CA_Loss : tcp_ca_state = 4 ; pub type tcp_ca_state = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_info { pub tcpi_state : u_int8_t , pub tcpi_ca_state : u_int8_t , pub tcpi_retransmits : u_int8_t , pub tcpi_probes : u_int8_t , pub tcpi_backoff : u_int8_t , pub tcpi_options : u_int8_t , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub tcpi_rto : u_int32_t , pub tcpi_ato : u_int32_t , pub tcpi_snd_mss : u_int32_t , pub tcpi_rcv_mss : u_int32_t , pub tcpi_unacked : u_int32_t , pub tcpi_sacked : u_int32_t , pub tcpi_lost : u_int32_t , pub tcpi_retrans : u_int32_t , pub tcpi_fackets : u_int32_t , pub tcpi_last_data_sent : u_int32_t , pub tcpi_last_ack_sent : u_int32_t , pub tcpi_last_data_recv : u_int32_t , pub tcpi_last_ack_recv : u_int32_t , pub tcpi_pmtu : u_int32_t , pub tcpi_rcv_ssthresh : u_int32_t , pub tcpi_rtt : u_int32_t , pub tcpi_rttvar : u_int32_t , pub tcpi_snd_ssthresh : u_int32_t , pub tcpi_snd_cwnd : u_int32_t , pub tcpi_advmss : u_int32_t , pub tcpi_reordering : u_int32_t , pub tcpi_rcv_rtt : u_int32_t , pub tcpi_rcv_space : u_int32_t , pub tcpi_total_retrans : u_int32_t , } # [ test ] fn bindgen_test_layout_tcp_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_info > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( tcp_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_info > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( tcp_info ) ) ) ; } impl tcp_info { # [ inline ] pub fn tcpi_snd_wscale ( & self ) -> u_int8_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_snd_wscale ( & mut self , val : u_int8_t ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn tcpi_rcv_wscale ( & self ) -> u_int8_t { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_tcpi_rcv_wscale ( & mut self , val : u_int8_t ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tcpi_snd_wscale : u_int8_t , tcpi_rcv_wscale : u_int8_t ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let tcpi_snd_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_snd_wscale ) } ; tcpi_snd_wscale as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let tcpi_rcv_wscale : u8 = unsafe { :: std :: mem :: transmute ( tcpi_rcv_wscale ) } ; tcpi_rcv_wscale as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_md5sig { pub tcpm_addr : sockaddr_storage , pub __tcpm_pad1 : u_int16_t , pub tcpm_keylen : u_int16_t , pub __tcpm_pad2 : u_int32_t , pub tcpm_key : [ u_int8_t ; 80usize ] , } # [ test ] fn bindgen_test_layout_tcp_md5sig ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_md5sig > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( tcp_md5sig ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_md5sig > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( tcp_md5sig ) ) ) ; } impl Default for tcp_md5sig { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct tcp_repair_opt { pub opt_code : u_int32_t , pub opt_val : u_int32_t , } # [ test ] fn bindgen_test_layout_tcp_repair_opt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_repair_opt > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( tcp_repair_opt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_repair_opt > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( tcp_repair_opt ) ) ) ; } pub const TCP_NO_QUEUE : _bindgen_ty_34 = 0 ; pub const TCP_RECV_QUEUE : _bindgen_ty_34 = 1 ; pub const TCP_SEND_QUEUE : _bindgen_ty_34 = 2 ; pub const TCP_QUEUES_NR : _bindgen_ty_34 = 3 ; pub type _bindgen_ty_34 = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct tcp_cookie_transactions { pub tcpct_flags : u_int16_t , pub __tcpct_pad1 : u_int8_t , pub tcpct_cookie_desired : u_int8_t , pub tcpct_s_data_desired : u_int16_t , pub tcpct_used : u_int16_t , pub tcpct_value : [ u_int8_t ; 536usize ] , } # [ test ] fn bindgen_test_layout_tcp_cookie_transactions ( ) { assert_eq ! ( :: std :: mem :: size_of :: < tcp_cookie_transactions > ( ) , 544usize , concat ! ( "Size of: " , stringify ! ( tcp_cookie_transactions ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < tcp_cookie_transactions > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( tcp_cookie_transactions ) ) ) ; } impl Default for tcp_cookie_transactions { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct winsize { pub ws_row : :: std :: os :: raw :: c_ushort , pub ws_col : :: std :: os :: raw :: c_ushort , pub ws_xpixel : :: std :: os :: raw :: c_ushort , pub ws_ypixel : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout_winsize ( ) { assert_eq ! ( :: std :: mem :: size_of :: < winsize > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( winsize ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < winsize > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( winsize ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct termio { pub c_iflag : :: std :: os :: raw :: c_ushort , pub c_oflag : :: std :: os :: raw :: c_ushort , pub c_cflag : :: std :: os :: raw :: c_ushort , pub c_lflag : :: std :: os :: raw :: c_ushort , pub c_line : :: std :: os :: raw :: c_uchar , pub c_cc : [ :: std :: os :: raw :: c_uchar ; 8usize ] , } # [ test ] fn bindgen_test_layout_termio ( ) { assert_eq ! ( :: std :: mem :: size_of :: < termio > ( ) , 18usize , concat ! ( "Size of: " , stringify ! ( termio ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < termio > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( termio ) ) ) ; } extern "C" { # [ link_name = "\u{1}_Z5ioctl" ] pub fn ioctl ( __fd : :: std :: os :: raw :: c_int , __request : :: std :: os :: raw :: c_ulong , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4mmap" ] pub fn mmap ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __prot : :: std :: os :: raw :: c_int , __flags : :: std :: os :: raw :: c_int , __fd : :: std :: os :: raw :: c_int , __offset : __off_t ) -> * mut :: std :: os :: raw :: c_void ; } extern "C" { # [ link_name = "\u{1}_Z6munmap" ] pub fn munmap ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mprotect" ] pub fn mprotect ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __prot : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5msync" ] pub fn msync ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7madvise" ] pub fn madvise ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __advice : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z13posix_madvise" ] pub fn posix_madvise ( __addr : * mut :: std :: os :: raw :: c_void , __len : usize , __advice : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5mlock" ] pub fn mlock ( __addr : * const :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7munlock" ] pub fn munlock ( __addr : * const :: std :: os :: raw :: c_void , __len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mlockall" ] pub fn mlockall ( __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10munlockall" ] pub fn munlockall ( ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mincore" ] pub fn mincore ( __start : * mut :: std :: os :: raw :: c_void , __len : usize , __vec : * mut :: std :: os :: raw :: c_uchar ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8shm_open" ] pub fn shm_open ( __name : * const :: std :: os :: raw :: c_char , __oflag : :: std :: os :: raw :: c_int , __mode : mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10shm_unlink" ] pub fn shm_unlink ( __name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } pub const __rlimit_resource_RLIMIT_CPU : __rlimit_resource = 0 ; pub const __rlimit_resource_RLIMIT_FSIZE : __rlimit_resource = 1 ; pub const __rlimit_resource_RLIMIT_DATA : __rlimit_resource = 2 ; pub const __rlimit_resource_RLIMIT_STACK : __rlimit_resource = 3 ; pub const __rlimit_resource_RLIMIT_CORE : __rlimit_resource = 4 ; pub const __rlimit_resource___RLIMIT_RSS : __rlimit_resource = 5 ; pub const __rlimit_resource_RLIMIT_NOFILE : __rlimit_resource = 7 ; pub const __rlimit_resource___RLIMIT_OFILE : __rlimit_resource = 7 ; pub const __rlimit_resource_RLIMIT_AS : __rlimit_resource = 9 ; pub const __rlimit_resource___RLIMIT_NPROC : __rlimit_resource = 6 ; pub const __rlimit_resource___RLIMIT_MEMLOCK : __rlimit_resource = 8 ; pub const __rlimit_resource___RLIMIT_LOCKS : __rlimit_resource = 10 ; pub const __rlimit_resource___RLIMIT_SIGPENDING : __rlimit_resource = 11 ; pub const __rlimit_resource___RLIMIT_MSGQUEUE : __rlimit_resource = 12 ; pub const __rlimit_resource___RLIMIT_NICE : __rlimit_resource = 13 ; pub const __rlimit_resource___RLIMIT_RTPRIO : __rlimit_resource = 14 ; pub const __rlimit_resource___RLIMIT_RTTIME : __rlimit_resource = 15 ; pub const __rlimit_resource___RLIMIT_NLIMITS : __rlimit_resource = 16 ; pub const __rlimit_resource___RLIM_NLIMITS : __rlimit_resource = 16 ; pub type __rlimit_resource = u32 ; pub type rlim_t = __rlim_t ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct rlimit { pub rlim_cur : rlim_t , pub rlim_max : rlim_t , } # [ test ] fn bindgen_test_layout_rlimit ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rlimit > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( rlimit ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rlimit > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rlimit ) ) ) ; } pub const __rusage_who_RUSAGE_SELF : __rusage_who = 0 ; pub const __rusage_who_RUSAGE_CHILDREN : __rusage_who = -1 ; pub type __rusage_who = i32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct rusage { pub ru_utime : timeval , pub ru_stime : timeval , pub __bindgen_anon_1 : rusage__bindgen_ty_1 , pub __bindgen_anon_2 : rusage__bindgen_ty_2 , pub __bindgen_anon_3 : rusage__bindgen_ty_3 , pub __bindgen_anon_4 : rusage__bindgen_ty_4 , pub __bindgen_anon_5 : rusage__bindgen_ty_5 , pub __bindgen_anon_6 : rusage__bindgen_ty_6 , pub __bindgen_anon_7 : rusage__bindgen_ty_7 , pub __bindgen_anon_8 : rusage__bindgen_ty_8 , pub __bindgen_anon_9 : rusage__bindgen_ty_9 , pub __bindgen_anon_10 : rusage__bindgen_ty_10 , pub __bindgen_anon_11 : rusage__bindgen_ty_11 , pub __bindgen_anon_12 : rusage__bindgen_ty_12 , pub __bindgen_anon_13 : rusage__bindgen_ty_13 , pub __bindgen_anon_14 : rusage__bindgen_ty_14 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_1 { pub ru_maxrss : :: std :: os :: raw :: c_long , pub __ru_maxrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_1 ) ) ) ; } impl Default for rusage__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_2 { pub ru_ixrss : :: std :: os :: raw :: c_long , pub __ru_ixrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_2 ) ) ) ; } impl Default for rusage__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_3 { pub ru_idrss : :: std :: os :: raw :: c_long , pub __ru_idrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_3 ) ) ) ; } impl Default for rusage__bindgen_ty_3 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_4 { pub ru_isrss : :: std :: os :: raw :: c_long , pub __ru_isrss_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_4 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_4 ) ) ) ; } impl Default for rusage__bindgen_ty_4 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_5 { pub ru_minflt : :: std :: os :: raw :: c_long , pub __ru_minflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_5 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_5 ) ) ) ; } impl Default for rusage__bindgen_ty_5 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_6 { pub ru_majflt : :: std :: os :: raw :: c_long , pub __ru_majflt_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_6 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_6 ) ) ) ; } impl Default for rusage__bindgen_ty_6 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_7 { pub ru_nswap : :: std :: os :: raw :: c_long , pub __ru_nswap_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_7 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_7 ) ) ) ; } impl Default for rusage__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_8 { pub ru_inblock : :: std :: os :: raw :: c_long , pub __ru_inblock_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_8 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_8 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_8 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_8 ) ) ) ; } impl Default for rusage__bindgen_ty_8 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_9 { pub ru_oublock : :: std :: os :: raw :: c_long , pub __ru_oublock_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_9 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_9 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_9 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_9 ) ) ) ; } impl Default for rusage__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_10 { pub ru_msgsnd : :: std :: os :: raw :: c_long , pub __ru_msgsnd_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_10 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_10 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_10 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_10 ) ) ) ; } impl Default for rusage__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_11 { pub ru_msgrcv : :: std :: os :: raw :: c_long , pub __ru_msgrcv_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_11 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_11 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_11 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_11 ) ) ) ; } impl Default for rusage__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_12 { pub ru_nsignals : :: std :: os :: raw :: c_long , pub __ru_nsignals_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_12 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_12 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_12 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_12 ) ) ) ; } impl Default for rusage__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_13 { pub ru_nvcsw : :: std :: os :: raw :: c_long , pub __ru_nvcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_13 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_13 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_13 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_13 ) ) ) ; } impl Default for rusage__bindgen_ty_13 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union rusage__bindgen_ty_14 { pub ru_nivcsw : :: std :: os :: raw :: c_long , pub __ru_nivcsw_word : __syscall_slong_t , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_rusage__bindgen_ty_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage__bindgen_ty_14 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( rusage__bindgen_ty_14 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage__bindgen_ty_14 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage__bindgen_ty_14 ) ) ) ; } impl Default for rusage__bindgen_ty_14 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_rusage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( rusage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage ) ) ) ; } impl Default for rusage { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const __priority_which_PRIO_PROCESS : __priority_which = 0 ; pub const __priority_which_PRIO_PGRP : __priority_which = 1 ; pub const __priority_which_PRIO_USER : __priority_which = 2 ; pub type __priority_which = u32 ; pub type __rlimit_resource_t = :: std :: os :: raw :: c_int ; pub type __rusage_who_t = :: std :: os :: raw :: c_int ; pub type __priority_which_t = :: std :: os :: raw :: c_int ; extern "C" { # [ link_name = "\u{1}_Z9getrlimit" ] pub fn getrlimit ( __resource : __rlimit_resource_t , __rlimits : * mut rlimit ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9setrlimit" ] pub fn setrlimit ( __resource : __rlimit_resource_t , __rlimits : * const rlimit ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9getrusage" ] pub fn getrusage ( __who : __rusage_who_t , __usage : * mut rusage ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11getpriority" ] pub fn getpriority ( __which : __priority_which_t , __who : id_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z11setpriority" ] pub fn setpriority ( __which : __priority_which_t , __who : id_t , __prio : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z4stat" ] pub fn stat ( __file : * const :: std :: os :: raw :: c_char , __buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5fstat" ] pub fn fstat ( __fd : :: std :: os :: raw :: c_int , __buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7fstatat" ] pub fn fstatat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __buf : * mut stat , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5lstat" ] pub fn lstat ( __file : * const :: std :: os :: raw :: c_char , __buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5chmod" ] pub fn chmod ( __file : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6lchmod" ] pub fn lchmod ( __file : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6fchmod" ] pub fn fchmod ( __fd : :: std :: os :: raw :: c_int , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8fchmodat" ] pub fn fchmodat ( __fd : :: std :: os :: raw :: c_int , __file : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5umask" ] pub fn umask ( __mask : __mode_t ) -> __mode_t ; } extern "C" { # [ link_name = "\u{1}_Z5mkdir" ] pub fn mkdir ( __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mkdirat" ] pub fn mkdirat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5mknod" ] pub fn mknod ( __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : __dev_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7mknodat" ] pub fn mknodat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : __dev_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z6mkfifo" ] pub fn mkfifo ( __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8mkfifoat" ] pub fn mkfifoat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z9utimensat" ] pub fn utimensat ( __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __times : * const timespec , __flags : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8futimens" ] pub fn futimens ( __fd : :: std :: os :: raw :: c_int , __times : * const timespec ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8__fxstat" ] pub fn __fxstat ( __ver : :: std :: os :: raw :: c_int , __fildes : :: std :: os :: raw :: c_int , __stat_buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z7__xstat" ] pub fn __xstat ( __ver : :: std :: os :: raw :: c_int , __filename : * const :: std :: os :: raw :: c_char , __stat_buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8__lxstat" ] pub fn __lxstat ( __ver : :: std :: os :: raw :: c_int , __filename : * const :: std :: os :: raw :: c_char , __stat_buf : * mut stat ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10__fxstatat" ] pub fn __fxstatat ( __ver : :: std :: os :: raw :: c_int , __fildes : :: std :: os :: raw :: c_int , __filename : * const :: std :: os :: raw :: c_char , __stat_buf : * mut stat , __flag : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z8__xmknod" ] pub fn __xmknod ( __ver : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z10__xmknodat" ] pub fn __xmknodat ( __ver : :: std :: os :: raw :: c_int , __fd : :: std :: os :: raw :: c_int , __path : * const :: std :: os :: raw :: c_char , __mode : __mode_t , __dev : * mut __dev_t ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sockaddr_un { pub sun_family : sa_family_t , pub sun_path : [ :: std :: os :: raw :: c_char ; 108usize ] , } # [ test ] fn bindgen_test_layout_sockaddr_un ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sockaddr_un > ( ) , 110usize , concat ! ( "Size of: " , stringify ! ( sockaddr_un ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sockaddr_un > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( sockaddr_un ) ) ) ; } impl Default for sockaddr_un { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user_fpregs_struct { pub cwd : :: std :: os :: raw :: c_ushort , pub swd : :: std :: os :: raw :: c_ushort , pub ftw : :: std :: os :: raw :: c_ushort , pub fop : :: std :: os :: raw :: c_ushort , pub rip : :: std :: os :: raw :: c_ulonglong , pub rdp : :: std :: os :: raw :: c_ulonglong , pub mxcsr : :: std :: os :: raw :: c_uint , pub mxcr_mask : :: std :: os :: raw :: c_uint , pub st_space : [ :: std :: os :: raw :: c_uint ; 32usize ] , pub xmm_space : [ :: std :: os :: raw :: c_uint ; 64usize ] , pub padding : [ :: std :: os :: raw :: c_uint ; 24usize ] , } # [ test ] fn bindgen_test_layout_user_fpregs_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user_fpregs_struct > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( user_fpregs_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user_fpregs_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user_fpregs_struct ) ) ) ; } impl Default for user_fpregs_struct { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct user_regs_struct { pub r15 : :: std :: os :: raw :: c_ulonglong , pub r14 : :: std :: os :: raw :: c_ulonglong , pub r13 : :: std :: os :: raw :: c_ulonglong , pub r12 : :: std :: os :: raw :: c_ulonglong , pub rbp : :: std :: os :: raw :: c_ulonglong , pub rbx : :: std :: os :: raw :: c_ulonglong , pub r11 : :: std :: os :: raw :: c_ulonglong , pub r10 : :: std :: os :: raw :: c_ulonglong , pub r9 : :: std :: os :: raw :: c_ulonglong , pub r8 : :: std :: os :: raw :: c_ulonglong , pub rax : :: std :: os :: raw :: c_ulonglong , pub rcx : :: std :: os :: raw :: c_ulonglong , pub rdx : :: std :: os :: raw :: c_ulonglong , pub rsi : :: std :: os :: raw :: c_ulonglong , pub rdi : :: std :: os :: raw :: c_ulonglong , pub orig_rax : :: std :: os :: raw :: c_ulonglong , pub rip : :: std :: os :: raw :: c_ulonglong , pub cs : :: std :: os :: raw :: c_ulonglong , pub eflags : :: std :: os :: raw :: c_ulonglong , pub rsp : :: std :: os :: raw :: c_ulonglong , pub ss : :: std :: os :: raw :: c_ulonglong , pub fs_base : :: std :: os :: raw :: c_ulonglong , pub gs_base : :: std :: os :: raw :: c_ulonglong , pub ds : :: std :: os :: raw :: c_ulonglong , pub es : :: std :: os :: raw :: c_ulonglong , pub fs : :: std :: os :: raw :: c_ulonglong , pub gs : :: std :: os :: raw :: c_ulonglong , } # [ test ] fn bindgen_test_layout_user_regs_struct ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user_regs_struct > ( ) , 216usize , concat ! ( "Size of: " , stringify ! ( user_regs_struct ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user_regs_struct > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user_regs_struct ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct user { pub regs : user_regs_struct , pub u_fpvalid : :: std :: os :: raw :: c_int , pub i387 : user_fpregs_struct , pub u_tsize : :: std :: os :: raw :: c_ulonglong , pub u_dsize : :: std :: os :: raw :: c_ulonglong , pub u_ssize : :: std :: os :: raw :: c_ulonglong , pub start_code : :: std :: os :: raw :: c_ulonglong , pub start_stack : :: std :: os :: raw :: c_ulonglong , pub signal : :: std :: os :: raw :: c_longlong , pub reserved : :: std :: os :: raw :: c_int , pub __bindgen_anon_1 : user__bindgen_ty_1 , pub __bindgen_anon_2 : user__bindgen_ty_2 , pub magic : :: std :: os :: raw :: c_ulonglong , pub u_comm : [ :: std :: os :: raw :: c_char ; 32usize ] , pub u_debugreg : [ :: std :: os :: raw :: c_ulonglong ; 8usize ] , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_1 { pub u_ar0 : * mut user_regs_struct , pub __u_ar0_word : :: std :: os :: raw :: c_ulonglong , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_user__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( user__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user__bindgen_ty_1 ) ) ) ; } impl Default for user__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union user__bindgen_ty_2 { pub u_fpstate : * mut user_fpregs_struct , pub __u_fpstate_word : :: std :: os :: raw :: c_ulonglong , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_user__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( user__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user__bindgen_ty_2 ) ) ) ; } impl Default for user__bindgen_ty_2 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_user ( ) { assert_eq ! ( :: std :: mem :: size_of :: < user > ( ) , 912usize , concat ! ( "Size of: " , stringify ! ( user ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < user > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( user ) ) ) ; } impl Default for user { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = u32 ; extern "C" { # [ link_name = "\u{1}_Z4wait" ] pub fn wait ( __stat_loc : __WAIT_STATUS ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z7waitpid" ] pub fn waitpid ( __pid : __pid_t , __stat_loc : * mut :: std :: os :: raw :: c_int , __options : :: std :: os :: raw :: c_int ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z6waitid" ] pub fn waitid ( __idtype : idtype_t , __id : __id_t , __infop : * mut siginfo_t , __options : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z5wait3" ] pub fn wait3 ( __stat_loc : __WAIT_STATUS , __options : :: std :: os :: raw :: c_int , __usage : * mut rusage ) -> __pid_t ; } extern "C" { # [ link_name = "\u{1}_Z5wait4" ] pub fn wait4 ( __pid : __pid_t , __stat_loc : __WAIT_STATUS , __options : :: std :: os :: raw :: c_int , __usage : * mut rusage ) -> __pid_t ; } pub const spdk_scsi_group_code_SPDK_SCSI_6BYTE_CMD : spdk_scsi_group_code = 0 ; pub const spdk_scsi_group_code_SPDK_SCSI_10BYTE_CMD : spdk_scsi_group_code = 32 ; pub const spdk_scsi_group_code_SPDK_SCSI_10BYTE_CMD2 : spdk_scsi_group_code = 64 ; pub const spdk_scsi_group_code_SPDK_SCSI_16BYTE_CMD : spdk_scsi_group_code = 128 ; pub const spdk_scsi_group_code_SPDK_SCSI_12BYTE_CMD : spdk_scsi_group_code = 160 ; pub type spdk_scsi_group_code = u32 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_GOOD : spdk_scsi_status = 0 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_CHECK_CONDITION : spdk_scsi_status = 2 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_CONDITION_MET : spdk_scsi_status = 4 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_BUSY : spdk_scsi_status = 8 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_INTERMEDIATE : spdk_scsi_status = 16 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_INTERMEDIATE_CONDITION_MET : spdk_scsi_status = 20 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_RESERVATION_CONFLICT : spdk_scsi_status = 24 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_Obsolete : spdk_scsi_status = 34 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_TASK_SET_FULL : spdk_scsi_status = 40 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_ACA_ACTIVE : spdk_scsi_status = 48 ; pub const spdk_scsi_status_SPDK_SCSI_STATUS_TASK_ABORTED : spdk_scsi_status = 64 ; pub type spdk_scsi_status = u32 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_NO_SENSE : spdk_scsi_sense = 0 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_RECOVERED_ERROR : spdk_scsi_sense = 1 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_NOT_READY : spdk_scsi_sense = 2 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_MEDIUM_ERROR : spdk_scsi_sense = 3 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_HARDWARE_ERROR : spdk_scsi_sense = 4 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_ILLEGAL_REQUEST : spdk_scsi_sense = 5 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_UNIT_ATTENTION : spdk_scsi_sense = 6 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_DATA_PROTECT : spdk_scsi_sense = 7 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_BLANK_CHECK : spdk_scsi_sense = 8 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_VENDOR_SPECIFIC : spdk_scsi_sense = 9 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_COPY_ABORTED : spdk_scsi_sense = 10 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_ABORTED_COMMAND : spdk_scsi_sense = 11 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_VOLUME_OVERFLOW : spdk_scsi_sense = 13 ; pub const spdk_scsi_sense_SPDK_SCSI_SENSE_MISCOMPARE : spdk_scsi_sense = 14 ; pub type spdk_scsi_sense = u32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_NO_ADDITIONAL_SENSE : spdk_scsi_asc = 0 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_PERIPHERAL_DEVICE_WRITE_FAULT : spdk_scsi_asc = 3 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_UNIT_NOT_READY : spdk_scsi_asc = 4 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_WARNING : spdk_scsi_asc = 11 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_GUARD_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED : spdk_scsi_asc = 16 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_UNRECOVERED_READ_ERROR : spdk_scsi_asc = 17 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_MISCOMPARE_DURING_VERIFY_OPERATION : spdk_scsi_asc = 29 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INVALID_COMMAND_OPERATION_CODE : spdk_scsi_asc = 32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_ACCESS_DENIED : spdk_scsi_asc = 32 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE : spdk_scsi_asc = 33 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INVALID_FIELD_IN_CDB : spdk_scsi_asc = 36 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED : spdk_scsi_asc = 37 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_WRITE_PROTECTED : spdk_scsi_asc = 39 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_FORMAT_COMMAND_FAILED : spdk_scsi_asc = 49 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_SAVING_PARAMETERS_NOT_SUPPORTED : spdk_scsi_asc = 57 ; pub const spdk_scsi_asc_SPDK_SCSI_ASC_INTERNAL_TARGET_FAILURE : spdk_scsi_asc = 68 ; pub type spdk_scsi_asc = u32 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_CAUSE_NOT_REPORTABLE : spdk_scsi_ascq = 0 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_BECOMING_READY : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_FORMAT_COMMAND_FAILED : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_GUARD_CHECK_FAILED : spdk_scsi_ascq = 1 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED : spdk_scsi_ascq = 2 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_NO_ACCESS_RIGHTS : spdk_scsi_ascq = 2 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED : spdk_scsi_ascq = 3 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_POWER_LOSS_EXPECTED : spdk_scsi_ascq = 8 ; pub const spdk_scsi_ascq_SPDK_SCSI_ASCQ_INVALID_LU_IDENTIFIER : spdk_scsi_ascq = 9 ; pub type spdk_scsi_ascq = u32 ; pub const spdk_spc_opcode_SPDK_SPC_ACCESS_CONTROL_IN : spdk_spc_opcode = 134 ; pub const spdk_spc_opcode_SPDK_SPC_ACCESS_CONTROL_OUT : spdk_spc_opcode = 135 ; pub const spdk_spc_opcode_SPDK_SPC_EXTENDED_COPY : spdk_spc_opcode = 131 ; pub const spdk_spc_opcode_SPDK_SPC_INQUIRY : spdk_spc_opcode = 18 ; pub const spdk_spc_opcode_SPDK_SPC_LOG_SELECT : spdk_spc_opcode = 76 ; pub const spdk_spc_opcode_SPDK_SPC_LOG_SENSE : spdk_spc_opcode = 77 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SELECT_6 : spdk_spc_opcode = 21 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SELECT_10 : spdk_spc_opcode = 85 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SENSE_6 : spdk_spc_opcode = 26 ; pub const spdk_spc_opcode_SPDK_SPC_MODE_SENSE_10 : spdk_spc_opcode = 90 ; pub const spdk_spc_opcode_SPDK_SPC_PERSISTENT_RESERVE_IN : spdk_spc_opcode = 94 ; pub const spdk_spc_opcode_SPDK_SPC_PERSISTENT_RESERVE_OUT : spdk_spc_opcode = 95 ; pub const spdk_spc_opcode_SPDK_SPC_PREVENT_ALLOW_MEDIUM_REMOVAL : spdk_spc_opcode = 30 ; pub const spdk_spc_opcode_SPDK_SPC_READ_ATTRIBUTE : spdk_spc_opcode = 140 ; pub const spdk_spc_opcode_SPDK_SPC_READ_BUFFER : spdk_spc_opcode = 60 ; pub const spdk_spc_opcode_SPDK_SPC_RECEIVE_COPY_RESULTS : spdk_spc_opcode = 132 ; pub const spdk_spc_opcode_SPDK_SPC_RECEIVE_DIAGNOSTIC_RESULTS : spdk_spc_opcode = 28 ; pub const spdk_spc_opcode_SPDK_SPC_REPORT_LUNS : spdk_spc_opcode = 160 ; pub const spdk_spc_opcode_SPDK_SPC_REQUEST_SENSE : spdk_spc_opcode = 3 ; pub const spdk_spc_opcode_SPDK_SPC_SEND_DIAGNOSTIC : spdk_spc_opcode = 29 ; pub const spdk_spc_opcode_SPDK_SPC_TEST_UNIT_READY : spdk_spc_opcode = 0 ; pub const spdk_spc_opcode_SPDK_SPC_WRITE_ATTRIBUTE : spdk_spc_opcode = 141 ; pub const spdk_spc_opcode_SPDK_SPC_WRITE_BUFFER : spdk_spc_opcode = 59 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_IN_12 : spdk_spc_opcode = 171 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_OUT_12 : spdk_spc_opcode = 169 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_IN_16 : spdk_spc_opcode = 158 ; pub const spdk_spc_opcode_SPDK_SPC_SERVICE_ACTION_OUT_16 : spdk_spc_opcode = 159 ; pub const spdk_spc_opcode_SPDK_SPC_VARIABLE_LENGTH : spdk_spc_opcode = 127 ; pub const spdk_spc_opcode_SPDK_SPC_MO_CHANGE_ALIASES : spdk_spc_opcode = 11 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_DEVICE_IDENTIFIER : spdk_spc_opcode = 6 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_PRIORITY : spdk_spc_opcode = 14 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_TARGET_PORT_GROUPS : spdk_spc_opcode = 10 ; pub const spdk_spc_opcode_SPDK_SPC_MO_SET_TIMESTAMP : spdk_spc_opcode = 15 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_ALIASES : spdk_spc_opcode = 11 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_DEVICE_IDENTIFIER : spdk_spc_opcode = 5 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_PRIORITY : spdk_spc_opcode = 14 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_SUPPORTED_OPERATION_CODES : spdk_spc_opcode = 12 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS : spdk_spc_opcode = 13 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_TARGET_PORT_GROUPS : spdk_spc_opcode = 10 ; pub const spdk_spc_opcode_SPDK_SPC_MI_REPORT_TIMESTAMP : spdk_spc_opcode = 15 ; pub const spdk_spc_opcode_SPDK_SPC2_RELEASE_6 : spdk_spc_opcode = 23 ; pub const spdk_spc_opcode_SPDK_SPC2_RELEASE_10 : spdk_spc_opcode = 87 ; pub const spdk_spc_opcode_SPDK_SPC2_RESERVE_6 : spdk_spc_opcode = 22 ; pub const spdk_spc_opcode_SPDK_SPC2_RESERVE_10 : spdk_spc_opcode = 86 ; pub type spdk_spc_opcode = u32 ; pub const spdk_scc_opcode_SPDK_SCC_MAINTENANCE_IN : spdk_scc_opcode = 163 ; pub const spdk_scc_opcode_SPDK_SCC_MAINTENANCE_OUT : spdk_scc_opcode = 164 ; pub type spdk_scc_opcode = u32 ; pub const spdk_sbc_opcode_SPDK_SBC_COMPARE_AND_WRITE : spdk_sbc_opcode = 137 ; pub const spdk_sbc_opcode_SPDK_SBC_FORMAT_UNIT : spdk_sbc_opcode = 4 ; pub const spdk_sbc_opcode_SPDK_SBC_GET_LBA_STATUS : spdk_sbc_opcode = 1179806 ; pub const spdk_sbc_opcode_SPDK_SBC_ORWRITE_16 : spdk_sbc_opcode = 139 ; pub const spdk_sbc_opcode_SPDK_SBC_PRE_FETCH_10 : spdk_sbc_opcode = 52 ; pub const spdk_sbc_opcode_SPDK_SBC_PRE_FETCH_16 : spdk_sbc_opcode = 144 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_6 : spdk_sbc_opcode = 8 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_10 : spdk_sbc_opcode = 40 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_12 : spdk_sbc_opcode = 168 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_16 : spdk_sbc_opcode = 136 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_ATTRIBUTE : spdk_sbc_opcode = 140 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_BUFFER : spdk_sbc_opcode = 60 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_CAPACITY_10 : spdk_sbc_opcode = 37 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_DEFECT_DATA_10 : spdk_sbc_opcode = 55 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_DEFECT_DATA_12 : spdk_sbc_opcode = 183 ; pub const spdk_sbc_opcode_SPDK_SBC_READ_LONG_10 : spdk_sbc_opcode = 62 ; pub const spdk_sbc_opcode_SPDK_SBC_REASSIGN_BLOCKS : spdk_sbc_opcode = 7 ; pub const spdk_sbc_opcode_SPDK_SBC_SANITIZE : spdk_sbc_opcode = 72 ; pub const spdk_sbc_opcode_SPDK_SBC_START_STOP_UNIT : spdk_sbc_opcode = 27 ; pub const spdk_sbc_opcode_SPDK_SBC_SYNCHRONIZE_CACHE_10 : spdk_sbc_opcode = 53 ; pub const spdk_sbc_opcode_SPDK_SBC_SYNCHRONIZE_CACHE_16 : spdk_sbc_opcode = 145 ; pub const spdk_sbc_opcode_SPDK_SBC_UNMAP : spdk_sbc_opcode = 66 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_10 : spdk_sbc_opcode = 47 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_12 : spdk_sbc_opcode = 175 ; pub const spdk_sbc_opcode_SPDK_SBC_VERIFY_16 : spdk_sbc_opcode = 143 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_6 : spdk_sbc_opcode = 10 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_10 : spdk_sbc_opcode = 42 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_12 : spdk_sbc_opcode = 170 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_16 : spdk_sbc_opcode = 138 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_10 : spdk_sbc_opcode = 46 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_12 : spdk_sbc_opcode = 174 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_AND_VERIFY_16 : spdk_sbc_opcode = 142 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_LONG_10 : spdk_sbc_opcode = 63 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_SAME_10 : spdk_sbc_opcode = 65 ; pub const spdk_sbc_opcode_SPDK_SBC_WRITE_SAME_16 : spdk_sbc_opcode = 147 ; pub const spdk_sbc_opcode_SPDK_SBC_XDREAD_10 : spdk_sbc_opcode = 82 ; pub const spdk_sbc_opcode_SPDK_SBC_XDWRITE_10 : spdk_sbc_opcode = 80 ; pub const spdk_sbc_opcode_SPDK_SBC_XDWRITEREAD_10 : spdk_sbc_opcode = 83 ; pub const spdk_sbc_opcode_SPDK_SBC_XPWRITE_10 : spdk_sbc_opcode = 81 ; pub const spdk_sbc_opcode_SPDK_SBC_SAI_READ_CAPACITY_16 : spdk_sbc_opcode = 16 ; pub const spdk_sbc_opcode_SPDK_SBC_SAI_READ_LONG_16 : spdk_sbc_opcode = 17 ; pub const spdk_sbc_opcode_SPDK_SBC_SAO_WRITE_LONG_16 : spdk_sbc_opcode = 17 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_READ_32 : spdk_sbc_opcode = 9 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_VERIFY_32 : spdk_sbc_opcode = 10 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_32 : spdk_sbc_opcode = 11 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_AND_VERIFY_32 : spdk_sbc_opcode = 12 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_WRITE_SAME_32 : spdk_sbc_opcode = 13 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDREAD_32 : spdk_sbc_opcode = 3 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDWRITE_32 : spdk_sbc_opcode = 4 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XDWRITEREAD_32 : spdk_sbc_opcode = 7 ; pub const spdk_sbc_opcode_SPDK_SBC_VL_XPWRITE_32 : spdk_sbc_opcode = 6 ; pub type spdk_sbc_opcode = u32 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DISC_STRUCTURE : spdk_mmc_opcode = 173 ; pub const spdk_mmc_opcode_SPDK_MMC_BLANK : spdk_mmc_opcode = 161 ; pub const spdk_mmc_opcode_SPDK_MMC_CLOSE_TRACK_SESSION : spdk_mmc_opcode = 91 ; pub const spdk_mmc_opcode_SPDK_MMC_ERASE_10 : spdk_mmc_opcode = 44 ; pub const spdk_mmc_opcode_SPDK_MMC_FORMAT_UNIT : spdk_mmc_opcode = 4 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_CONFIGURATION : spdk_mmc_opcode = 70 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_EVENT_STATUS_NOTIFICATION : spdk_mmc_opcode = 74 ; pub const spdk_mmc_opcode_SPDK_MMC_GET_PERFORMANCE : spdk_mmc_opcode = 172 ; pub const spdk_mmc_opcode_SPDK_MMC_INQUIRY : spdk_mmc_opcode = 18 ; pub const spdk_mmc_opcode_SPDK_MMC_LOAD_UNLOAD_MEDIUM : spdk_mmc_opcode = 166 ; pub const spdk_mmc_opcode_SPDK_MMC_MECHANISM_STATUS : spdk_mmc_opcode = 189 ; pub const spdk_mmc_opcode_SPDK_MMC_MODE_SELECT_10 : spdk_mmc_opcode = 85 ; pub const spdk_mmc_opcode_SPDK_MMC_MODE_SENSE_10 : spdk_mmc_opcode = 90 ; pub const spdk_mmc_opcode_SPDK_MMC_PAUSE_RESUME : spdk_mmc_opcode = 75 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_10 : spdk_mmc_opcode = 69 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_12 : spdk_mmc_opcode = 165 ; pub const spdk_mmc_opcode_SPDK_MMC_PLAY_AUDIO_MSF : spdk_mmc_opcode = 71 ; pub const spdk_mmc_opcode_SPDK_MMC_PREVENT_ALLOW_MEDIUM_REMOVAL : spdk_mmc_opcode = 30 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_10 : spdk_mmc_opcode = 40 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_12 : spdk_mmc_opcode = 168 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_BUFFER : spdk_mmc_opcode = 60 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_BUFFER_CAPACITY : spdk_mmc_opcode = 92 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CAPACITY : spdk_mmc_opcode = 37 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CD : spdk_mmc_opcode = 190 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_CD_MSF : spdk_mmc_opcode = 185 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DISC_INFORMATION : spdk_mmc_opcode = 81 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_DVD_STRUCTURE : spdk_mmc_opcode = 173 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_FORMAT_CAPACITIES : spdk_mmc_opcode = 35 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_SUB_CHANNEL : spdk_mmc_opcode = 66 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_TOC_PMA_ATIP : spdk_mmc_opcode = 67 ; pub const spdk_mmc_opcode_SPDK_MMC_READ_TRACK_INFORMATION : spdk_mmc_opcode = 82 ; pub const spdk_mmc_opcode_SPDK_MMC_REPAIR_TRACK : spdk_mmc_opcode = 88 ; pub const spdk_mmc_opcode_SPDK_MMC_REPORT_KEY : spdk_mmc_opcode = 164 ; pub const spdk_mmc_opcode_SPDK_MMC_REQUEST_SENSE : spdk_mmc_opcode = 3 ; pub const spdk_mmc_opcode_SPDK_MMC_RESERVE_TRACK : spdk_mmc_opcode = 83 ; pub const spdk_mmc_opcode_SPDK_MMC_SCAN : spdk_mmc_opcode = 186 ; pub const spdk_mmc_opcode_SPDK_MMC_SEEK_10 : spdk_mmc_opcode = 43 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_CUE_SHEET : spdk_mmc_opcode = 93 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_DVD_STRUCTURE : spdk_mmc_opcode = 191 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_KEY : spdk_mmc_opcode = 163 ; pub const spdk_mmc_opcode_SPDK_MMC_SEND_OPC_INFORMATION : spdk_mmc_opcode = 84 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_CD_SPEED : spdk_mmc_opcode = 187 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_READ_AHEAD : spdk_mmc_opcode = 167 ; pub const spdk_mmc_opcode_SPDK_MMC_SET_STREAMING : spdk_mmc_opcode = 182 ; pub const spdk_mmc_opcode_SPDK_MMC_START_STOP_UNIT : spdk_mmc_opcode = 27 ; pub const spdk_mmc_opcode_SPDK_MMC_STOP_PLAY_SCAN : spdk_mmc_opcode = 78 ; pub const spdk_mmc_opcode_SPDK_MMC_SYNCHRONIZE_CACHE : spdk_mmc_opcode = 53 ; pub const spdk_mmc_opcode_SPDK_MMC_TEST_UNIT_READY : spdk_mmc_opcode = 0 ; pub const spdk_mmc_opcode_SPDK_MMC_VERIFY_10 : spdk_mmc_opcode = 47 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_10 : spdk_mmc_opcode = 162 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_12 : spdk_mmc_opcode = 170 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_AND_VERIFY_10 : spdk_mmc_opcode = 46 ; pub const spdk_mmc_opcode_SPDK_MMC_WRITE_BUFFER : spdk_mmc_opcode = 59 ; pub type spdk_mmc_opcode = u32 ; pub const spdk_ssc_opcode_SPDK_SSC_ERASE_6 : spdk_ssc_opcode = 25 ; pub const spdk_ssc_opcode_SPDK_SSC_FORMAT_MEDIUM : spdk_ssc_opcode = 4 ; pub const spdk_ssc_opcode_SPDK_SSC_LOAD_UNLOAD : spdk_ssc_opcode = 27 ; pub const spdk_ssc_opcode_SPDK_SSC_LOCATE_10 : spdk_ssc_opcode = 43 ; pub const spdk_ssc_opcode_SPDK_SSC_LOCATE_16 : spdk_ssc_opcode = 146 ; pub const spdk_ssc_opcode_SPDK_SSC_MOVE_MEDIUM_ATTACHED : spdk_ssc_opcode = 167 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_6 : spdk_ssc_opcode = 8 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_BLOCK_LIMITS : spdk_ssc_opcode = 5 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_ELEMENT_STATUS_ATTACHED : spdk_ssc_opcode = 180 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_POSITION : spdk_ssc_opcode = 52 ; pub const spdk_ssc_opcode_SPDK_SSC_READ_REVERSE_6 : spdk_ssc_opcode = 15 ; pub const spdk_ssc_opcode_SPDK_SSC_RECOVER_BUFFERED_DATA : spdk_ssc_opcode = 20 ; pub const spdk_ssc_opcode_SPDK_SSC_REPORT_DENSITY_SUPPORT : spdk_ssc_opcode = 68 ; pub const spdk_ssc_opcode_SPDK_SSC_REWIND : spdk_ssc_opcode = 1 ; pub const spdk_ssc_opcode_SPDK_SSC_SET_CAPACITY : spdk_ssc_opcode = 11 ; pub const spdk_ssc_opcode_SPDK_SSC_SPACE_6 : spdk_ssc_opcode = 17 ; pub const spdk_ssc_opcode_SPDK_SSC_SPACE_16 : spdk_ssc_opcode = 145 ; pub const spdk_ssc_opcode_SPDK_SSC_VERIFY_6 : spdk_ssc_opcode = 19 ; pub const spdk_ssc_opcode_SPDK_SSC_WRITE_6 : spdk_ssc_opcode = 10 ; pub const spdk_ssc_opcode_SPDK_SSC_WRITE_FILEMARKS_6 : spdk_ssc_opcode = 16 ; pub type spdk_ssc_opcode = u32 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_DEVICE_IDENTIFICATION : spdk_spc_vpd = 131 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_EXTENDED_INQUIRY_DATA : spdk_spc_vpd = 134 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_MANAGEMENT_NETWORK_ADDRESSES : spdk_spc_vpd = 133 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_MODE_PAGE_POLICY : spdk_spc_vpd = 135 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SCSI_PORTS : spdk_spc_vpd = 136 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SOFTWARE_INTERFACE_IDENTIFICATION : spdk_spc_vpd = 132 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_SUPPORTED_VPD_PAGES : spdk_spc_vpd = 0 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_UNIT_SERIAL_NUMBER : spdk_spc_vpd = 128 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_LIMITS : spdk_spc_vpd = 176 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_DEV_CHARS : spdk_spc_vpd = 177 ; pub const spdk_spc_vpd_SPDK_SPC_VPD_BLOCK_THIN_PROVISION : spdk_spc_vpd = 178 ; pub type spdk_spc_vpd = u32 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_CONNECTED : spdk_spc_peripheral_qualifier = 0 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_NOT_CONNECTED : spdk_spc_peripheral_qualifier = 1 ; pub const spdk_spc_peripheral_qualifier_SPDK_SPC_PERIPHERAL_QUALIFIER_NOT_CAPABLE : spdk_spc_peripheral_qualifier = 3 ; pub type spdk_spc_peripheral_qualifier = u32 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_DISK : _bindgen_ty_35 = 0 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_TAPE : _bindgen_ty_35 = 1 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_DVD : _bindgen_ty_35 = 5 ; pub const SPDK_SPC_PERIPHERAL_DEVICE_TYPE_CHANGER : _bindgen_ty_35 = 8 ; pub const SPDK_SPC_VERSION_NONE : _bindgen_ty_35 = 0 ; pub const SPDK_SPC_VERSION_SPC : _bindgen_ty_35 = 3 ; pub const SPDK_SPC_VERSION_SPC2 : _bindgen_ty_35 = 4 ; pub const SPDK_SPC_VERSION_SPC3 : _bindgen_ty_35 = 5 ; pub const SPDK_SPC_VERSION_SPC4 : _bindgen_ty_35 = 6 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_FC : _bindgen_ty_35 = 0 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_PSCSI : _bindgen_ty_35 = 1 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_SSA : _bindgen_ty_35 = 2 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_IEEE1394 : _bindgen_ty_35 = 3 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_RDMA : _bindgen_ty_35 = 4 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ISCSI : _bindgen_ty_35 = 5 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_SAS : _bindgen_ty_35 = 6 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ADT : _bindgen_ty_35 = 7 ; pub const SPDK_SPC_PROTOCOL_IDENTIFIER_ATA : _bindgen_ty_35 = 8 ; pub const SPDK_SPC_VPD_CODE_SET_BINARY : _bindgen_ty_35 = 1 ; pub const SPDK_SPC_VPD_CODE_SET_ASCII : _bindgen_ty_35 = 2 ; pub const SPDK_SPC_VPD_CODE_SET_UTF8 : _bindgen_ty_35 = 3 ; pub const SPDK_SPC_VPD_ASSOCIATION_LOGICAL_UNIT : _bindgen_ty_35 = 0 ; pub const SPDK_SPC_VPD_ASSOCIATION_TARGET_PORT : _bindgen_ty_35 = 1 ; pub const SPDK_SPC_VPD_ASSOCIATION_TARGET_DEVICE : _bindgen_ty_35 = 2 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_VENDOR_SPECIFIC : _bindgen_ty_35 = 0 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_T10_VENDOR_ID : _bindgen_ty_35 = 1 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_EUI64 : _bindgen_ty_35 = 2 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_NAA : _bindgen_ty_35 = 3 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_RELATIVE_TARGET_PORT : _bindgen_ty_35 = 4 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_TARGET_PORT_GROUP : _bindgen_ty_35 = 5 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_LOGICAL_UNIT_GROUP : _bindgen_ty_35 = 6 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_MD5_LOGICAL_UNIT : _bindgen_ty_35 = 7 ; pub const SPDK_SPC_VPD_IDENTIFIER_TYPE_SCSI_NAME : _bindgen_ty_35 = 8 ; pub type _bindgen_ty_35 = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_cdb_inquiry { pub opcode : u8 , pub evpd : u8 , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub control : u8 , } # [ test ] fn bindgen_test_layout_spdk_scsi_cdb_inquiry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_cdb_inquiry > ( ) , 6usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_cdb_inquiry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_cdb_inquiry > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_cdb_inquiry ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_cdb_inquiry_data { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub rmb : u8 , pub version : u8 , pub response : u8 , pub add_len : u8 , pub flags : u8 , pub flags2 : u8 , pub flags3 : u8 , pub t10_vendor_id : [ u8 ; 8usize ] , pub product_id : [ u8 ; 16usize ] , pub product_rev : [ u8 ; 4usize ] , pub vendor : [ u8 ; 20usize ] , pub ius : u8 , pub reserved : u8 , pub desc : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_scsi_cdb_inquiry_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_cdb_inquiry_data > ( ) , 58usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_cdb_inquiry_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_cdb_inquiry_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_cdb_inquiry_data ) ) ) ; } impl spdk_scsi_cdb_inquiry_data { # [ inline ] pub fn peripheral_device_type ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_device_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn peripheral_qualifier ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_qualifier ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( peripheral_device_type : u8 , peripheral_qualifier : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let peripheral_device_type : u8 = unsafe { :: std :: mem :: transmute ( peripheral_device_type ) } ; peripheral_device_type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let peripheral_qualifier : u8 = unsafe { :: std :: mem :: transmute ( peripheral_qualifier ) } ; peripheral_qualifier as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_vpd_page { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub params : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_scsi_vpd_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_vpd_page > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_vpd_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_vpd_page > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_vpd_page ) ) ) ; } impl spdk_scsi_vpd_page { # [ inline ] pub fn peripheral_device_type ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_device_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn peripheral_qualifier ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_peripheral_qualifier ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( peripheral_device_type : u8 , peripheral_qualifier : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let peripheral_device_type : u8 = unsafe { :: std :: mem :: transmute ( peripheral_device_type ) } ; peripheral_device_type as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let peripheral_qualifier : u8 = unsafe { :: std :: mem :: transmute ( peripheral_qualifier ) } ; peripheral_qualifier as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_scsi_vpd_ext_inquiry { pub peripheral : u8 , pub page_code : u8 , pub alloc_len : [ u8 ; 2usize ] , pub check : u8 , pub sup : u8 , pub sup2 : u8 , pub luiclr : u8 , pub cbcs : u8 , pub micro_dl : u8 , pub reserved : [ u8 ; 54usize ] , } # [ test ] fn bindgen_test_layout_spdk_scsi_vpd_ext_inquiry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_vpd_ext_inquiry > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_vpd_ext_inquiry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_vpd_ext_inquiry > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_vpd_ext_inquiry ) ) ) ; } impl Default for spdk_scsi_vpd_ext_inquiry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_desig_desc { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub reserved1 : u8 , pub len : u8 , pub desig : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_scsi_desig_desc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_desig_desc > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_desig_desc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_desig_desc > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_desig_desc ) ) ) ; } impl spdk_scsi_desig_desc { # [ inline ] pub fn code_set ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_code_set ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn protocol_id ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_protocol_id ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn association ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_association ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn piv ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_piv ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( code_set : u8 , protocol_id : u8 , type_ : u8 , association : u8 , reserved0 : u8 , piv : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let code_set : u8 = unsafe { :: std :: mem :: transmute ( code_set ) } ; code_set as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let protocol_id : u8 = unsafe { :: std :: mem :: transmute ( protocol_id ) } ; protocol_id as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let association : u8 = unsafe { :: std :: mem :: transmute ( association ) } ; association as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let reserved0 : u8 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let piv : u8 = unsafe { :: std :: mem :: transmute ( piv ) } ; piv as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_mpage_policy_desc { pub page_code : u8 , pub sub_page_code : u8 , pub policy : u8 , pub reserved : u8 , } # [ test ] fn bindgen_test_layout_spdk_scsi_mpage_policy_desc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_mpage_policy_desc > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_mpage_policy_desc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_mpage_policy_desc > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_mpage_policy_desc ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_tgt_port_desc { pub code_set : u8 , pub desig_type : u8 , pub reserved : u8 , pub len : u8 , pub designator : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_scsi_tgt_port_desc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_tgt_port_desc > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_tgt_port_desc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_tgt_port_desc > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_tgt_port_desc ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_scsi_port_desc { pub reserved : u16 , pub rel_port_id : u16 , pub reserved2 : u16 , pub init_port_len : u16 , pub init_port_id : u16 , pub reserved3 : u16 , pub tgt_desc_len : u16 , pub tgt_desc : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_scsi_port_desc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_port_desc > ( ) , 14usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_port_desc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_port_desc > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_port_desc ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_scsi_unmap_bdesc { pub lba : u64 , pub block_count : u32 , pub reserved : u32 , } # [ test ] fn bindgen_test_layout_spdk_scsi_unmap_bdesc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_scsi_unmap_bdesc > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_scsi_unmap_bdesc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_scsi_unmap_bdesc > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_scsi_unmap_bdesc ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cap_register { pub raw : u64 , pub bits : spdk_nvme_cap_register__bindgen_ty_1 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cap_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cap_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cap_register__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cap_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cap_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cap_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cap_register__bindgen_ty_1 { # [ inline ] pub fn mqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 5u8 , val as u64 ) } } # [ inline ] pub fn to ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_to ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn dstrd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 32usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_dstrd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 32usize , 4u8 , val as u64 ) } } # [ inline ] pub fn nssrs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 36usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssrs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 36usize , 1u8 , val as u64 ) } } # [ inline ] pub fn css_nvm ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 37usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_css_nvm ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 37usize , 1u8 , val as u64 ) } } # [ inline ] pub fn css_reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 38usize , 7u8 ) as u32 ) } } # [ inline ] pub fn set_css_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 38usize , 7u8 , val as u64 ) } } # [ inline ] pub fn bps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 45usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 45usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 46usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 46usize , 2u8 , val as u64 ) } } # [ inline ] pub fn mpsmin ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 48usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmin ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 48usize , 4u8 , val as u64 ) } } # [ inline ] pub fn mpsmax ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 52usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mpsmax ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 52usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mqes : u32 , cqr : u32 , ams : u32 , reserved1 : u32 , to : u32 , dstrd : u32 , nssrs : u32 , css_nvm : u32 , css_reserved : u32 , bps : u32 , reserved2 : u32 , mpsmin : u32 , mpsmax : u32 , reserved3 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let mqes : u32 = unsafe { :: std :: mem :: transmute ( mqes ) } ; mqes as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cqr : u32 = unsafe { :: std :: mem :: transmute ( cqr ) } ; cqr as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 2u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let to : u32 = unsafe { :: std :: mem :: transmute ( to ) } ; to as u64 } ) ; __bindgen_bitfield_unit . set ( 32usize , 4u8 , { let dstrd : u32 = unsafe { :: std :: mem :: transmute ( dstrd ) } ; dstrd as u64 } ) ; __bindgen_bitfield_unit . set ( 36usize , 1u8 , { let nssrs : u32 = unsafe { :: std :: mem :: transmute ( nssrs ) } ; nssrs as u64 } ) ; __bindgen_bitfield_unit . set ( 37usize , 1u8 , { let css_nvm : u32 = unsafe { :: std :: mem :: transmute ( css_nvm ) } ; css_nvm as u64 } ) ; __bindgen_bitfield_unit . set ( 38usize , 7u8 , { let css_reserved : u32 = unsafe { :: std :: mem :: transmute ( css_reserved ) } ; css_reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 45usize , 1u8 , { let bps : u32 = unsafe { :: std :: mem :: transmute ( bps ) } ; bps as u64 } ) ; __bindgen_bitfield_unit . set ( 46usize , 2u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 48usize , 4u8 , { let mpsmin : u32 = unsafe { :: std :: mem :: transmute ( mpsmin ) } ; mpsmin as u64 } ) ; __bindgen_bitfield_unit . set ( 52usize , 4u8 , { let mpsmax : u32 = unsafe { :: std :: mem :: transmute ( mpsmax ) } ; mpsmax as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 8u8 , { let reserved3 : u32 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cap_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cap_register > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cap_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cap_register > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cap_register ) ) ) ; } impl Default for spdk_nvme_cap_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cc_register { pub raw : u32 , pub bits : spdk_nvme_cc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cc_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cc_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cc_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cc_register__bindgen_ty_1 { # [ inline ] pub fn en ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_en ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn css ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_css ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn mps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ams ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ams ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 3u8 , val as u64 ) } } # [ inline ] pub fn shn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn iosqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iosqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn iocqes ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_iocqes ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 4u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( en : u32 , reserved1 : u32 , css : u32 , mps : u32 , ams : u32 , shn : u32 , iosqes : u32 , iocqes : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let en : u32 = unsafe { :: std :: mem :: transmute ( en ) } ; en as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let css : u32 = unsafe { :: std :: mem :: transmute ( css ) } ; css as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 4u8 , { let mps : u32 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 3u8 , { let ams : u32 = unsafe { :: std :: mem :: transmute ( ams ) } ; ams as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let shn : u32 = unsafe { :: std :: mem :: transmute ( shn ) } ; shn as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let iosqes : u32 = unsafe { :: std :: mem :: transmute ( iosqes ) } ; iosqes as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 4u8 , { let iocqes : u32 = unsafe { :: std :: mem :: transmute ( iocqes ) } ; iocqes as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cc_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cc_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cc_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cc_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cc_register ) ) ) ; } impl Default for spdk_nvme_cc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shn_value_SPDK_NVME_SHN_NORMAL : spdk_nvme_shn_value = 1 ; pub const spdk_nvme_shn_value_SPDK_NVME_SHN_ABRUPT : spdk_nvme_shn_value = 2 ; pub type spdk_nvme_shn_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_csts_register { pub raw : u32 , pub bits : spdk_nvme_csts_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_csts_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_csts_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_csts_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_csts_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_csts_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_csts_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_csts_register__bindgen_ty_1 { # [ inline ] pub fn rdy ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rdy ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cfs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cfs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn shst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_shst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 2u8 , val as u64 ) } } # [ inline ] pub fn nssro ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_nssro ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( rdy : u32 , cfs : u32 , shst : u32 , nssro : u32 , pp : u32 , reserved1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let rdy : u32 = unsafe { :: std :: mem :: transmute ( rdy ) } ; rdy as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cfs : u32 = unsafe { :: std :: mem :: transmute ( cfs ) } ; cfs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 2u8 , { let shst : u32 = unsafe { :: std :: mem :: transmute ( shst ) } ; shst as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let nssro : u32 = unsafe { :: std :: mem :: transmute ( nssro ) } ; nssro as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let pp : u32 = unsafe { :: std :: mem :: transmute ( pp ) } ; pp as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_csts_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_csts_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_csts_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_csts_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_csts_register ) ) ) ; } impl Default for spdk_nvme_csts_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_shst_value_SPDK_NVME_SHST_NORMAL : spdk_nvme_shst_value = 0 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_OCCURRING : spdk_nvme_shst_value = 1 ; pub const spdk_nvme_shst_value_SPDK_NVME_SHST_COMPLETE : spdk_nvme_shst_value = 2 ; pub type spdk_nvme_shst_value = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_aqa_register { pub raw : u32 , pub bits : spdk_nvme_aqa_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_aqa_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_aqa_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_aqa_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_aqa_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_aqa_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_aqa_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_aqa_register__bindgen_ty_1 { # [ inline ] pub fn asqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_asqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 4u8 , val as u64 ) } } # [ inline ] pub fn acqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 12u8 ) as u32 ) } } # [ inline ] pub fn set_acqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 12u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 28usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 28usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( asqs : u32 , reserved1 : u32 , acqs : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 12u8 , { let asqs : u32 = unsafe { :: std :: mem :: transmute ( asqs ) } ; asqs as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 4u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 12u8 , { let acqs : u32 = unsafe { :: std :: mem :: transmute ( acqs ) } ; acqs as u64 } ) ; __bindgen_bitfield_unit . set ( 28usize , 4u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_aqa_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_aqa_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_aqa_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_aqa_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_aqa_register ) ) ) ; } impl Default for spdk_nvme_aqa_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_vs_register { pub raw : u32 , pub bits : spdk_nvme_vs_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_vs_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_vs_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_vs_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_vs_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_vs_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_vs_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_vs_register__bindgen_ty_1 { # [ inline ] pub fn ter ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_ter ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mnr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mnr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mjr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_mjr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ter : u32 , mnr : u32 , mjr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let ter : u32 = unsafe { :: std :: mem :: transmute ( ter ) } ; ter as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let mnr : u32 = unsafe { :: std :: mem :: transmute ( mnr ) } ; mnr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let mjr : u32 = unsafe { :: std :: mem :: transmute ( mjr ) } ; mjr as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_vs_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_vs_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_vs_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_vs_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_vs_register ) ) ) ; } impl Default for spdk_nvme_vs_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbloc_register { pub raw : u32 , pub bits : spdk_nvme_cmbloc_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbloc_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbloc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbloc_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbloc_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbloc_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cmbloc_register__bindgen_ty_1 { # [ inline ] pub fn bir ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_bir ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 9u8 , val as u64 ) } } # [ inline ] pub fn ofst ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_ofst ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bir : u32 , reserved1 : u32 , ofst : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let bir : u32 = unsafe { :: std :: mem :: transmute ( bir ) } ; bir as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let ofst : u32 = unsafe { :: std :: mem :: transmute ( ofst ) } ; ofst as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbloc_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbloc_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbloc_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbloc_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbloc_register ) ) ) ; } impl Default for spdk_nvme_cmbloc_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmbsz_register { pub raw : u32 , pub bits : spdk_nvme_cmbsz_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbsz_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbsz_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbsz_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbsz_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbsz_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_cmbsz_register__bindgen_ty_1 { # [ inline ] pub fn sqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn cqs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cqs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lists ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_lists ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn rds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_rds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wds ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wds ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn szu ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_szu ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 4u8 , val as u64 ) } } # [ inline ] pub fn sz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_sz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( sqs : u32 , cqs : u32 , lists : u32 , rds : u32 , wds : u32 , reserved1 : u32 , szu : u32 , sz : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let sqs : u32 = unsafe { :: std :: mem :: transmute ( sqs ) } ; sqs as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let cqs : u32 = unsafe { :: std :: mem :: transmute ( cqs ) } ; cqs as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let lists : u32 = unsafe { :: std :: mem :: transmute ( lists ) } ; lists as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let rds : u32 = unsafe { :: std :: mem :: transmute ( rds ) } ; rds as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let wds : u32 = unsafe { :: std :: mem :: transmute ( wds ) } ; wds as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 4u8 , { let szu : u32 = unsafe { :: std :: mem :: transmute ( szu ) } ; szu as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let sz : u32 = unsafe { :: std :: mem :: transmute ( sz ) } ; sz as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_cmbsz_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmbsz_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmbsz_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmbsz_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmbsz_register ) ) ) ; } impl Default for spdk_nvme_cmbsz_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Boot partition information 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bpinfo_register { pub raw : u32 , pub bits : spdk_nvme_bpinfo_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_bpinfo_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bpinfo_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bpinfo_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bpinfo_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bpinfo_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_bpinfo_register__bindgen_ty_1 { # [ inline ] pub fn bpsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_bpsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 15u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 9u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 9u8 , val as u64 ) } } # [ inline ] pub fn brs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_brs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 5u8 , val as u64 ) } } # [ inline ] pub fn abpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_abpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bpsz : u32 , reserved1 : u32 , brs : u32 , reserved2 : u32 , abpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 15u8 , { let bpsz : u32 = unsafe { :: std :: mem :: transmute ( bpsz ) } ; bpsz as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 9u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let brs : u32 = unsafe { :: std :: mem :: transmute ( brs ) } ; brs as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 5u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let abpid : u32 = unsafe { :: std :: mem :: transmute ( abpid ) } ; abpid as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_bpinfo_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bpinfo_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bpinfo_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bpinfo_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bpinfo_register ) ) ) ; } impl Default for spdk_nvme_bpinfo_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Boot partition read select 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_bprsel_register { pub raw : u32 , pub bits : spdk_nvme_bprsel_register__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_bprsel_register__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_bprsel_register__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bprsel_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bprsel_register__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bprsel_register__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bprsel_register__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_bprsel_register__bindgen_ty_1 { # [ inline ] pub fn bprsz ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_bprsz ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 10u8 , val as u64 ) } } # [ inline ] pub fn bprof ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_bprof ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 20u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 30usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 30usize , 1u8 , val as u64 ) } } # [ inline ] pub fn bpid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 31usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bpid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 31usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( bprsz : u32 , bprof : u32 , reserved : u32 , bpid : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 10u8 , { let bprsz : u32 = unsafe { :: std :: mem :: transmute ( bprsz ) } ; bprsz as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 20u8 , { let bprof : u32 = unsafe { :: std :: mem :: transmute ( bprof ) } ; bprof as u64 } ) ; __bindgen_bitfield_unit . set ( 30usize , 1u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 31usize , 1u8 , { let bpid : u32 = unsafe { :: std :: mem :: transmute ( bpid ) } ; bpid as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_bprsel_register ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_bprsel_register > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_bprsel_register ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_bprsel_register > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_bprsel_register ) ) ) ; } impl Default for spdk_nvme_bprsel_register { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_registers { 
 /// controller capabilities 
 pub cap : spdk_nvme_cap_register , 
 /// version of NVMe specification 
 pub vs : spdk_nvme_vs_register , pub intms : u32 , pub intmc : u32 , 
 /// controller configuration 
 pub cc : spdk_nvme_cc_register , pub reserved1 : u32 , pub csts : spdk_nvme_csts_register , pub nssr : u32 , 
 /// admin queue attributes 
 pub aqa : spdk_nvme_aqa_register , pub asq : u64 , pub acq : u64 , 
 /// controller memory buffer location 
 pub cmbloc : spdk_nvme_cmbloc_register , 
 /// controller memory buffer size 
 pub cmbsz : spdk_nvme_cmbsz_register , 
 /// boot partition information 
 pub bpinfo : spdk_nvme_bpinfo_register , 
 /// boot partition read select 
 pub bprsel : spdk_nvme_bprsel_register , 
 /// boot partition memory buffer location (must be 4KB aligned) 
 pub bpmbl : u64 , pub reserved3 : [ u32 ; 1004usize ] , pub doorbell : [ spdk_nvme_registers__bindgen_ty_1 ; 1usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_registers__bindgen_ty_1 { pub sq_tdbl : u32 , pub cq_hdbl : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvme_registers__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_registers__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_registers__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_registers__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_registers__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvme_registers ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_registers > ( ) , 4104usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_registers ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_registers > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_registers ) ) ) ; } impl Default for spdk_nvme_registers { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 0 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_BIT_BUCKET : spdk_nvme_sgl_descriptor_type = 1 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_SEGMENT : spdk_nvme_sgl_descriptor_type = 2 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_LAST_SEGMENT : spdk_nvme_sgl_descriptor_type = 3 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK : spdk_nvme_sgl_descriptor_type = 4 ; pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC : spdk_nvme_sgl_descriptor_type = 15 ; pub type spdk_nvme_sgl_descriptor_type = u32 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_ADDRESS : spdk_nvme_sgl_descriptor_subtype = 0 ; pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_OFFSET : spdk_nvme_sgl_descriptor_subtype = 1 ; pub type spdk_nvme_sgl_descriptor_subtype = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor { pub address : u64 , pub __bindgen_anon_1 : spdk_nvme_sgl_descriptor__bindgen_ty_1 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 { pub generic : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 , pub unkeyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 , pub keyed : spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 , _bindgen_union_align : u64 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { pub reserved : [ u8 ; 7usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { pub length : u32 , pub reserved : [ u8 ; 3usize ] , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 ) ) ) ; } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 { # [ inline ] pub fn subtype ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_type ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( subtype : u8 , type_ : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let subtype : u8 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let type_ : u8 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > , pub __bindgen_align : [ u64 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 ) ) ) ; } impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 { # [ inline ] pub fn length ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 24u8 ) as u64 ) } } # [ inline ] pub fn set_length ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 24u8 , val as u64 ) } } # [ inline ] pub fn key ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 32u8 ) as u64 ) } } # [ inline ] pub fn set_key ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 32u8 , val as u64 ) } } # [ inline ] pub fn subtype ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 56usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_subtype ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 56usize , 4u8 , val as u64 ) } } # [ inline ] pub fn type_ ( & self ) -> u64 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 60usize , 4u8 ) as u64 ) } } # [ inline ] pub fn set_type ( & mut self , val : u64 ) { unsafe { let val : u64 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 60usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( length : u64 , key : u64 , subtype : u64 , type_ : u64 ) -> __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 8usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 24u8 , { let length : u64 = unsafe { :: std :: mem :: transmute ( length ) } ; length as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 32u8 , { let key : u64 = unsafe { :: std :: mem :: transmute ( key ) } ; key as u64 } ) ; __bindgen_bitfield_unit . set ( 56usize , 4u8 , { let subtype : u64 = unsafe { :: std :: mem :: transmute ( subtype ) } ; subtype as u64 } ) ; __bindgen_bitfield_unit . set ( 60usize , 4u8 , { let type_ : u64 = unsafe { :: std :: mem :: transmute ( type_ ) } ; type_ as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_sgl_descriptor__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_sgl_descriptor ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_sgl_descriptor > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_sgl_descriptor ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_sgl_descriptor > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_sgl_descriptor ) ) ) ; } impl Default for spdk_nvme_sgl_descriptor { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_PRP : spdk_nvme_psdt_value = 0 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_CONTIG : spdk_nvme_psdt_value = 1 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_SGL : spdk_nvme_psdt_value = 2 ; pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_RESERVED : spdk_nvme_psdt_value = 3 ; pub type spdk_nvme_psdt_value = u32 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_URGENT : spdk_nvme_qprio = 0 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_HIGH : spdk_nvme_qprio = 1 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_MEDIUM : spdk_nvme_qprio = 2 ; pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_LOW : spdk_nvme_qprio = 3 ; 
 /// Submission queue priority values for Create I/O Submission Queue Command.
///
/// Only valid for weighted round robin arbitration method. 
 pub type spdk_nvme_qprio = u32 ; 
 /// < weighted round robin 
 pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_WRR : spdk_nvme_cap_ams = 1 ; 
 /// < vendor specific 
 pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_VS : spdk_nvme_cap_ams = 2 ; 
 /// Optional Arbitration Mechanism Supported by the controller.
///
/// Two bits for CAP.AMS (18:17) field are set to '1' when the controller supports.
/// There is no bit for AMS_RR where all controllers support and set to 0x0 by default. 
 pub type spdk_nvme_cap_ams = u32 ; 
 /// < default round robin 
 pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_RR : spdk_nvme_cc_ams = 0 ; 
 /// < weighted round robin 
 pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_WRR : spdk_nvme_cc_ams = 1 ; 
 /// < vendor specific 
 pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_VS : spdk_nvme_cc_ams = 7 ; 
 /// Arbitration Mechanism Selected to the controller.
///
/// Value 0x2 to 0x6 is reserved. 
 pub type spdk_nvme_cc_ams = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmd { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub cid : u16 , pub nsid : u32 , pub rsvd2 : u32 , pub rsvd3 : u32 , pub mptr : u64 , pub dptr : spdk_nvme_cmd__bindgen_ty_1 , pub cdw10 : u32 , pub cdw11 : u32 , pub cdw12 : u32 , pub cdw13 : u32 , pub cdw14 : u32 , pub cdw15 : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_cmd__bindgen_ty_1 { pub prp : spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 , pub sgl1 : spdk_nvme_sgl_descriptor , _bindgen_union_align : [ u64 ; 2usize ] , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 { pub prp1 : u64 , pub prp2 : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } # [ test ] fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmd__bindgen_ty_1 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmd__bindgen_ty_1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmd__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_cmd__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_cmd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmd > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmd > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmd ) ) ) ; } impl Default for spdk_nvme_cmd { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_cmd { # [ inline ] pub fn opc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_opc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn fuse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_fuse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 2u8 , val as u64 ) } } # [ inline ] pub fn rsvd1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 4u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 4u8 , val as u64 ) } } # [ inline ] pub fn psdt ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_psdt ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( opc : u16 , fuse : u16 , rsvd1 : u16 , psdt : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let opc : u16 = unsafe { :: std :: mem :: transmute ( opc ) } ; opc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 2u8 , { let fuse : u16 = unsafe { :: std :: mem :: transmute ( fuse ) } ; fuse as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 4u8 , { let rsvd1 : u16 = unsafe { :: std :: mem :: transmute ( rsvd1 ) } ; rsvd1 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 2u8 , { let psdt : u16 = unsafe { :: std :: mem :: transmute ( psdt ) } ; psdt as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_status { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_status ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_status > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_status ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_status > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_status ) ) ) ; } impl spdk_nvme_status { # [ inline ] pub fn p ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_p ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 8u8 ) as u16 ) } } # [ inline ] pub fn set_sc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 8u8 , val as u64 ) } } # [ inline ] pub fn sct ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_sct ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rsvd2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 2u8 ) as u16 ) } } # [ inline ] pub fn set_rsvd2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 2u8 , val as u64 ) } } # [ inline ] pub fn m ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 14usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_m ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 14usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dnr ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 15usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dnr ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 15usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( p : u16 , sc : u16 , sct : u16 , rsvd2 : u16 , m : u16 , dnr : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let p : u16 = unsafe { :: std :: mem :: transmute ( p ) } ; p as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 8u8 , { let sc : u16 = unsafe { :: std :: mem :: transmute ( sc ) } ; sc as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let sct : u16 = unsafe { :: std :: mem :: transmute ( sct ) } ; sct as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 2u8 , { let rsvd2 : u16 = unsafe { :: std :: mem :: transmute ( rsvd2 ) } ; rsvd2 as u64 } ) ; __bindgen_bitfield_unit . set ( 14usize , 1u8 , { let m : u16 = unsafe { :: std :: mem :: transmute ( m ) } ; m as u64 } ) ; __bindgen_bitfield_unit . set ( 15usize , 1u8 , { let dnr : u16 = unsafe { :: std :: mem :: transmute ( dnr ) } ; dnr as u64 } ) ; __bindgen_bitfield_unit } } 
 /// Completion queue entry 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cpl { pub cdw0 : u32 , pub rsvd1 : u32 , pub sqhd : u16 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , } # [ test ] fn bindgen_test_layout_spdk_nvme_cpl ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cpl > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cpl ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cpl > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cpl ) ) ) ; } 
 /// Dataset Management range 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_dsm_range { pub attributes : spdk_nvme_dsm_range__bindgen_ty_1 , pub length : u32 , pub starting_lba : u64 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_dsm_range__bindgen_ty_1 { pub bits : spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 , pub raw : u32 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn af ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_af ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn al ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_al ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved0 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_reserved0 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn sr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn wp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 11usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 11usize , 13u8 , val as u64 ) } } # [ inline ] pub fn access_size ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_access_size ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( af : u32 , al : u32 , reserved0 : u32 , sr : u32 , sw : u32 , wp : u32 , reserved1 : u32 , access_size : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let af : u32 = unsafe { :: std :: mem :: transmute ( af ) } ; af as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 2u8 , { let al : u32 = unsafe { :: std :: mem :: transmute ( al ) } ; al as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved0 : u32 = unsafe { :: std :: mem :: transmute ( reserved0 ) } ; reserved0 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let sr : u32 = unsafe { :: std :: mem :: transmute ( sr ) } ; sr as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let sw : u32 = unsafe { :: std :: mem :: transmute ( sw ) } ; sw as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 1u8 , { let wp : u32 = unsafe { :: std :: mem :: transmute ( wp ) } ; wp as u64 } ) ; __bindgen_bitfield_unit . set ( 11usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let access_size : u32 = unsafe { :: std :: mem :: transmute ( access_size ) } ; access_size as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_dsm_range__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_dsm_range__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_dsm_range__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_dsm_range__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_dsm_range ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_dsm_range > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_dsm_range ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_dsm_range > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_dsm_range ) ) ) ; } impl Default for spdk_nvme_dsm_range { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_GENERIC : spdk_nvme_status_code_type = 0 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_COMMAND_SPECIFIC : spdk_nvme_status_code_type = 1 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_MEDIA_ERROR : spdk_nvme_status_code_type = 2 ; pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_VENDOR_SPECIFIC : spdk_nvme_status_code_type = 7 ; 
 /// Status code types 
 pub type spdk_nvme_status_code_type = u32 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SUCCESS : spdk_nvme_generic_command_status_code = 0 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_OPCODE : spdk_nvme_generic_command_status_code = 1 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_FIELD : spdk_nvme_generic_command_status_code = 2 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_ID_CONFLICT : spdk_nvme_generic_command_status_code = 3 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_TRANSFER_ERROR : spdk_nvme_generic_command_status_code = 4 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_POWER_LOSS : spdk_nvme_generic_command_status_code = 5 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INTERNAL_DEVICE_ERROR : spdk_nvme_generic_command_status_code = 6 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_BY_REQUEST : spdk_nvme_generic_command_status_code = 7 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_SQ_DELETION : spdk_nvme_generic_command_status_code = 8 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_FAILED_FUSED : spdk_nvme_generic_command_status_code = 9 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_MISSING_FUSED : spdk_nvme_generic_command_status_code = 10 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT : spdk_nvme_generic_command_status_code = 11 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR : spdk_nvme_generic_command_status_code = 12 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR : spdk_nvme_generic_command_status_code = 13 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS : spdk_nvme_generic_command_status_code = 14 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 15 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID : spdk_nvme_generic_command_status_code = 16 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID : spdk_nvme_generic_command_status_code = 17 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF : spdk_nvme_generic_command_status_code = 18 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_PRP_OFFSET : spdk_nvme_generic_command_status_code = 19 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED : spdk_nvme_generic_command_status_code = 20 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_OPERATION_DENIED : spdk_nvme_generic_command_status_code = 21 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_OFFSET : spdk_nvme_generic_command_status_code = 22 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT : spdk_nvme_generic_command_status_code = 24 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_EXPIRED : spdk_nvme_generic_command_status_code = 25 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_INVALID : spdk_nvme_generic_command_status_code = 26 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_PREEMPT : spdk_nvme_generic_command_status_code = 27 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_FAILED : spdk_nvme_generic_command_status_code = 28 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_IN_PROGRESS : spdk_nvme_generic_command_status_code = 29 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID : spdk_nvme_generic_command_status_code = 30 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_INVALID_IN_CMB : spdk_nvme_generic_command_status_code = 31 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_LBA_OUT_OF_RANGE : spdk_nvme_generic_command_status_code = 128 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_CAPACITY_EXCEEDED : spdk_nvme_generic_command_status_code = 129 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_NAMESPACE_NOT_READY : spdk_nvme_generic_command_status_code = 130 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_RESERVATION_CONFLICT : spdk_nvme_generic_command_status_code = 131 ; pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_FORMAT_IN_PROGRESS : spdk_nvme_generic_command_status_code = 132 ; 
 /// Generic command status codes 
 pub type spdk_nvme_generic_command_status_code = u32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_COMPLETION_QUEUE_INVALID : spdk_nvme_command_specific_status_code = 0 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER : spdk_nvme_command_specific_status_code = 1 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED : spdk_nvme_command_specific_status_code = 2 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 3 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED : spdk_nvme_command_specific_status_code = 5 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_SLOT : spdk_nvme_command_specific_status_code = 6 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE : spdk_nvme_command_specific_status_code = 7 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR : spdk_nvme_command_specific_status_code = 8 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_LOG_PAGE : spdk_nvme_command_specific_status_code = 9 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FORMAT : spdk_nvme_command_specific_status_code = 10 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET : spdk_nvme_command_specific_status_code = 11 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_DELETION : spdk_nvme_command_specific_status_code = 12 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE : spdk_nvme_command_specific_status_code = 13 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE : spdk_nvme_command_specific_status_code = 14 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC : spdk_nvme_command_specific_status_code = 15 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET : spdk_nvme_command_specific_status_code = 16 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_RESET : spdk_nvme_command_specific_status_code = 17 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION : spdk_nvme_command_specific_status_code = 18 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED : spdk_nvme_command_specific_status_code = 19 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_OVERLAPPING_RANGE : spdk_nvme_command_specific_status_code = 20 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY : spdk_nvme_command_specific_status_code = 21 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE : spdk_nvme_command_specific_status_code = 22 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED : spdk_nvme_command_specific_status_code = 24 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_IS_PRIVATE : spdk_nvme_command_specific_status_code = 25 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED : spdk_nvme_command_specific_status_code = 26 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED : spdk_nvme_command_specific_status_code = 27 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONTROLLER_LIST_INVALID : spdk_nvme_command_specific_status_code = 28 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS : spdk_nvme_command_specific_status_code = 29 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED : spdk_nvme_command_specific_status_code = 30 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_CTRLR_ID : spdk_nvme_command_specific_status_code = 31 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE : spdk_nvme_command_specific_status_code = 32 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES : spdk_nvme_command_specific_status_code = 33 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_RESOURCE_ID : spdk_nvme_command_specific_status_code = 34 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONFLICTING_ATTRIBUTES : spdk_nvme_command_specific_status_code = 128 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_PROTECTION_INFO : spdk_nvme_command_specific_status_code = 129 ; pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE : spdk_nvme_command_specific_status_code = 130 ; 
 /// Command specific status codes 
 pub type spdk_nvme_command_specific_status_code = u32 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_WRITE_FAULTS : spdk_nvme_media_error_status_code = 128 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_UNRECOVERED_READ_ERROR : spdk_nvme_media_error_status_code = 129 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_GUARD_CHECK_ERROR : spdk_nvme_media_error_status_code = 130 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 131 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR : spdk_nvme_media_error_status_code = 132 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_COMPARE_FAILURE : spdk_nvme_media_error_status_code = 133 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_ACCESS_DENIED : spdk_nvme_media_error_status_code = 134 ; pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK : spdk_nvme_media_error_status_code = 135 ; 
 /// Media error status codes 
 pub type spdk_nvme_media_error_status_code = u32 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_SQ : spdk_nvme_admin_opcode = 0 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_SQ : spdk_nvme_admin_opcode = 1 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LOG_PAGE : spdk_nvme_admin_opcode = 2 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_CQ : spdk_nvme_admin_opcode = 4 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_CQ : spdk_nvme_admin_opcode = 5 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_IDENTIFY : spdk_nvme_admin_opcode = 6 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ABORT : spdk_nvme_admin_opcode = 8 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SET_FEATURES : spdk_nvme_admin_opcode = 9 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_FEATURES : spdk_nvme_admin_opcode = 10 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ASYNC_EVENT_REQUEST : spdk_nvme_admin_opcode = 12 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_MANAGEMENT : spdk_nvme_admin_opcode = 13 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_COMMIT : spdk_nvme_admin_opcode = 16 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD : spdk_nvme_admin_opcode = 17 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DEVICE_SELF_TEST : spdk_nvme_admin_opcode = 20 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_ATTACHMENT : spdk_nvme_admin_opcode = 21 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_KEEP_ALIVE : spdk_nvme_admin_opcode = 24 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_SEND : spdk_nvme_admin_opcode = 25 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_RECEIVE : spdk_nvme_admin_opcode = 26 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT : spdk_nvme_admin_opcode = 28 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_SEND : spdk_nvme_admin_opcode = 29 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_RECEIVE : spdk_nvme_admin_opcode = 30 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG : spdk_nvme_admin_opcode = 124 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FORMAT_NVM : spdk_nvme_admin_opcode = 128 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_SEND : spdk_nvme_admin_opcode = 129 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_RECEIVE : spdk_nvme_admin_opcode = 130 ; pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SANITIZE : spdk_nvme_admin_opcode = 132 ; 
 /// Admin opcodes 
 pub type spdk_nvme_admin_opcode = u32 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_FLUSH : spdk_nvme_nvm_opcode = 0 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE : spdk_nvme_nvm_opcode = 1 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_READ : spdk_nvme_nvm_opcode = 2 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_UNCORRECTABLE : spdk_nvme_nvm_opcode = 4 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_COMPARE : spdk_nvme_nvm_opcode = 5 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_ZEROES : spdk_nvme_nvm_opcode = 8 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_DATASET_MANAGEMENT : spdk_nvme_nvm_opcode = 9 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REGISTER : spdk_nvme_nvm_opcode = 13 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REPORT : spdk_nvme_nvm_opcode = 14 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_ACQUIRE : spdk_nvme_nvm_opcode = 17 ; pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_RELEASE : spdk_nvme_nvm_opcode = 21 ; 
 /// NVM command set opcodes 
 pub type spdk_nvme_nvm_opcode = u32 ; 
 /// Opcode does not transfer data 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_NONE : spdk_nvme_data_transfer = 0 ; 
 /// Opcode transfers data from host to controller (e.g. Write) 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_HOST_TO_CONTROLLER : spdk_nvme_data_transfer = 1 ; 
 /// Opcode transfers data from controller to host (e.g. Read) 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_CONTROLLER_TO_HOST : spdk_nvme_data_transfer = 2 ; 
 /// Opcode transfers data both directions 
 pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_BIDIRECTIONAL : spdk_nvme_data_transfer = 3 ; 
 /// Data transfer (bits 1:0) of an NVMe opcode.
///
/// \sa spdk_nvme_opc_get_data_transfer 
 pub type spdk_nvme_data_transfer = u32 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ARBITRATION : spdk_nvme_feat = 1 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_POWER_MANAGEMENT : spdk_nvme_feat = 2 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_RANGE_TYPE : spdk_nvme_feat = 3 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD : spdk_nvme_feat = 4 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ERROR_RECOVERY : spdk_nvme_feat = 5 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE : spdk_nvme_feat = 6 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NUMBER_OF_QUEUES : spdk_nvme_feat = 7 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_COALESCING : spdk_nvme_feat = 8 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION : spdk_nvme_feat = 9 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_WRITE_ATOMICITY : spdk_nvme_feat = 10 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION : spdk_nvme_feat = 11 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION : spdk_nvme_feat = 12 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_MEM_BUFFER : spdk_nvme_feat = 13 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_TIMESTAMP : spdk_nvme_feat = 14 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_KEEP_ALIVE_TIMER : spdk_nvme_feat = 15 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT : spdk_nvme_feat = 16 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG : spdk_nvme_feat = 17 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER : spdk_nvme_feat = 128 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_IDENTIFIER : spdk_nvme_feat = 129 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_MASK : spdk_nvme_feat = 130 ; pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_PERSIST : spdk_nvme_feat = 131 ; pub type spdk_nvme_feat = u32 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_READ : spdk_nvme_dsm_attribute = 1 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE : spdk_nvme_dsm_attribute = 2 ; pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_DEALLOCATE : spdk_nvme_dsm_attribute = 4 ; pub type spdk_nvme_dsm_attribute = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_power_state { pub mp : u16 , pub reserved1 : u8 , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub enlat : u32 , pub exlat : u32 , pub _bitfield_2 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub reserved7 : [ u8 ; 16usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_power_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_power_state > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_power_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_power_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_power_state ) ) ) ; } impl spdk_nvme_power_state { # [ inline ] pub fn mps ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_mps ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nops ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_nops ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( mps : u8 , nops : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let mps : u8 = unsafe { :: std :: mem :: transmute ( mps ) } ; mps as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let nops : u8 = unsafe { :: std :: mem :: transmute ( nops ) } ; nops as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } # [ inline ] pub fn rrt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 0usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rrl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 8usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rrl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 8usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 13usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 13usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwt ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 16usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwt ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 16usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved5 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 21usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved5 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 21usize , 3u8 , val as u64 ) } } # [ inline ] pub fn rwl ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 24usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_rwl ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 24usize , 5u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_2 . get ( 29usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_2 . set ( 29usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_2 ( rrt : u8 , reserved3 : u8 , rrl : u8 , reserved4 : u8 , rwt : u8 , reserved5 : u8 , rwl : u8 , reserved6 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let rrt : u8 = unsafe { :: std :: mem :: transmute ( rrt ) } ; rrt as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 5u8 , { let rrl : u8 = unsafe { :: std :: mem :: transmute ( rrl ) } ; rrl as u64 } ) ; __bindgen_bitfield_unit . set ( 13usize , 3u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 5u8 , { let rwt : u8 = unsafe { :: std :: mem :: transmute ( rwt ) } ; rwt as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 3u8 , { let reserved5 : u8 = unsafe { :: std :: mem :: transmute ( reserved5 ) } ; reserved5 as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 5u8 , { let rwl : u8 = unsafe { :: std :: mem :: transmute ( rwl ) } ; rwl as u64 } ) ; __bindgen_bitfield_unit . set ( 29usize , 3u8 , { let reserved6 : u8 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// Identify namespace indicated in CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS : spdk_nvme_identify_cns = 0 ; 
 /// Identify controller 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR : spdk_nvme_identify_cns = 1 ; 
 /// List active NSIDs greater than CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST : spdk_nvme_identify_cns = 2 ; 
 /// List namespace identification descriptors 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST : spdk_nvme_identify_cns = 3 ; 
 /// List allocated NSIDs greater than CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST : spdk_nvme_identify_cns = 16 ; 
 /// Identify namespace if CDW1.NSID is allocated 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED : spdk_nvme_identify_cns = 17 ; 
 /// Get list of controllers starting at CDW10.CNTID that are attached to CDW1.NSID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST : spdk_nvme_identify_cns = 18 ; 
 /// Get list of controllers starting at CDW10.CNTID 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_LIST : spdk_nvme_identify_cns = 19 ; 
 /// Get primary controller capabilities structure 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP : spdk_nvme_identify_cns = 20 ; 
 /// Get secondary controller list 
 pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST : spdk_nvme_identify_cns = 21 ; 
 /// Identify command CNS value 
 pub type spdk_nvme_identify_cns = u32 ; 
 /// NVM subsystem uses dynamic controller model 
 pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_DYNAMIC : spdk_nvmf_ctrlr_model = 0 ; 
 /// NVM subsystem uses static controller model 
 pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_STATIC : spdk_nvmf_ctrlr_model = 1 ; 
 /// NVMe over Fabrics controller model 
 pub type spdk_nvmf_ctrlr_model = u32 ; 
 /// SGLs are not supported 
 pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_NOT_SUPPORTED : spdk_nvme_sgls_supported = 0 ; 
 /// SGLs are supported with no alignment or granularity requirement. 
 pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED : spdk_nvme_sgls_supported = 1 ; 
 /// SGLs are supported with a DWORD alignment and granularity requirement. 
 pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED : spdk_nvme_sgls_supported = 2 ; 
 /// Identify Controller data sgls.supported values 
 pub type spdk_nvme_sgls_supported = u32 ; # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data { 
 /// pci vendor id 
 pub vid : u16 , 
 /// pci subsystem vendor id 
 pub ssvid : u16 , 
 /// serial number 
 pub sn : [ i8 ; 20usize ] , 
 /// model number 
 pub mn : [ i8 ; 40usize ] , 
 /// firmware revision 
 pub fr : [ u8 ; 8usize ] , 
 /// recommended arbitration burst 
 pub rab : u8 , 
 /// ieee oui identifier 
 pub ieee : [ u8 ; 3usize ] , pub cmic : spdk_nvme_ctrlr_data__bindgen_ty_1 , 
 /// maximum data transfer size 
 pub mdts : u8 , 
 /// controller id 
 pub cntlid : u16 , 
 /// version 
 pub ver : spdk_nvme_vs_register , 
 /// RTD3 resume latency 
 pub rtd3r : u32 , 
 /// RTD3 entry latency 
 pub rtd3e : u32 , pub oaes : spdk_nvme_ctrlr_data__bindgen_ty_2 , pub ctratt : spdk_nvme_ctrlr_data__bindgen_ty_3 , pub reserved_100 : [ u8 ; 12usize ] , 
 /// FRU globally unique identifier 
 pub fguid : [ u8 ; 16usize ] , pub reserved_128 : [ u8 ; 128usize ] , pub oacs : spdk_nvme_ctrlr_data__bindgen_ty_4 , 
 /// abort command limit 
 pub acl : u8 , 
 /// asynchronous event request limit 
 pub aerl : u8 , pub frmw : spdk_nvme_ctrlr_data__bindgen_ty_5 , pub lpa : spdk_nvme_ctrlr_data__bindgen_ty_6 , 
 /// error log page entries 
 pub elpe : u8 , 
 /// number of power states supported 
 pub npss : u8 , pub avscc : spdk_nvme_ctrlr_data__bindgen_ty_7 , pub apsta : spdk_nvme_ctrlr_data__bindgen_ty_8 , 
 /// warning composite temperature threshold 
 pub wctemp : u16 , 
 /// critical composite temperature threshold 
 pub cctemp : u16 , 
 /// maximum time for firmware activation 
 pub mtfa : u16 , 
 /// host memory buffer preferred size 
 pub hmpre : u32 , 
 /// host memory buffer minimum size 
 pub hmmin : u32 , 
 /// total NVM capacity 
 pub tnvmcap : [ u64 ; 2usize ] , 
 /// unallocated NVM capacity 
 pub unvmcap : [ u64 ; 2usize ] , pub rpmbs : spdk_nvme_ctrlr_data__bindgen_ty_9 , 
 /// extended device self-test time (in minutes) 
 pub edstt : u16 , pub dsto : spdk_nvme_ctrlr_data__bindgen_ty_10 , 
 /// Firmware update granularity
    ///
    /// 4KB units
    /// 0x00 = no information provided
    /// 0xFF = no restriction 
 pub fwug : u8 , 
 /// Keep Alive Support
    ///
    /// Granularity of keep alive timer in 100 ms units
    /// 0 = keep alive not supported 
 pub kas : u16 , pub hctma : spdk_nvme_ctrlr_data__bindgen_ty_11 , 
 /// Minimum thermal management temperature 
 pub mntmt : u16 , 
 /// Maximum thermal management temperature 
 pub mxtmt : u16 , pub sanicap : spdk_nvme_ctrlr_data__bindgen_ty_12 , pub reserved3 : [ u8 ; 180usize ] , pub sqes : spdk_nvme_ctrlr_data__bindgen_ty_13 , pub cqes : spdk_nvme_ctrlr_data__bindgen_ty_14 , pub maxcmd : u16 , 
 /// number of namespaces 
 pub nn : u32 , pub oncs : spdk_nvme_ctrlr_data__bindgen_ty_15 , 
 /// fused operation support 
 pub fuses : u16 , pub fna : spdk_nvme_ctrlr_data__bindgen_ty_16 , pub vwc : spdk_nvme_ctrlr_data__bindgen_ty_17 , 
 /// atomic write unit normal 
 pub awun : u16 , 
 /// atomic write unit power fail 
 pub awupf : u16 , 
 /// NVM vendor specific command configuration 
 pub nvscc : u8 , pub reserved531 : u8 , 
 /// atomic compare & write unit 
 pub acwu : u16 , pub reserved534 : u16 , pub sgls : spdk_nvme_ctrlr_data__bindgen_ty_18 , pub reserved4 : [ u8 ; 228usize ] , pub subnqn : [ u8 ; 256usize ] , pub reserved5 : [ u8 ; 768usize ] , pub nvmf_specific : spdk_nvme_ctrlr_data__bindgen_ty_19 , pub psd : [ spdk_nvme_power_state ; 32usize ] , pub vs : [ u8 ; 1024usize ] , } 
 /// controller multi-path I/O and namespace sharing capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn multi_port ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_port ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn multi_host ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_multi_host ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sr_iov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_sr_iov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( multi_port : u8 , multi_host : u8 , sr_iov : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let multi_port : u8 = unsafe { :: std :: mem :: transmute ( multi_port ) } ; multi_port as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let multi_host : u8 = unsafe { :: std :: mem :: transmute ( multi_host ) } ; multi_host as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let sr_iov : u8 = unsafe { :: std :: mem :: transmute ( sr_iov ) } ; sr_iov as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// optional asynchronous events supported 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_2 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_2 { # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn ns_attribute_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attribute_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notices ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notices ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 10usize , 22u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 10usize , 22u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( reserved1 : u32 , ns_attribute_notices : u32 , fw_activation_notices : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let ns_attribute_notices : u32 = unsafe { :: std :: mem :: transmute ( ns_attribute_notices ) } ; ns_attribute_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 1u8 , { let fw_activation_notices : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notices ) } ; fw_activation_notices as u64 } ) ; __bindgen_bitfield_unit . set ( 10usize , 22u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// controller attributes 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_3 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_3 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_3 { # [ inline ] pub fn host_id_exhid_supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_host_id_exhid_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn non_operational_power_state_permissive_mode ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_non_operational_power_state_permissive_mode ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( host_id_exhid_supported : u32 , non_operational_power_state_permissive_mode : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let host_id_exhid_supported : u32 = unsafe { :: std :: mem :: transmute ( host_id_exhid_supported ) } ; host_id_exhid_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let non_operational_power_state_permissive_mode : u32 = unsafe { :: std :: mem :: transmute ( non_operational_power_state_permissive_mode ) } ; non_operational_power_state_permissive_mode as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// optional admin command support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_4 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_4 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_4 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_4 { # [ inline ] pub fn security ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_security ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn format ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_format ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn firmware ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_firmware ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_manage ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ns_manage ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_self_test ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_device_self_test ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn directives ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_directives ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nvme_mi ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nvme_mi ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn virtualization_management ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_virtualization_management ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn doorbell_buffer_config ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_doorbell_buffer_config ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oacs_rsvd ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 7u8 ) as u16 ) } } # [ inline ] pub fn set_oacs_rsvd ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( security : u16 , format : u16 , firmware : u16 , ns_manage : u16 , device_self_test : u16 , directives : u16 , nvme_mi : u16 , virtualization_management : u16 , doorbell_buffer_config : u16 , oacs_rsvd : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let security : u16 = unsafe { :: std :: mem :: transmute ( security ) } ; security as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let format : u16 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let firmware : u16 = unsafe { :: std :: mem :: transmute ( firmware ) } ; firmware as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let ns_manage : u16 = unsafe { :: std :: mem :: transmute ( ns_manage ) } ; ns_manage as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let device_self_test : u16 = unsafe { :: std :: mem :: transmute ( device_self_test ) } ; device_self_test as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let directives : u16 = unsafe { :: std :: mem :: transmute ( directives ) } ; directives as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let nvme_mi : u16 = unsafe { :: std :: mem :: transmute ( nvme_mi ) } ; nvme_mi as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let virtualization_management : u16 = unsafe { :: std :: mem :: transmute ( virtualization_management ) } ; virtualization_management as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let doorbell_buffer_config : u16 = unsafe { :: std :: mem :: transmute ( doorbell_buffer_config ) } ; doorbell_buffer_config as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 7u8 , { let oacs_rsvd : u16 = unsafe { :: std :: mem :: transmute ( oacs_rsvd ) } ; oacs_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// firmware updates 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_5 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_5 { # [ inline ] pub fn slot1_ro ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_slot1_ro ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn num_slots ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_slots ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 3u8 , val as u64 ) } } # [ inline ] pub fn activation_without_reset ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_activation_without_reset ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn frmw_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_frmw_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( slot1_ro : u8 , num_slots : u8 , activation_without_reset : u8 , frmw_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let slot1_ro : u8 = unsafe { :: std :: mem :: transmute ( slot1_ro ) } ; slot1_ro as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 3u8 , { let num_slots : u8 = unsafe { :: std :: mem :: transmute ( num_slots ) } ; num_slots as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let activation_without_reset : u8 = unsafe { :: std :: mem :: transmute ( activation_without_reset ) } ; activation_without_reset as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let frmw_rsvd : u8 = unsafe { :: std :: mem :: transmute ( frmw_rsvd ) } ; frmw_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// log page attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_6 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_6 { # [ inline ] pub fn ns_smart ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_smart ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn celp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_celp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn edlp ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_edlp ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_telemetry ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lpa_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_lpa_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_smart : u8 , celp : u8 , edlp : u8 , telemetry : u8 , lpa_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_smart : u8 = unsafe { :: std :: mem :: transmute ( ns_smart ) } ; ns_smart as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let celp : u8 = unsafe { :: std :: mem :: transmute ( celp ) } ; celp as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let edlp : u8 = unsafe { :: std :: mem :: transmute ( edlp ) } ; edlp as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let telemetry : u8 = unsafe { :: std :: mem :: transmute ( telemetry ) } ; telemetry as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let lpa_rsvd : u8 = unsafe { :: std :: mem :: transmute ( lpa_rsvd ) } ; lpa_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// admin vendor specific command configuration 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_7 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_7 { # [ inline ] pub fn spec_format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_spec_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn avscc_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_avscc_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( spec_format : u8 , avscc_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let spec_format : u8 = unsafe { :: std :: mem :: transmute ( spec_format ) } ; spec_format as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let avscc_rsvd : u8 = unsafe { :: std :: mem :: transmute ( avscc_rsvd ) } ; avscc_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// autonomous power state transition attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_8 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_8 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_8 { # [ inline ] pub fn supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn apsta_rsvd ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_apsta_rsvd ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u8 , apsta_rsvd : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u8 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let apsta_rsvd : u8 = unsafe { :: std :: mem :: transmute ( apsta_rsvd ) } ; apsta_rsvd as u64 } ) ; __bindgen_bitfield_unit } } 
 /// replay protected memory block support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , pub reserved2 : u8 , pub total_size : u8 , pub access_size : u8 , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_9 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_9 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_9 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_9 { # [ inline ] pub fn num_rpmb_units ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_num_rpmb_units ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn auth_method ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_auth_method ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 2u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 2u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num_rpmb_units : u8 , auth_method : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let num_rpmb_units : u8 = unsafe { :: std :: mem :: transmute ( num_rpmb_units ) } ; num_rpmb_units as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let auth_method : u8 = unsafe { :: std :: mem :: transmute ( auth_method ) } ; auth_method as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 2u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// device self-test options 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_10 { pub raw : u8 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 { # [ inline ] pub fn one_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_one_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( one_only : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let one_only : u8 = unsafe { :: std :: mem :: transmute ( one_only ) } ; one_only as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_10 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_10 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_10 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Host controlled thermal management attributes 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_11 { pub raw : u16 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 , _bindgen_union_align : u16 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 { # [ inline ] pub fn supported ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 15u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let supported : u16 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 15u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_11 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_11 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_11 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Sanitize capabilities 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ctrlr_data__bindgen_ty_12 { pub raw : u32 , pub bits : spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 { # [ inline ] pub fn crypto_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_crypto_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn block_erase ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_block_erase ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn overwrite ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_overwrite ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 29u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 29u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( crypto_erase : u32 , block_erase : u32 , overwrite : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let crypto_erase : u32 = unsafe { :: std :: mem :: transmute ( crypto_erase ) } ; crypto_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let block_erase : u32 = unsafe { :: std :: mem :: transmute ( block_erase ) } ; block_erase as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let overwrite : u32 = unsafe { :: std :: mem :: transmute ( overwrite ) } ; overwrite as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 29u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_12 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_12 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_12 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// submission queue entry size 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_13 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_13 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_13 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_13 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_13 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_13 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } 
 /// completion queue entry size 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_14 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_14 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_14 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_14 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_14 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_14 { # [ inline ] pub fn min ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_min ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn max ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_max ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( min : u8 , max : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let min : u8 = unsafe { :: std :: mem :: transmute ( min ) } ; min as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let max : u8 = unsafe { :: std :: mem :: transmute ( max ) } ; max as u64 } ) ; __bindgen_bitfield_unit } } 
 /// optional nvm command support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_15 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_15 > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_15 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_15 > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_15 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_15 { # [ inline ] pub fn compare ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_compare ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_unc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_unc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dsm ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_dsm ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_zeroes ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_write_zeroes ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn set_features_save ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_set_features_save ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reservations ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_reservations ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn timestamp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_timestamp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 9u8 ) as u16 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 9u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( compare : u16 , write_unc : u16 , dsm : u16 , write_zeroes : u16 , set_features_save : u16 , reservations : u16 , timestamp : u16 , reserved : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 2usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let compare : u16 = unsafe { :: std :: mem :: transmute ( compare ) } ; compare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_unc : u16 = unsafe { :: std :: mem :: transmute ( write_unc ) } ; write_unc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dsm : u16 = unsafe { :: std :: mem :: transmute ( dsm ) } ; dsm as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zeroes : u16 = unsafe { :: std :: mem :: transmute ( write_zeroes ) } ; write_zeroes as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let set_features_save : u16 = unsafe { :: std :: mem :: transmute ( set_features_save ) } ; set_features_save as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let reservations : u16 = unsafe { :: std :: mem :: transmute ( reservations ) } ; reservations as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let timestamp : u16 = unsafe { :: std :: mem :: transmute ( timestamp ) } ; timestamp as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 9u8 , { let reserved : u16 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// format nvm attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_16 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_16 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_16 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_16 { # [ inline ] pub fn format_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_format_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn erase_all_ns ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_erase_all_ns ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn crypto_erase_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_crypto_erase_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format_all_ns : u8 , erase_all_ns : u8 , crypto_erase_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let format_all_ns : u8 = unsafe { :: std :: mem :: transmute ( format_all_ns ) } ; format_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let erase_all_ns : u8 = unsafe { :: std :: mem :: transmute ( erase_all_ns ) } ; erase_all_ns as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let crypto_erase_supported : u8 = unsafe { :: std :: mem :: transmute ( crypto_erase_supported ) } ; crypto_erase_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// volatile write cache 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_17 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_17 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_17 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_17 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_17 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_17 { # [ inline ] pub fn present ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_present ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( present : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let present : u8 = unsafe { :: std :: mem :: transmute ( present ) } ; present as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// SGL support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_18 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_18 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_18 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_18 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_18 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_18 { # [ inline ] pub fn supported ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_supported ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 2u8 , val as u64 ) } } # [ inline ] pub fn keyed_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_keyed_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 13u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 13u8 , val as u64 ) } } # [ inline ] pub fn bit_bucket_descriptor ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_bit_bucket_descriptor ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_pointer ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_pointer ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 1u8 , val as u64 ) } } # [ inline ] pub fn oversized_sgl ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 18usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_oversized_sgl ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 18usize , 1u8 , val as u64 ) } } # [ inline ] pub fn metadata_address ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_metadata_address ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 1u8 , val as u64 ) } } # [ inline ] pub fn sgl_offset ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_sgl_offset ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 21usize , 11u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 21usize , 11u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( supported : u32 , keyed_sgl : u32 , reserved1 : u32 , bit_bucket_descriptor : u32 , metadata_pointer : u32 , oversized_sgl : u32 , metadata_address : u32 , sgl_offset : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 2u8 , { let supported : u32 = unsafe { :: std :: mem :: transmute ( supported ) } ; supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let keyed_sgl : u32 = unsafe { :: std :: mem :: transmute ( keyed_sgl ) } ; keyed_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 13u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let bit_bucket_descriptor : u32 = unsafe { :: std :: mem :: transmute ( bit_bucket_descriptor ) } ; bit_bucket_descriptor as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 1u8 , { let metadata_pointer : u32 = unsafe { :: std :: mem :: transmute ( metadata_pointer ) } ; metadata_pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 18usize , 1u8 , { let oversized_sgl : u32 = unsafe { :: std :: mem :: transmute ( oversized_sgl ) } ; oversized_sgl as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 1u8 , { let metadata_address : u32 = unsafe { :: std :: mem :: transmute ( metadata_address ) } ; metadata_address as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 1u8 , { let sgl_offset : u32 = unsafe { :: std :: mem :: transmute ( sgl_offset ) } ; sgl_offset as u64 } ) ; __bindgen_bitfield_unit . set ( 21usize , 11u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// NVMe over Fabrics-specific fields 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 { 
 /// I/O queue command capsule supported size (16-byte units) 
 pub ioccsz : u32 , 
 /// I/O queue response capsule supported size (16-byte units) 
 pub iorcsz : u32 , 
 /// In-capsule data offset (16-byte units) 
 pub icdoff : u16 , pub ctrattr : spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 , 
 /// Maximum SGL block descriptors (0 = no limit) 
 pub msdbd : u8 , pub reserved : [ u8 ; 244usize ] , } 
 /// Controller attributes 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ctrlr_data__bindgen_ty_19__bindgen_ty_1 { # [ inline ] pub fn ctrlr_model ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ctrlr_model ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ctrlr_model : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ctrlr_model : u8 = unsafe { :: std :: mem :: transmute ( ctrlr_model ) } ; ctrlr_model as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19 > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data__bindgen_ty_19 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data__bindgen_ty_19 ) ) ) ; } impl Default for spdk_nvme_ctrlr_data__bindgen_ty_19 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_data > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_data ) ) ) ; } impl Default for spdk_nvme_ctrlr_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities { 
 /// controller id 
 pub cntlid : u16 , 
 /// port identifier 
 pub portid : u16 , pub crt : spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 , pub reserved : [ u8 ; 27usize ] , 
 /// total number of VQ flexible resources 
 pub vqfrt : u32 , 
 /// total number of VQ flexible resources assigned to secondary controllers 
 pub vqrfa : u32 , 
 /// total number of VQ flexible resources allocated to primary controller 
 pub vqrfap : u16 , 
 /// total number of VQ Private resources for the primary controller 
 pub vqprt : u16 , 
 /// max number of VQ flexible Resources that may be assigned to a secondary controller 
 pub vqfrsm : u16 , 
 /// preferred granularity of assigning and removing VQ Flexible Resources 
 pub vqgran : u16 , pub reserved1 : [ u8 ; 16usize ] , 
 /// total number of VI flexible resources for the primary and its secondary controllers 
 pub vifrt : u32 , 
 /// total number of VI flexible resources assigned to the secondary controllers 
 pub virfa : u32 , 
 /// total number of VI flexible resources currently allocated to the primary controller 
 pub virfap : u16 , 
 /// total number of VI private resources for the primary controller 
 pub viprt : u16 , 
 /// max number of VI flexible resources that may be assigned to a secondary controller 
 pub vifrsm : u16 , 
 /// preferred granularity of assigning and removing VI flexible resources 
 pub vigran : u16 , pub reserved2 : [ u8 ; 4016usize ] , } 
 /// controller resource types 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 { # [ inline ] pub fn vq_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vq_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn vi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_vi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( vq_supported : u8 , vi_supported : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let vq_supported : u8 = unsafe { :: std :: mem :: transmute ( vq_supported ) } ; vq_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let vi_supported : u8 = unsafe { :: std :: mem :: transmute ( vi_supported ) } ; vi_supported as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_primary_ctrl_capabilities > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_primary_ctrl_capabilities ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_primary_ctrl_capabilities > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_primary_ctrl_capabilities ) ) ) ; } impl Default for spdk_nvme_primary_ctrl_capabilities { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry { 
 /// controller identifier of the secondary controller 
 pub scid : u16 , 
 /// controller identifier of the associated primary controller 
 pub pcid : u16 , pub scs : spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 , pub reserved : [ u8 ; 3usize ] , 
 /// VF number if the secondary controller is an SR-IOV VF 
 pub vfn : u16 , 
 /// number of VQ flexible resources assigned to the indicated secondary controller 
 pub nvq : u16 , 
 /// number of VI flexible resources assigned to the indicated secondary controller 
 pub nvi : u16 , pub reserved1 : [ u8 ; 18usize ] , } 
 /// indicates the state of the secondary controller 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 { # [ inline ] pub fn is_online ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_is_online ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( is_online : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let is_online : u8 = unsafe { :: std :: mem :: transmute ( is_online ) } ; is_online as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_secondary_ctrl_entry > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_secondary_ctrl_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_secondary_ctrl_entry > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_secondary_ctrl_entry ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_secondary_ctrl_list { 
 /// number of Secondary controller entries in the list 
 pub number : u8 , pub reserved : [ u8 ; 31usize ] , pub entries : [ spdk_nvme_secondary_ctrl_entry ; 127usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_secondary_ctrl_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_secondary_ctrl_list > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_secondary_ctrl_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_secondary_ctrl_list > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_secondary_ctrl_list ) ) ) ; } impl Default for spdk_nvme_secondary_ctrl_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_data { 
 /// namespace size 
 pub nsze : u64 , 
 /// namespace capacity 
 pub ncap : u64 , 
 /// namespace utilization 
 pub nuse : u64 , pub nsfeat : spdk_nvme_ns_data__bindgen_ty_1 , 
 /// number of lba formats 
 pub nlbaf : u8 , pub flbas : spdk_nvme_ns_data__bindgen_ty_2 , pub mc : spdk_nvme_ns_data__bindgen_ty_3 , pub dpc : spdk_nvme_ns_data__bindgen_ty_4 , pub dps : spdk_nvme_ns_data__bindgen_ty_5 , pub nmic : spdk_nvme_ns_data__bindgen_ty_6 , pub nsrescap : spdk_nvme_ns_data__bindgen_ty_7 , pub fpi : spdk_nvme_ns_data__bindgen_ty_8 , pub dlfeat : spdk_nvme_ns_data__bindgen_ty_9 , 
 /// namespace atomic write unit normal 
 pub nawun : u16 , 
 /// namespace atomic write unit power fail 
 pub nawupf : u16 , 
 /// namespace atomic compare & write unit 
 pub nacwu : u16 , 
 /// namespace atomic boundary size normal 
 pub nabsn : u16 , 
 /// namespace atomic boundary offset 
 pub nabo : u16 , 
 /// namespace atomic boundary size power fail 
 pub nabspf : u16 , 
 /// namespace optimal I/O boundary in logical blocks 
 pub noiob : u16 , 
 /// NVM capacity 
 pub nvmcap : [ u64 ; 2usize ] , pub reserved64 : [ u8 ; 40usize ] , 
 /// namespace globally unique identifier 
 pub nguid : [ u8 ; 16usize ] , 
 /// IEEE extended unique identifier 
 pub eui64 : u64 , pub lbaf : [ spdk_nvme_ns_data__bindgen_ty_10 ; 16usize ] , pub reserved6 : [ u8 ; 192usize ] , pub vendor_specific : [ u8 ; 3712usize ] , } 
 /// namespace features 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_1 { # [ inline ] pub fn thin_prov ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_thin_prov ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ns_atomic_write_unit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ns_atomic_write_unit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn dealloc_or_unwritten_error ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_dealloc_or_unwritten_error ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guid_never_reused ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guid_never_reused ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( thin_prov : u8 , ns_atomic_write_unit : u8 , dealloc_or_unwritten_error : u8 , guid_never_reused : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let thin_prov : u8 = unsafe { :: std :: mem :: transmute ( thin_prov ) } ; thin_prov as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let ns_atomic_write_unit : u8 = unsafe { :: std :: mem :: transmute ( ns_atomic_write_unit ) } ; ns_atomic_write_unit as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let dealloc_or_unwritten_error : u8 = unsafe { :: std :: mem :: transmute ( dealloc_or_unwritten_error ) } ; dealloc_or_unwritten_error as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let guid_never_reused : u8 = unsafe { :: std :: mem :: transmute ( guid_never_reused ) } ; guid_never_reused as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// formatted lba size 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_2 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_2 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_2 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_2 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_2 { # [ inline ] pub fn format ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_format ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( format : u8 , extended : u8 , reserved2 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let format : u8 = unsafe { :: std :: mem :: transmute ( format ) } ; format as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved2 : u8 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// metadata capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_3 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_3 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_3 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_3 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_3 { # [ inline ] pub fn extended ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_extended ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pointer ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pointer ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 6u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( extended : u8 , pointer : u8 , reserved3 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let extended : u8 = unsafe { :: std :: mem :: transmute ( extended ) } ; extended as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pointer : u8 = unsafe { :: std :: mem :: transmute ( pointer ) } ; pointer as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 6u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// end-to-end data protection capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_4 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_4 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_4 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_4 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_4 { # [ inline ] pub fn pit1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit2 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit2 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pit3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_pit3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn md_end ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_end ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit1 : u8 , pit2 : u8 , pit3 : u8 , md_start : u8 , md_end : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let pit1 : u8 = unsafe { :: std :: mem :: transmute ( pit1 ) } ; pit1 as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let pit2 : u8 = unsafe { :: std :: mem :: transmute ( pit2 ) } ; pit2 as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let pit3 : u8 = unsafe { :: std :: mem :: transmute ( pit3 ) } ; pit3 as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let md_end : u8 = unsafe { :: std :: mem :: transmute ( md_end ) } ; md_end as u64 } ) ; __bindgen_bitfield_unit } } 
 /// end-to-end data protection type settings 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_5 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_5 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_5 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_5 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_5 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_5 { # [ inline ] pub fn pit ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_pit ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn md_start ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_md_start ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved4 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 4u8 ) as u8 ) } } # [ inline ] pub fn set_reserved4 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 4u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pit : u8 , md_start : u8 , reserved4 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let pit : u8 = unsafe { :: std :: mem :: transmute ( pit ) } ; pit as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let md_start : u8 = unsafe { :: std :: mem :: transmute ( md_start ) } ; md_start as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 4u8 , { let reserved4 : u8 = unsafe { :: std :: mem :: transmute ( reserved4 ) } ; reserved4 as u64 } ) ; __bindgen_bitfield_unit } } 
 /// namespace multi-path I/O and namespace sharing capabilities 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_6 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_6 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_6 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_6 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_6 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_6 { # [ inline ] pub fn can_share ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_can_share ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( can_share : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let can_share : u8 = unsafe { :: std :: mem :: transmute ( can_share ) } ; can_share as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } 
 /// reservation capabilities 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_7 { pub rescap : spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 , pub raw : u8 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 { # [ inline ] pub fn persist ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_persist ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_reg_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_reg_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn write_exclusive_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_exclusive_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 1u8 , val as u64 ) } } # [ inline ] pub fn exclusive_access_all_reg ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_exclusive_access_all_reg ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ignore_existing_key ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_ignore_existing_key ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( persist : u8 , write_exclusive : u8 , exclusive_access : u8 , write_exclusive_reg_only : u8 , exclusive_access_reg_only : u8 , write_exclusive_all_reg : u8 , exclusive_access_all_reg : u8 , ignore_existing_key : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let persist : u8 = unsafe { :: std :: mem :: transmute ( persist ) } ; persist as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let write_exclusive : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive ) } ; write_exclusive as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let exclusive_access : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access ) } ; exclusive_access as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_exclusive_reg_only : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_reg_only ) } ; write_exclusive_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let exclusive_access_reg_only : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_reg_only ) } ; exclusive_access_reg_only as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 1u8 , { let write_exclusive_all_reg : u8 = unsafe { :: std :: mem :: transmute ( write_exclusive_all_reg ) } ; write_exclusive_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 1u8 , { let exclusive_access_all_reg : u8 = unsafe { :: std :: mem :: transmute ( exclusive_access_all_reg ) } ; exclusive_access_all_reg as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let ignore_existing_key : u8 = unsafe { :: std :: mem :: transmute ( ignore_existing_key ) } ; ignore_existing_key as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_7 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_7 ) ) ) ; } impl Default for spdk_nvme_ns_data__bindgen_ty_7 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// format progress indicator 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_8 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_8 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_8 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_8 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_8 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_8 { # [ inline ] pub fn percentage_remaining ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_percentage_remaining ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 7u8 , val as u64 ) } } # [ inline ] pub fn fpi_supported ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_fpi_supported ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( percentage_remaining : u8 , fpi_supported : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 7u8 , { let percentage_remaining : u8 = unsafe { :: std :: mem :: transmute ( percentage_remaining ) } ; percentage_remaining as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let fpi_supported : u8 = unsafe { :: std :: mem :: transmute ( fpi_supported ) } ; fpi_supported as u64 } ) ; __bindgen_bitfield_unit } } 
 /// deallocate logical features 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_ns_data__bindgen_ty_9 { pub raw : u8 , pub bits : spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 { # [ inline ] pub fn read_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_read_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn write_zero_deallocate ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_write_zero_deallocate ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn guard_value ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_guard_value ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( read_value : u8 , write_zero_deallocate : u8 , guard_value : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let read_value : u8 = unsafe { :: std :: mem :: transmute ( read_value ) } ; read_value as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let write_zero_deallocate : u8 = unsafe { :: std :: mem :: transmute ( write_zero_deallocate ) } ; write_zero_deallocate as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let guard_value : u8 = unsafe { :: std :: mem :: transmute ( guard_value ) } ; guard_value as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_9 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_9 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_9 ) ) ) ; } impl Default for spdk_nvme_ns_data__bindgen_ty_9 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// lba format support 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_ns_data__bindgen_ty_10 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_10 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data__bindgen_ty_10 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_10 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data__bindgen_ty_10 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data__bindgen_ty_10 ) ) ) ; } impl spdk_nvme_ns_data__bindgen_ty_10 { # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn lbads ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lbads ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn rp ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_rp ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved6 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 26usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_reserved6 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 26usize , 6u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ms : u32 , lbads : u32 , rp : u32 , reserved6 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let lbads : u32 = unsafe { :: std :: mem :: transmute ( lbads ) } ; lbads as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 2u8 , { let rp : u32 = unsafe { :: std :: mem :: transmute ( rp ) } ; rp as u64 } ) ; __bindgen_bitfield_unit . set ( 26usize , 6u8 , { let reserved6 : u32 = unsafe { :: std :: mem :: transmute ( reserved6 ) } ; reserved6 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_data > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_data ) ) ) ; } impl Default for spdk_nvme_ns_data { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Not reported 
 pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_NOT_REPORTED : spdk_nvme_dealloc_logical_block_read_value = 0 ; 
 /// Deallocated blocks read 0x00 
 pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_00 : spdk_nvme_dealloc_logical_block_read_value = 1 ; 
 /// Deallocated blocks read 0xFF 
 pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_FF : spdk_nvme_dealloc_logical_block_read_value = 2 ; 
 /// Deallocated logical block features - read value 
 pub type spdk_nvme_dealloc_logical_block_read_value = u32 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE : spdk_nvme_reservation_type = 1 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS : spdk_nvme_reservation_type = 2 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY : spdk_nvme_reservation_type = 3 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY : spdk_nvme_reservation_type = 4 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS : spdk_nvme_reservation_type = 5 ; pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS : spdk_nvme_reservation_type = 6 ; 
 /// Reservation Type Encoding 
 pub type spdk_nvme_reservation_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_acquire_data { 
 /// current reservation key 
 pub crkey : u64 , 
 /// preempt reservation key 
 pub prkey : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_acquire_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_acquire_data > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_acquire_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_acquire_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_acquire_data ) ) ) ; } pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_ACQUIRE : spdk_nvme_reservation_acquire_action = 0 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT : spdk_nvme_reservation_acquire_action = 1 ; pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT_ABORT : spdk_nvme_reservation_acquire_action = 2 ; 
 /// Reservation Acquire action 
 pub type spdk_nvme_reservation_acquire_action = u32 ; # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_status_data { 
 /// reservation action generation counter 
 pub generation : u32 , 
 /// reservation type 
 pub type_ : u8 , 
 /// number of registered controllers 
 pub nr_regctl : u16 , pub reserved1 : u16 , 
 /// persist through power loss state 
 pub ptpl_state : u8 , pub reserved : [ u8 ; 14usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_status_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_status_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_status_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_status_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_status_data ) ) ) ; } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_ctrlr_data { pub ctrlr_id : u16 , pub rcsts : spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 , pub reserved2 : [ u8 ; 5usize ] , 
 /// host identifier 
 pub host_id : u64 , 
 /// reservation key 
 pub key : u64 , } 
 /// reservation status 
 # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_reservation_ctrlr_data__bindgen_ty_1 { # [ inline ] pub fn status ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_status ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 7u8 ) as u8 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 7u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( status : u8 , reserved1 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let status : u8 = unsafe { :: std :: mem :: transmute ( status ) } ; status as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 7u8 , { let reserved1 : u8 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_ctrlr_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_ctrlr_data > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_ctrlr_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_ctrlr_data > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_ctrlr_data ) ) ) ; } pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_NO_CHANGES : spdk_nvme_reservation_register_cptpl = 0 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON : spdk_nvme_reservation_register_cptpl = 2 ; pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS : spdk_nvme_reservation_register_cptpl = 3 ; 
 /// Change persist through power loss state for
/// Reservation Register command 
 pub type spdk_nvme_reservation_register_cptpl = u32 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REGISTER_KEY : spdk_nvme_reservation_register_action = 0 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_UNREGISTER_KEY : spdk_nvme_reservation_register_action = 1 ; pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REPLACE_KEY : spdk_nvme_reservation_register_action = 2 ; 
 /// Registration action for Reservation Register command 
 pub type spdk_nvme_reservation_register_action = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_register_data { 
 /// current reservation key 
 pub crkey : u64 , 
 /// new reservation key 
 pub nrkey : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_register_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_register_data > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_register_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_register_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_register_data ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_reservation_key_data { 
 /// current reservation key 
 pub crkey : u64 , } # [ test ] fn bindgen_test_layout_spdk_nvme_reservation_key_data ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_reservation_key_data > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_reservation_key_data ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_reservation_key_data > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_reservation_key_data ) ) ) ; } pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_RELEASE : spdk_nvme_reservation_release_action = 0 ; pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_CLEAR : spdk_nvme_reservation_release_action = 1 ; 
 /// Reservation Release action 
 pub type spdk_nvme_reservation_release_action = u32 ; 
 /// Error information (mandatory) - \ref spdk_nvme_error_information_entry 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_ERROR : spdk_nvme_log_page = 1 ; 
 /// SMART / health information (mandatory) - \ref spdk_nvme_health_information_page 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_HEALTH_INFORMATION : spdk_nvme_log_page = 2 ; 
 /// Firmware slot information (mandatory) - \ref spdk_nvme_firmware_page 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_FIRMWARE_SLOT : spdk_nvme_log_page = 3 ; 
 /// Changed namespace list (optional) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_CHANGED_NS_LIST : spdk_nvme_log_page = 4 ; 
 /// Command effects log (optional) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_COMMAND_EFFECTS_LOG : spdk_nvme_log_page = 5 ; 
 /// Discovery(refer to the NVMe over Fabrics specification) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_DISCOVERY : spdk_nvme_log_page = 112 ; 
 /// Reservation notification (optional) 
 pub const spdk_nvme_log_page_SPDK_NVME_LOG_RESERVATION_NOTIFICATION : spdk_nvme_log_page = 128 ; 
 /// Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE 
 pub type spdk_nvme_log_page = u32 ; 
 /// Error information log page (\ref SPDK_NVME_LOG_ERROR) 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_error_information_entry { pub error_count : u64 , pub sqid : u16 , pub cid : u16 , pub status : spdk_nvme_status , pub error_location : u16 , pub lba : u64 , pub nsid : u32 , pub vendor_specific : u8 , pub reserved : [ u8 ; 35usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_error_information_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_error_information_entry > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_error_information_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_error_information_entry > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_error_information_entry ) ) ) ; } impl Default for spdk_nvme_error_information_entry { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_critical_warning_state { pub raw : u8 , pub bits : spdk_nvme_critical_warning_state__bindgen_ty_1 , _bindgen_union_align : u8 , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_critical_warning_state__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_critical_warning_state__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_critical_warning_state__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_critical_warning_state__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_critical_warning_state__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_critical_warning_state__bindgen_ty_1 { # [ inline ] pub fn available_spare ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_available_spare ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn temperature ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_temperature ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn device_reliability ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_device_reliability ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn read_only ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_read_only ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn volatile_memory_backup ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_volatile_memory_backup ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( available_spare : u8 , temperature : u8 , device_reliability : u8 , read_only : u8 , volatile_memory_backup : u8 , reserved : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let available_spare : u8 = unsafe { :: std :: mem :: transmute ( available_spare ) } ; available_spare as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let temperature : u8 = unsafe { :: std :: mem :: transmute ( temperature ) } ; temperature as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let device_reliability : u8 = unsafe { :: std :: mem :: transmute ( device_reliability ) } ; device_reliability as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let read_only : u8 = unsafe { :: std :: mem :: transmute ( read_only ) } ; read_only as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let volatile_memory_backup : u8 = unsafe { :: std :: mem :: transmute ( volatile_memory_backup ) } ; volatile_memory_backup as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let reserved : u8 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_critical_warning_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_critical_warning_state > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_critical_warning_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_critical_warning_state > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_critical_warning_state ) ) ) ; } impl Default for spdk_nvme_critical_warning_state { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// SMART / health information page (\ref SPDK_NVME_LOG_HEALTH_INFORMATION) 
 # [ repr ( C , packed ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_health_information_page { pub critical_warning : spdk_nvme_critical_warning_state , pub temperature : u16 , pub available_spare : u8 , pub available_spare_threshold : u8 , pub percentage_used : u8 , pub reserved : [ u8 ; 26usize ] , pub data_units_read : [ u64 ; 2usize ] , pub data_units_written : [ u64 ; 2usize ] , pub host_read_commands : [ u64 ; 2usize ] , pub host_write_commands : [ u64 ; 2usize ] , pub controller_busy_time : [ u64 ; 2usize ] , pub power_cycles : [ u64 ; 2usize ] , pub power_on_hours : [ u64 ; 2usize ] , pub unsafe_shutdowns : [ u64 ; 2usize ] , pub media_errors : [ u64 ; 2usize ] , pub num_error_info_log_entries : [ u64 ; 2usize ] , pub warning_temp_time : u32 , pub critical_temp_time : u32 , pub temp_sensor : [ u16 ; 8usize ] , pub reserved2 : [ u8 ; 296usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_health_information_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_health_information_page > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_health_information_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_health_information_page > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_health_information_page ) ) ) ; } impl Default for spdk_nvme_health_information_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_entry { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmds_and_effect_entry ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmds_and_effect_entry > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmds_and_effect_entry ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmds_and_effect_entry > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmds_and_effect_entry ) ) ) ; } impl spdk_nvme_cmds_and_effect_entry { # [ inline ] pub fn csupp ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_csupp ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn lbcc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_lbcc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ncc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ncc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn nic ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_nic ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ccc ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u16 ) } } # [ inline ] pub fn set_ccc ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 11u8 ) as u16 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 11u8 , val as u64 ) } } # [ inline ] pub fn cse ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 3u8 ) as u16 ) } } # [ inline ] pub fn set_cse ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u16 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 19usize , 13u8 ) as u16 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u16 ) { unsafe { let val : u16 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 19usize , 13u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( csupp : u16 , lbcc : u16 , ncc : u16 , nic : u16 , ccc : u16 , reserved1 : u16 , cse : u16 , reserved2 : u16 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let csupp : u16 = unsafe { :: std :: mem :: transmute ( csupp ) } ; csupp as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let lbcc : u16 = unsafe { :: std :: mem :: transmute ( lbcc ) } ; lbcc as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let ncc : u16 = unsafe { :: std :: mem :: transmute ( ncc ) } ; ncc as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let nic : u16 = unsafe { :: std :: mem :: transmute ( nic ) } ; nic as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ccc : u16 = unsafe { :: std :: mem :: transmute ( ccc ) } ; ccc as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 11u8 , { let reserved1 : u16 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 3u8 , { let cse : u16 = unsafe { :: std :: mem :: transmute ( cse ) } ; cse as u64 } ) ; __bindgen_bitfield_unit . set ( 19usize , 13u8 , { let reserved2 : u16 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_cmds_and_effect_log_page { 
 /// Commands Supported and Effects Data Structure for the Admin Commands 
 pub admin_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , 
 /// Commands Supported and Effects Data Structure for the IO Commands 
 pub io_cmds_supported : [ spdk_nvme_cmds_and_effect_entry ; 256usize ] , pub reserved0 : [ u8 ; 2048usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_cmds_and_effect_log_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_cmds_and_effect_log_page > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_cmds_and_effect_log_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_cmds_and_effect_log_page > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_cmds_and_effect_log_page ) ) ) ; } impl Default for spdk_nvme_cmds_and_effect_log_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_ERROR : spdk_nvme_async_event_type = 0 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_SMART : spdk_nvme_async_event_type = 1 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE : spdk_nvme_async_event_type = 2 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_IO : spdk_nvme_async_event_type = 6 ; pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_VENDOR : spdk_nvme_async_event_type = 7 ; 
 /// Asynchronous Event Type 
 pub type spdk_nvme_async_event_type = u32 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_WRITE_INVALID_DB : spdk_nvme_async_event_info_error = 0 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_INVALID_DB_WRITE : spdk_nvme_async_event_info_error = 1 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_DIAGNOSTIC_FAILURE : spdk_nvme_async_event_info_error = 2 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_PERSISTENT_INTERNAL : spdk_nvme_async_event_info_error = 3 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_TRANSIENT_INTERNAL : spdk_nvme_async_event_info_error = 4 ; pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_FW_IMAGE_LOAD : spdk_nvme_async_event_info_error = 5 ; 
 /// Asynchronous Event Information for Error Status 
 pub type spdk_nvme_async_event_info_error = u32 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SUBSYSTEM_RELIABILITY : spdk_nvme_async_event_info_smart = 0 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_TEMPERATURE_THRESHOLD : spdk_nvme_async_event_info_smart = 1 ; pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SPARE_BELOW_THRESHOLD : spdk_nvme_async_event_info_smart = 2 ; 
 /// Asynchronous Event Information for SMART/Health Status 
 pub type spdk_nvme_async_event_info_smart = u32 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED : spdk_nvme_async_event_info_notice = 0 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_FW_ACTIVATION_START : spdk_nvme_async_event_info_notice = 1 ; pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_TELEMETRY_LOG_CHANGED : spdk_nvme_async_event_info_notice = 2 ; 
 /// Asynchronous Event Information for Notice 
 pub type spdk_nvme_async_event_info_notice = u32 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_RESERVATION_LOG_AVAIL : spdk_nvme_async_event_info_nvm_command_set = 0 ; pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_SANITIZE_COMPLETED : spdk_nvme_async_event_info_nvm_command_set = 1 ; 
 /// Asynchronous Event Information for NVM Command Set Specific Status 
 pub type spdk_nvme_async_event_info_nvm_command_set = u32 ; 
 /// Asynchronous Event Request Completion 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_async_event_completion { pub raw : u32 , pub bits : spdk_nvme_async_event_completion__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_async_event_completion__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_async_event_completion__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_async_event_completion__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_async_event_completion__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_async_event_completion__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_async_event_completion__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_async_event_completion__bindgen_ty_1 { # [ inline ] pub fn async_event_type ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_type ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn async_event_info ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_async_event_info ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn log_page_identifier ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_log_page_identifier ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_reserved2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( async_event_type : u32 , reserved1 : u32 , async_event_info : u32 , log_page_identifier : u32 , reserved2 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let async_event_type : u32 = unsafe { :: std :: mem :: transmute ( async_event_type ) } ; async_event_type as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved1 : u32 = unsafe { :: std :: mem :: transmute ( reserved1 ) } ; reserved1 as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let async_event_info : u32 = unsafe { :: std :: mem :: transmute ( async_event_info ) } ; async_event_info as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let log_page_identifier : u32 = unsafe { :: std :: mem :: transmute ( log_page_identifier ) } ; log_page_identifier as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let reserved2 : u32 = unsafe { :: std :: mem :: transmute ( reserved2 ) } ; reserved2 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_async_event_completion ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_async_event_completion > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_async_event_completion ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_async_event_completion > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_async_event_completion ) ) ) ; } impl Default for spdk_nvme_async_event_completion { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_ARBITRATION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_arbitration { pub raw : u32 , pub bits : spdk_nvme_feat_arbitration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_arbitration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_arbitration__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_arbitration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_arbitration__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_arbitration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_arbitration__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_arbitration__bindgen_ty_1 { # [ inline ] pub fn ab ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ab ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 5u8 , val as u64 ) } } # [ inline ] pub fn lpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_lpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 8u8 , val as u64 ) } } # [ inline ] pub fn mpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_mpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 8u8 , val as u64 ) } } # [ inline ] pub fn hpw ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 24usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_hpw ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 24usize , 8u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ab : u32 , reserved : u32 , lpw : u32 , mpw : u32 , hpw : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let ab : u32 = unsafe { :: std :: mem :: transmute ( ab ) } ; ab as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 5u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 8u8 , { let lpw : u32 = unsafe { :: std :: mem :: transmute ( lpw ) } ; lpw as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 8u8 , { let mpw : u32 = unsafe { :: std :: mem :: transmute ( mpw ) } ; mpw as u64 } ) ; __bindgen_bitfield_unit . set ( 24usize , 8u8 , { let hpw : u32 = unsafe { :: std :: mem :: transmute ( hpw ) } ; hpw as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_arbitration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_arbitration > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_arbitration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_arbitration > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_arbitration ) ) ) ; } impl Default for spdk_nvme_feat_arbitration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_POWER_MANAGEMENT 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_power_management { pub raw : u32 , pub bits : spdk_nvme_feat_power_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_power_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_power_management__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_power_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_power_management__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_power_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_power_management__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_power_management__bindgen_ty_1 { # [ inline ] pub fn ps ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 5u8 ) as u32 ) } } # [ inline ] pub fn set_ps ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 5u8 , val as u64 ) } } # [ inline ] pub fn wh ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_wh ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ps : u32 , wh : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 5u8 , { let ps : u32 = unsafe { :: std :: mem :: transmute ( ps ) } ; ps as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let wh : u32 = unsafe { :: std :: mem :: transmute ( wh ) } ; wh as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_power_management ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_power_management > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_power_management ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_power_management > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_power_management ) ) ) ; } impl Default for spdk_nvme_feat_power_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_LBA_RANGE_TYPE 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_lba_range_type { pub raw : u32 , pub bits : spdk_nvme_feat_lba_range_type__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_lba_range_type__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_lba_range_type__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_lba_range_type__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_lba_range_type__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_lba_range_type__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_lba_range_type__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_lba_range_type__bindgen_ty_1 { # [ inline ] pub fn num ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 6u8 ) as u32 ) } } # [ inline ] pub fn set_num ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 6u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( num : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 6u8 , { let num : u32 = unsafe { :: std :: mem :: transmute ( num ) } ; num as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_lba_range_type ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_lba_range_type > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_lba_range_type ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_lba_range_type > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_lba_range_type ) ) ) ; } impl Default for spdk_nvme_feat_lba_range_type { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_temperature_threshold { pub raw : u32 , pub bits : spdk_nvme_feat_temperature_threshold__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_temperature_threshold__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_temperature_threshold__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_temperature_threshold__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_temperature_threshold__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_temperature_threshold__bindgen_ty_1 { # [ inline ] pub fn tmpth ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmpth ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmpsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_tmpsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 4u8 , val as u64 ) } } # [ inline ] pub fn thsel ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 20usize , 2u8 ) as u32 ) } } # [ inline ] pub fn set_thsel ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 20usize , 2u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 22usize , 10u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 22usize , 10u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmpth : u32 , tmpsel : u32 , thsel : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmpth : u32 = unsafe { :: std :: mem :: transmute ( tmpth ) } ; tmpth as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 4u8 , { let tmpsel : u32 = unsafe { :: std :: mem :: transmute ( tmpsel ) } ; tmpsel as u64 } ) ; __bindgen_bitfield_unit . set ( 20usize , 2u8 , { let thsel : u32 = unsafe { :: std :: mem :: transmute ( thsel ) } ; thsel as u64 } ) ; __bindgen_bitfield_unit . set ( 22usize , 10u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_temperature_threshold > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_temperature_threshold ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_temperature_threshold > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_temperature_threshold ) ) ) ; } impl Default for spdk_nvme_feat_temperature_threshold { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_ERROR_RECOVERY 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_error_recovery { pub raw : u32 , pub bits : spdk_nvme_feat_error_recovery__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_error_recovery__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_error_recovery__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_error_recovery__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_error_recovery__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_error_recovery__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_error_recovery__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_error_recovery__bindgen_ty_1 { # [ inline ] pub fn tler ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tler ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn dulbe ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dulbe ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tler : u32 , dulbe : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tler : u32 = unsafe { :: std :: mem :: transmute ( tler ) } ; tler as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let dulbe : u32 = unsafe { :: std :: mem :: transmute ( dulbe ) } ; dulbe as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_error_recovery ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_error_recovery > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_error_recovery ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_error_recovery > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_error_recovery ) ) ) ; } impl Default for spdk_nvme_feat_error_recovery { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_volatile_write_cache { pub raw : u32 , pub bits : spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 { # [ inline ] pub fn wce ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_wce ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( wce : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let wce : u32 = unsafe { :: std :: mem :: transmute ( wce ) } ; wce as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_volatile_write_cache > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_volatile_write_cache ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_volatile_write_cache > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_volatile_write_cache ) ) ) ; } impl Default for spdk_nvme_feat_volatile_write_cache { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_NUMBER_OF_QUEUES 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_number_of_queues { pub raw : u32 , pub bits : spdk_nvme_feat_number_of_queues__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_number_of_queues__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_number_of_queues__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_number_of_queues__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_number_of_queues__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_number_of_queues__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_number_of_queues__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_number_of_queues__bindgen_ty_1 { # [ inline ] pub fn nsqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_nsqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn ncqr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_ncqr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( nsqr : u32 , ncqr : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let nsqr : u32 = unsafe { :: std :: mem :: transmute ( nsqr ) } ; nsqr as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let ncqr : u32 = unsafe { :: std :: mem :: transmute ( ncqr ) } ; ncqr as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_number_of_queues ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_number_of_queues > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_number_of_queues ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_number_of_queues > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_number_of_queues ) ) ) ; } impl Default for spdk_nvme_feat_number_of_queues { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_interrupt_vector_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 { # [ inline ] pub fn iv ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_iv ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn cd ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_cd ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 17usize , 15u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 17usize , 15u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( iv : u32 , cd : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let iv : u32 = unsafe { :: std :: mem :: transmute ( iv ) } ; iv as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 1u8 , { let cd : u32 = unsafe { :: std :: mem :: transmute ( cd ) } ; cd as u64 } ) ; __bindgen_bitfield_unit . set ( 17usize , 15u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_interrupt_vector_configuration > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_interrupt_vector_configuration > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_interrupt_vector_configuration ) ) ) ; } impl Default for spdk_nvme_feat_interrupt_vector_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_WRITE_ATOMICITY 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_write_atomicity { pub raw : u32 , pub bits : spdk_nvme_feat_write_atomicity__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_write_atomicity__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_write_atomicity__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_write_atomicity__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_write_atomicity__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_write_atomicity__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_write_atomicity__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_write_atomicity__bindgen_ty_1 { # [ inline ] pub fn dn ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_dn ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( dn : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let dn : u32 = unsafe { :: std :: mem :: transmute ( dn ) } ; dn as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_write_atomicity ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_write_atomicity > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_write_atomicity ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_write_atomicity > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_write_atomicity ) ) ) ; } impl Default for spdk_nvme_feat_write_atomicity { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features / Get Features \ref SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_async_event_configuration { pub raw : u32 , pub bits : spdk_nvme_feat_async_event_configuration__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { pub crit_warn : spdk_nvme_critical_warning_state , pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_async_event_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_async_event_configuration__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_async_event_configuration__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_async_event_configuration__bindgen_ty_1 ) ) ) ; } impl Default for spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } impl spdk_nvme_feat_async_event_configuration__bindgen_ty_1 { # [ inline ] pub fn ns_attr_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ns_attr_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn fw_activation_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_fw_activation_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn telemetry_log_notice ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_telemetry_log_notice ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 21u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 21u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ns_attr_notice : u32 , fw_activation_notice : u32 , telemetry_log_notice : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ns_attr_notice : u32 = unsafe { :: std :: mem :: transmute ( ns_attr_notice ) } ; ns_attr_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let fw_activation_notice : u32 = unsafe { :: std :: mem :: transmute ( fw_activation_notice ) } ; fw_activation_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 1u8 , { let telemetry_log_notice : u32 = unsafe { :: std :: mem :: transmute ( telemetry_log_notice ) } ; telemetry_log_notice as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 21u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_async_event_configuration > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_async_event_configuration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_async_event_configuration > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_async_event_configuration ) ) ) ; } impl Default for spdk_nvme_feat_async_event_configuration { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_autonomous_power_state_transition { pub raw : u32 , pub bits : spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 { # [ inline ] pub fn apste ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_apste ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( apste : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let apste : u32 = unsafe { :: std :: mem :: transmute ( apste ) } ; apste as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_autonomous_power_state_transition > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_autonomous_power_state_transition > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_autonomous_power_state_transition ) ) ) ; } impl Default for spdk_nvme_feat_autonomous_power_state_transition { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_HOST_MEM_BUFFER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_mem_buffer { pub raw : u32 , pub bits : spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 { # [ inline ] pub fn ehm ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ehm ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn mr ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_mr ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 2usize , 30u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 2usize , 30u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( ehm : u32 , mr : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let ehm : u32 = unsafe { :: std :: mem :: transmute ( ehm ) } ; ehm as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 1u8 , { let mr : u32 = unsafe { :: std :: mem :: transmute ( mr ) } ; mr as u64 } ) ; __bindgen_bitfield_unit . set ( 2usize , 30u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_mem_buffer > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_mem_buffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_mem_buffer > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_mem_buffer ) ) ) ; } impl Default for spdk_nvme_feat_host_mem_buffer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_KEEP_ALIVE_TIMER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_keep_alive_timer { pub raw : u32 , pub bits : spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 { # [ inline ] pub fn kato ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 32u8 ) as u32 ) } } # [ inline ] pub fn set_kato ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 32u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( kato : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 32u8 , { let kato : u32 = unsafe { :: std :: mem :: transmute ( kato ) } ; kato as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_keep_alive_timer > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_keep_alive_timer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_keep_alive_timer > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_keep_alive_timer ) ) ) ; } impl Default for spdk_nvme_feat_keep_alive_timer { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_controlled_thermal_management { pub raw : u32 , pub bits : spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 { # [ inline ] pub fn tmt2 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt2 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 16u8 , val as u64 ) } } # [ inline ] pub fn tmt1 ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 16usize , 16u8 ) as u32 ) } } # [ inline ] pub fn set_tmt1 ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 16usize , 16u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( tmt2 : u32 , tmt1 : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u16 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 16u8 , { let tmt2 : u32 = unsafe { :: std :: mem :: transmute ( tmt2 ) } ; tmt2 as u64 } ) ; __bindgen_bitfield_unit . set ( 16usize , 16u8 , { let tmt1 : u32 = unsafe { :: std :: mem :: transmute ( tmt1 ) } ; tmt1 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_controlled_thermal_management > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_controlled_thermal_management > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_controlled_thermal_management ) ) ) ; } impl Default for spdk_nvme_feat_host_controlled_thermal_management { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_non_operational_power_state_config { pub raw : u32 , pub bits : spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 { # [ inline ] pub fn noppme ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_noppme ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( noppme : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let noppme : u32 = unsafe { :: std :: mem :: transmute ( noppme ) } ; noppme as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_non_operational_power_state_config > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_non_operational_power_state_config > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_non_operational_power_state_config ) ) ) ; } impl Default for spdk_nvme_feat_non_operational_power_state_config { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_software_progress_marker { pub raw : u32 , pub bits : spdk_nvme_feat_software_progress_marker__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_software_progress_marker__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_software_progress_marker__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_software_progress_marker__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_software_progress_marker__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_software_progress_marker__bindgen_ty_1 { # [ inline ] pub fn pbslc ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 8u8 ) as u32 ) } } # [ inline ] pub fn set_pbslc ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 8u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 24u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 24u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( pbslc : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 8u8 , { let pbslc : u32 = unsafe { :: std :: mem :: transmute ( pbslc ) } ; pbslc as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 24u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_software_progress_marker > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_software_progress_marker ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_software_progress_marker > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_software_progress_marker ) ) ) ; } impl Default for spdk_nvme_feat_software_progress_marker { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Data used by Set Features/Get Features \ref SPDK_NVME_FEAT_HOST_IDENTIFIER 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union spdk_nvme_feat_host_identifier { pub raw : u32 , pub bits : spdk_nvme_feat_host_identifier__bindgen_ty_1 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_feat_host_identifier__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_identifier__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_identifier__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_identifier__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_identifier__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_identifier__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_feat_host_identifier__bindgen_ty_1 { # [ inline ] pub fn exhid ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_exhid ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 1u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 1usize , 31u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 1usize , 31u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( exhid : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 1u8 , { let exhid : u32 = unsafe { :: std :: mem :: transmute ( exhid ) } ; exhid as u64 } ) ; __bindgen_bitfield_unit . set ( 1usize , 31u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_feat_host_identifier ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_feat_host_identifier > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_feat_host_identifier ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_feat_host_identifier > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_feat_host_identifier ) ) ) ; } impl Default for spdk_nvme_feat_host_identifier { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// Firmware slot information page (\ref SPDK_NVME_LOG_FIRMWARE_SLOT) 
 # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_firmware_page { pub afi : spdk_nvme_firmware_page__bindgen_ty_1 , pub reserved : [ u8 ; 7usize ] , pub revision : [ [ u8 ; 8usize ] ; 7usize ] , 
 /// Revisions for 7 slots (ASCII strings) 
 pub reserved2 : [ u8 ; 448usize ] , } # [ repr ( C , packed ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_firmware_page__bindgen_ty_1 { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_firmware_page__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_firmware_page__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_firmware_page__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_firmware_page__bindgen_ty_1 > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_firmware_page__bindgen_ty_1 ) ) ) ; } impl spdk_nvme_firmware_page__bindgen_ty_1 { # [ inline ] pub fn active_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_active_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved3 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved3 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 1u8 , val as u64 ) } } # [ inline ] pub fn next_reset_slot ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 3u8 ) as u8 ) } } # [ inline ] pub fn set_next_reset_slot ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved7 ( & self ) -> u8 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 7usize , 1u8 ) as u8 ) } } # [ inline ] pub fn set_reserved7 ( & mut self , val : u8 ) { unsafe { let val : u8 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 7usize , 1u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( active_slot : u8 , reserved3 : u8 , next_reset_slot : u8 , reserved7 : u8 ) -> __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 1usize ] , u8 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let active_slot : u8 = unsafe { :: std :: mem :: transmute ( active_slot ) } ; active_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 1u8 , { let reserved3 : u8 = unsafe { :: std :: mem :: transmute ( reserved3 ) } ; reserved3 as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 3u8 , { let next_reset_slot : u8 = unsafe { :: std :: mem :: transmute ( next_reset_slot ) } ; next_reset_slot as u64 } ) ; __bindgen_bitfield_unit . set ( 7usize , 1u8 , { let reserved7 : u8 = unsafe { :: std :: mem :: transmute ( reserved7 ) } ; reserved7 as u64 } ) ; __bindgen_bitfield_unit } } # [ test ] fn bindgen_test_layout_spdk_nvme_firmware_page ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_firmware_page > ( ) , 512usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_firmware_page ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_firmware_page > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_firmware_page ) ) ) ; } impl Default for spdk_nvme_firmware_page { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_ATTACH : spdk_nvme_ns_attach_type = 0 ; pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_DETACH : spdk_nvme_ns_attach_type = 1 ; 
 /// Namespace attachment Type Encoding 
 pub type spdk_nvme_ns_attach_type = u32 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_CREATE : spdk_nvme_ns_management_type = 0 ; pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_DELETE : spdk_nvme_ns_management_type = 1 ; 
 /// Namespace management Type Encoding 
 pub type spdk_nvme_ns_management_type = u32 ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ns_list { pub ns_list : [ u32 ; 1024usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_list > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_list > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_list ) ) ) ; } impl Default for spdk_nvme_ns_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } 
 /// IEEE Extended Unique Identifier 
 pub const spdk_nvme_nidt_SPDK_NVME_NIDT_EUI64 : spdk_nvme_nidt = 1 ; 
 /// Namespace GUID 
 pub const spdk_nvme_nidt_SPDK_NVME_NIDT_NGUID : spdk_nvme_nidt = 2 ; 
 /// Namespace UUID 
 pub const spdk_nvme_nidt_SPDK_NVME_NIDT_UUID : spdk_nvme_nidt = 3 ; 
 /// Namespace identification descriptor type
///
/// \sa spdk_nvme_ns_id_desc 
 pub type spdk_nvme_nidt = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default ) ] pub struct spdk_nvme_ns_id_desc { 
 /// Namespace identifier type 
 pub nidt : u8 , 
 /// Namespace identifier length (length of nid field) 
 pub nidl : u8 , pub reserved2 : u8 , pub reserved3 : u8 , 
 /// Namespace identifier 
 pub nid : __IncompleteArrayField < u8 > , } # [ test ] fn bindgen_test_layout_spdk_nvme_ns_id_desc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ns_id_desc > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ns_id_desc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ns_id_desc > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ns_id_desc ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct spdk_nvme_ctrlr_list { pub ctrlr_count : u16 , pub ctrlr_list : [ u16 ; 2047usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_ctrlr_list ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_ctrlr_list > ( ) , 4096usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_ctrlr_list ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_ctrlr_list > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_ctrlr_list ) ) ) ; } impl Default for spdk_nvme_ctrlr_list { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE : spdk_nvme_secure_erase_setting = 0 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE : spdk_nvme_secure_erase_setting = 1 ; pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE : spdk_nvme_secure_erase_setting = 2 ; pub type spdk_nvme_secure_erase_setting = u32 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL : spdk_nvme_pi_location = 0 ; pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD : spdk_nvme_pi_location = 1 ; pub type spdk_nvme_pi_location = u32 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_DISABLE : spdk_nvme_pi_type = 0 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE1 : spdk_nvme_pi_type = 1 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE2 : spdk_nvme_pi_type = 2 ; pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE3 : spdk_nvme_pi_type = 3 ; pub type spdk_nvme_pi_type = u32 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER : spdk_nvme_metadata_setting = 0 ; pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA : spdk_nvme_metadata_setting = 1 ; pub type spdk_nvme_metadata_setting = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_format { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_format ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_format > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_format ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_format > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_format ) ) ) ; } impl spdk_nvme_format { # [ inline ] pub fn lbaf ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 4u8 ) as u32 ) } } # [ inline ] pub fn set_lbaf ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 4u8 , val as u64 ) } } # [ inline ] pub fn ms ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 4usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_ms ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 4usize , 1u8 , val as u64 ) } } # [ inline ] pub fn pi ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 5usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_pi ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 5usize , 3u8 , val as u64 ) } } # [ inline ] pub fn pil ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 8usize , 1u8 ) as u32 ) } } # [ inline ] pub fn set_pil ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 8usize , 1u8 , val as u64 ) } } # [ inline ] pub fn ses ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 9usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ses ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 9usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 12usize , 20u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 12usize , 20u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( lbaf : u32 , ms : u32 , pi : u32 , pil : u32 , ses : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 4u8 , { let lbaf : u32 = unsafe { :: std :: mem :: transmute ( lbaf ) } ; lbaf as u64 } ) ; __bindgen_bitfield_unit . set ( 4usize , 1u8 , { let ms : u32 = unsafe { :: std :: mem :: transmute ( ms ) } ; ms as u64 } ) ; __bindgen_bitfield_unit . set ( 5usize , 3u8 , { let pi : u32 = unsafe { :: std :: mem :: transmute ( pi ) } ; pi as u64 } ) ; __bindgen_bitfield_unit . set ( 8usize , 1u8 , { let pil : u32 = unsafe { :: std :: mem :: transmute ( pil ) } ; pil as u64 } ) ; __bindgen_bitfield_unit . set ( 9usize , 3u8 , { let ses : u32 = unsafe { :: std :: mem :: transmute ( ses ) } ; ses as u64 } ) ; __bindgen_bitfield_unit . set ( 12usize , 20u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_protection_info { pub guard : u16 , pub app_tag : u16 , pub ref_tag : u32 , } # [ test ] fn bindgen_test_layout_spdk_nvme_protection_info ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_protection_info > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_protection_info ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_protection_info > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_protection_info ) ) ) ; } 
 /// Downloaded image replaces the image specified by
/// the Firmware Slot field. This image is not activated. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_IMG : spdk_nvme_fw_commit_action = 0 ; 
 /// Downloaded image replaces the image specified by
/// the Firmware Slot field. This image is activated at the next reset. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG : spdk_nvme_fw_commit_action = 1 ; 
 /// The image specified by the Firmware Slot field is
/// activated at the next reset. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_ENABLE_IMG : spdk_nvme_fw_commit_action = 2 ; 
 /// The image specified by the Firmware Slot field is
/// requested to be activated immediately without reset. 
 pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_RUN_IMG : spdk_nvme_fw_commit_action = 3 ; 
 /// Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action 
 pub type spdk_nvme_fw_commit_action = u32 ; 
 /// Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10 
 # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_nvme_fw_commit { pub _bitfield_1 : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_spdk_nvme_fw_commit ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_nvme_fw_commit > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( spdk_nvme_fw_commit ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_nvme_fw_commit > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( spdk_nvme_fw_commit ) ) ) ; } impl spdk_nvme_fw_commit { # [ inline ] pub fn fs ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 0usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_fs ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 0usize , 3u8 , val as u64 ) } } # [ inline ] pub fn ca ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 3usize , 3u8 ) as u32 ) } } # [ inline ] pub fn set_ca ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 3usize , 3u8 , val as u64 ) } } # [ inline ] pub fn reserved ( & self ) -> u32 { unsafe { :: std :: mem :: transmute ( self . _bitfield_1 . get ( 6usize , 26u8 ) as u32 ) } } # [ inline ] pub fn set_reserved ( & mut self , val : u32 ) { unsafe { let val : u32 = :: std :: mem :: transmute ( val ) ; self . _bitfield_1 . set ( 6usize , 26u8 , val as u64 ) } } # [ inline ] pub fn new_bitfield_1 ( fs : u32 , ca : u32 , reserved : u32 ) -> __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [ u8 ; 4usize ] , u32 > = Default :: default ( ) ; __bindgen_bitfield_unit . set ( 0usize , 3u8 , { let fs : u32 = unsafe { :: std :: mem :: transmute ( fs ) } ; fs as u64 } ) ; __bindgen_bitfield_unit . set ( 3usize , 3u8 , { let ca : u32 = unsafe { :: std :: mem :: transmute ( ca ) } ; ca as u64 } ) ; __bindgen_bitfield_unit . set ( 6usize , 26u8 , { let reserved : u32 = unsafe { :: std :: mem :: transmute ( reserved ) } ; reserved as u64 } ) ; __bindgen_bitfield_unit } } pub const spdk_json_val_type_SPDK_JSON_VAL_INVALID : spdk_json_val_type = 0 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NULL : spdk_json_val_type = 1 ; pub const spdk_json_val_type_SPDK_JSON_VAL_TRUE : spdk_json_val_type = 2 ; pub const spdk_json_val_type_SPDK_JSON_VAL_FALSE : spdk_json_val_type = 3 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NUMBER : spdk_json_val_type = 4 ; pub const spdk_json_val_type_SPDK_JSON_VAL_STRING : spdk_json_val_type = 5 ; pub const spdk_json_val_type_SPDK_JSON_VAL_ARRAY_BEGIN : spdk_json_val_type = 6 ; pub const spdk_json_val_type_SPDK_JSON_VAL_ARRAY_END : spdk_json_val_type = 7 ; pub const spdk_json_val_type_SPDK_JSON_VAL_OBJECT_BEGIN : spdk_json_val_type = 8 ; pub const spdk_json_val_type_SPDK_JSON_VAL_OBJECT_END : spdk_json_val_type = 9 ; pub const spdk_json_val_type_SPDK_JSON_VAL_NAME : spdk_json_val_type = 10 ; pub type spdk_json_val_type = u32 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_val { 
 /// Pointer to the location of the value within the parsed JSON input.
    ///
    /// For SPDK_JSON_VAL_STRING and SPDK_JSON_VAL_NAME,
    /// this points to the beginning of the decoded UTF-8 string without quotes.
    ///
    /// For SPDK_JSON_VAL_NUMBER, this points to the beginning of the number as represented in
    /// the original JSON (text representation, not converted to a numeric value). 
 pub start : * mut :: std :: os :: raw :: c_void , 
 /// Length of value.
    ///
    /// For SPDK_JSON_VAL_STRING, SPDK_JSON_VAL_NUMBER, and SPDK_JSON_VAL_NAME,
    /// this is the length in bytes of the value starting at \ref start.
    ///
    /// For SPDK_JSON_VAL_ARRAY_BEGIN and SPDK_JSON_VAL_OBJECT_BEGIN,
    /// this is the number of values contained within the array or object (including
    /// nested objects and arrays, but not including the _END value).  The array or object _END
    /// value can be found by advancing len values from the _BEGIN value. 
 pub len : u32 , 
 /// Type of value. 
 pub type_ : spdk_json_val_type , } # [ test ] fn bindgen_test_layout_spdk_json_val ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_json_val > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( spdk_json_val ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_json_val > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_json_val ) ) ) ; } impl Default for spdk_json_val { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z15spdk_json_parse" ] pub fn spdk_json_parse ( json : * mut :: std :: os :: raw :: c_void , size : usize , values : * mut spdk_json_val , num_values : usize , end : * mut * mut :: std :: os :: raw :: c_void , flags : u32 ) -> isize ; } pub type spdk_json_decode_fn = :: std :: option :: Option < unsafe extern "C" fn ( val : * const spdk_json_val , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_object_decoder { pub name : * const :: std :: os :: raw :: c_char , pub offset : usize , pub decode_func : spdk_json_decode_fn , pub optional : bool , } # [ test ] fn bindgen_test_layout_spdk_json_object_decoder ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_json_object_decoder > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( spdk_json_object_decoder ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_json_object_decoder > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_json_object_decoder ) ) ) ; } impl Default for spdk_json_object_decoder { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } extern "C" { # [ link_name = "\u{1}_Z23spdk_json_decode_object" ] pub fn spdk_json_decode_object ( values : * const spdk_json_val , decoders : * const spdk_json_object_decoder , num_decoders : usize , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22spdk_json_decode_array" ] pub fn spdk_json_decode_array ( values : * const spdk_json_val , decode_func : spdk_json_decode_fn , out : * mut :: std :: os :: raw :: c_void , max_size : usize , out_size : * mut usize , stride : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21spdk_json_decode_bool" ] pub fn spdk_json_decode_bool ( val : * const spdk_json_val , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22spdk_json_decode_int32" ] pub fn spdk_json_decode_int32 ( val : * const spdk_json_val , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23spdk_json_decode_uint32" ] pub fn spdk_json_decode_uint32 ( val : * const spdk_json_val , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23spdk_json_decode_uint64" ] pub fn spdk_json_decode_uint64 ( val : * const spdk_json_val , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23spdk_json_decode_string" ] pub fn spdk_json_decode_string ( val : * const spdk_json_val , out : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Get length of a value in number of values.
///
/// This can be used to skip over a value while interpreting parse results.
///
/// For SPDK_JSON_VAL_ARRAY_BEGIN and SPDK_JSON_VAL_OBJECT_BEGIN,
/// this returns the number of values contained within this value, plus the _BEGIN and _END values.
///
/// For all other values, this returns 1. 
 # [ link_name = "\u{1}_Z17spdk_json_val_len" ] pub fn spdk_json_val_len ( val : * const spdk_json_val ) -> usize ; } extern "C" { 
 /// Compare JSON string with null terminated C string.
///
/// \return true if strings are equal or false if not 
 # [ link_name = "\u{1}_Z18spdk_json_strequal" ] pub fn spdk_json_strequal ( val : * const spdk_json_val , str : * const :: std :: os :: raw :: c_char ) -> bool ; } extern "C" { 
 /// Equivalent of strdup() for JSON string values.
///
/// If val is not representable as a C string (contains embedded '\0' characters),
/// returns NULL.
///
/// Caller is responsible for passing the result to free() when it is no longer needed. 
 # [ link_name = "\u{1}_Z16spdk_json_strdup" ] pub fn spdk_json_strdup ( val : * const spdk_json_val ) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { # [ link_name = "\u{1}_Z25spdk_json_number_to_int32" ] pub fn spdk_json_number_to_int32 ( val : * const spdk_json_val , num : * mut i32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_number_to_uint32" ] pub fn spdk_json_number_to_uint32 ( val : * const spdk_json_val , num : * mut u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_number_to_uint64" ] pub fn spdk_json_number_to_uint64 ( val : * const spdk_json_val , num : * mut u64 ) -> :: std :: os :: raw :: c_int ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_json_write_ctx { _unused : [ u8 ; 0 ] , } pub type spdk_json_write_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_ctx : * mut :: std :: os :: raw :: c_void , data : * const :: std :: os :: raw :: c_void , size : usize ) -> :: std :: os :: raw :: c_int > ; extern "C" { # [ link_name = "\u{1}_Z21spdk_json_write_begin" ] pub fn spdk_json_write_begin ( write_cb : spdk_json_write_cb , cb_ctx : * mut :: std :: os :: raw :: c_void , flags : u32 ) -> * mut spdk_json_write_ctx ; } extern "C" { # [ link_name = "\u{1}_Z19spdk_json_write_end" ] pub fn spdk_json_write_end ( w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20spdk_json_write_null" ] pub fn spdk_json_write_null ( w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20spdk_json_write_bool" ] pub fn spdk_json_write_bool ( w : * mut spdk_json_write_ctx , val : bool ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21spdk_json_write_int32" ] pub fn spdk_json_write_int32 ( w : * mut spdk_json_write_ctx , val : i32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22spdk_json_write_uint32" ] pub fn spdk_json_write_uint32 ( w : * mut spdk_json_write_ctx , val : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z21spdk_json_write_int64" ] pub fn spdk_json_write_int64 ( w : * mut spdk_json_write_ctx , val : i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22spdk_json_write_uint64" ] pub fn spdk_json_write_uint64 ( w : * mut spdk_json_write_ctx , val : u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z22spdk_json_write_string" ] pub fn spdk_json_write_string ( w : * mut spdk_json_write_ctx , val : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_write_string_raw" ] pub fn spdk_json_write_string_raw ( w : * mut spdk_json_write_ctx , val : * const :: std :: os :: raw :: c_char , len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Write null-terminated UTF-16LE string.
///
/// \param w JSON write context.
/// \param val UTF-16LE string; must be null terminated.
/// \return 0 on success or negative on failure. 
 # [ link_name = "\u{1}_Z30spdk_json_write_string_utf16le" ] pub fn spdk_json_write_string_utf16le ( w : * mut spdk_json_write_ctx , val : * const u16 ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Write UTF-16LE string.
///
/// \param w JSON write context.
/// \param val UTF-16LE string; may contain embedded null characters.
/// \param len Length of val in 16-bit code units (i.e. size of string in bytes divided by 2).
/// \return 0 on success or negative on failure. 
 # [ link_name = "\u{1}_Z34spdk_json_write_string_utf16le_raw" ] pub fn spdk_json_write_string_utf16le_raw ( w : * mut spdk_json_write_ctx , val : * const u16 , len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_write_string_fmt" ] pub fn spdk_json_write_string_fmt ( w : * mut spdk_json_write_ctx , fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28spdk_json_write_string_fmt_v" ] pub fn spdk_json_write_string_fmt_v ( w : * mut spdk_json_write_ctx , fmt : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27spdk_json_write_array_begin" ] pub fn spdk_json_write_array_begin ( w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z25spdk_json_write_array_end" ] pub fn spdk_json_write_array_end ( w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28spdk_json_write_object_begin" ] pub fn spdk_json_write_object_begin ( w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_write_object_end" ] pub fn spdk_json_write_object_end ( w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z20spdk_json_write_name" ] pub fn spdk_json_write_name ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z24spdk_json_write_name_raw" ] pub fn spdk_json_write_name_raw ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z19spdk_json_write_val" ] pub fn spdk_json_write_val ( w : * mut spdk_json_write_ctx , val : * const spdk_json_val ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z23spdk_json_write_val_raw" ] pub fn spdk_json_write_val_raw ( w : * mut spdk_json_write_ctx , data : * const :: std :: os :: raw :: c_void , len : usize ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_write_named_null" ] pub fn spdk_json_write_named_null ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z26spdk_json_write_named_bool" ] pub fn spdk_json_write_named_bool ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , val : bool ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27spdk_json_write_named_int32" ] pub fn spdk_json_write_named_int32 ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , val : i32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28spdk_json_write_named_uint32" ] pub fn spdk_json_write_named_uint32 ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , val : u32 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28spdk_json_write_named_uint64" ] pub fn spdk_json_write_named_uint64 ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , val : u64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z27spdk_json_write_named_int64" ] pub fn spdk_json_write_named_int64 ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , val : i64 ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z28spdk_json_write_named_string" ] pub fn spdk_json_write_named_string ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , val : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z32spdk_json_write_named_string_fmt" ] pub fn spdk_json_write_named_string_fmt ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , fmt : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z34spdk_json_write_named_string_fmt_v" ] pub fn spdk_json_write_named_string_fmt_v ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char , fmt : * const :: std :: os :: raw :: c_char , args : * mut __va_list_tag ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z33spdk_json_write_named_array_begin" ] pub fn spdk_json_write_named_array_begin ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } extern "C" { # [ link_name = "\u{1}_Z34spdk_json_write_named_object_begin" ] pub fn spdk_json_write_named_object_begin ( w : * mut spdk_json_write_ctx , name : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int ; } pub type spdk_bdev_remove_cb_t = :: std :: option :: Option < unsafe extern "C" fn ( remove_ctx : * mut :: std :: os :: raw :: c_void ) > ; 
 /// Block device I/O
///
/// This is an I/O that is passed to an spdk_bdev. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_io { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_fn_table { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_io_channel { _unused : [ u8 ; 0 ] , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_uuid { _unused : [ u8 ; 0 ] , } pub const spdk_bdev_status_SPDK_BDEV_STATUS_INVALID : spdk_bdev_status = 0 ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_READY : spdk_bdev_status = 1 ; pub const spdk_bdev_status_SPDK_BDEV_STATUS_REMOVING : spdk_bdev_status = 2 ; 
 /// bdev status 
 pub type spdk_bdev_status = u32 ; 
 /// \brief SPDK block device.
///
/// This is a virtual representation of a block device that is exported by the backend. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev { _unused : [ u8 ; 0 ] , } 
 /// \brief Handle to an opened SPDK block device. 
 # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct spdk_bdev_desc { _unused : [ u8 ; 0 ] , } pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_INVALID : spdk_bdev_io_type = 0 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_READ : spdk_bdev_io_type = 1 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_WRITE : spdk_bdev_io_type = 2 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_UNMAP : spdk_bdev_io_type = 3 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_FLUSH : spdk_bdev_io_type = 4 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_RESET : spdk_bdev_io_type = 5 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_ADMIN : spdk_bdev_io_type = 6 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_IO : spdk_bdev_io_type = 7 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_NVME_IO_MD : spdk_bdev_io_type = 8 ; pub const spdk_bdev_io_type_SPDK_BDEV_IO_TYPE_WRITE_ZEROES : spdk_bdev_io_type = 9 ; pub const spdk_bdev_io_type_SPDK_BDEV_NUM_IO_TYPES : spdk_bdev_io_type = 10 ; 
 /// bdev I/O type 
 pub type spdk_bdev_io_type = u32 ; 
 /// Block device completion callback.
///
/// \param bdev_io Block device I/O that has completed.
/// \param success true if I/O completed successfully or false if it failed; additional error
/// information may be retrieved from bdev_io by calling
/// spdk_bdev_io_get_nvme_status() or spdk_bdev_io_get_scsi_status().
/// \param cb_arg Callback argument specified when bdev_io was submitted. 
 pub type spdk_bdev_io_completion_cb = :: std :: option :: Option < unsafe extern "C" fn ( bdev_io : * mut spdk_bdev_io , success : bool , cb_arg : * mut :: std :: os :: raw :: c_void ) > ; # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct spdk_bdev_io_stat { pub bytes_read : u64 , pub num_read_ops : u64 , pub bytes_written : u64 , pub num_write_ops : u64 , pub read_latency_ticks : u64 , pub write_latency_ticks : u64 , pub ticks_rate : u64 , } # [ test ] fn bindgen_test_layout_spdk_bdev_io_stat ( ) { assert_eq ! ( :: std :: mem :: size_of :: < spdk_bdev_io_stat > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( spdk_bdev_io_stat ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < spdk_bdev_io_stat > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( spdk_bdev_io_stat ) ) ) ; } pub type spdk_bdev_init_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut :: std :: os :: raw :: c_void , rc : :: std :: os :: raw :: c_int ) > ; pub type spdk_bdev_fini_cb = :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut :: std :: os :: raw :: c_void ) > ; extern "C" { 
 /// Initialize block device modules.
///
/// \param cb_fn Called when the initialization is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 # [ link_name = "\u{1}_Z20spdk_bdev_initialize" ] pub fn spdk_bdev_initialize ( cb_fn : spdk_bdev_init_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Perform cleanup work to remove the registered block device modules.
///
/// \param cb_fn Called when the removal is complete.
/// \param cb_arg Argument passed to function cb_fn. 
 # [ link_name = "\u{1}_Z16spdk_bdev_finish" ] pub fn spdk_bdev_finish ( cb_fn : spdk_bdev_fini_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Get the configuration options for the registered block device modules.
///
/// \param fp The pointer to a file that will be written to the configuration options. 
 # [ link_name = "\u{1}_Z21spdk_bdev_config_text" ] pub fn spdk_bdev_config_text ( fp : * mut FILE ) ; } extern "C" { 
 /// Get the full configuration options for the registered block device modules and created bdevs.
///
/// \param w pointer to a JSON write context where the configuration will be written. 
 # [ link_name = "\u{1}_Z31spdk_bdev_subsystem_config_json" ] pub fn spdk_bdev_subsystem_config_json ( w : * mut spdk_json_write_ctx ) ; } extern "C" { 
 /// Get block device by the block device name.
///
/// \param bdev_name The name of the block device.
/// \return Block device associated with the name or NULL if no block device with
/// bdev_name is currently registered. 
 # [ link_name = "\u{1}_Z21spdk_bdev_get_by_name" ] pub fn spdk_bdev_get_by_name ( bdev_name : * const :: std :: os :: raw :: c_char ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the first registered block device.
///
/// \return The first registered block device. 
 # [ link_name = "\u{1}_Z15spdk_bdev_first" ] pub fn spdk_bdev_first ( ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the next registered block device.
///
/// \param prev The current block device.
/// \return The next registered block device. 
 # [ link_name = "\u{1}_Z14spdk_bdev_next" ] pub fn spdk_bdev_next ( prev : * mut spdk_bdev ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the first block device without virtual block devices on top.
///
/// This function only traverses over block devices which have no virtual block
/// devices on top of them, then get the first one.
///
/// \return The first block device without virtual block devices on top. 
 # [ link_name = "\u{1}_Z20spdk_bdev_first_leaf" ] pub fn spdk_bdev_first_leaf ( ) -> * mut spdk_bdev ; } extern "C" { 
 /// Get the next block device without virtual block devices on top.
///
/// This function only traverses over block devices which have no virtual block
/// devices on top of them, then get the next one.
///
/// \param prev The current block device.
/// \return The next block device without virtual block devices on top. 
 # [ link_name = "\u{1}_Z19spdk_bdev_next_leaf" ] pub fn spdk_bdev_next_leaf ( prev : * mut spdk_bdev ) -> * mut spdk_bdev ; } extern "C" { 
 /// Open a block device for I/O operations.
///
/// \param bdev Block device to open.
/// \param write true is read/write access requested, false if read-only
/// \param remove_cb callback function for hot remove the device.
/// \param remove_ctx param for hot removal callback function.
/// \param desc output parameter for the descriptor when operation is successful
/// \return 0 if operation is successful, suitable errno value otherwise 
 # [ link_name = "\u{1}_Z14spdk_bdev_open" ] pub fn spdk_bdev_open ( bdev : * mut spdk_bdev , write : bool , remove_cb : spdk_bdev_remove_cb_t , remove_ctx : * mut :: std :: os :: raw :: c_void , desc : * mut * mut spdk_bdev_desc ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Close a previously opened block device.
///
/// \param desc Block device descriptor to close. 
 # [ link_name = "\u{1}_Z15spdk_bdev_close" ] pub fn spdk_bdev_close ( desc : * mut spdk_bdev_desc ) ; } extern "C" { 
 /// Get the bdev associated with a bdev descriptor.
///
/// \param desc Open block device desciptor
/// \return bdev associated with the descriptor 
 # [ link_name = "\u{1}_Z23spdk_bdev_desc_get_bdev" ] pub fn spdk_bdev_desc_get_bdev ( desc : * mut spdk_bdev_desc ) -> * mut spdk_bdev ; } extern "C" { 
 /// Check whether the block device supports the I/O type.
///
/// \param bdev Block device to check.
/// \param io_type The specific I/O type like read, write, flush, unmap.
/// \return true if support, false otherwise. 
 # [ link_name = "\u{1}_Z27spdk_bdev_io_type_supported" ] pub fn spdk_bdev_io_type_supported ( bdev : * mut spdk_bdev , io_type : spdk_bdev_io_type ) -> bool ; } extern "C" { 
 /// Output driver-specific information to a JSON stream.
///
/// The JSON write context will be initialized with an open object, so the bdev
/// driver should write a name(based on the driver name) followed by a JSON value
/// (most likely another nested object).
///
/// \param bdev Block device to query.
/// \param w JSON write context. It will store the driver-specific configuration context.
/// \return 0 on success, negated errno on failure. 
 # [ link_name = "\u{1}_Z24spdk_bdev_dump_info_json" ] pub fn spdk_bdev_dump_info_json ( bdev : * mut spdk_bdev , w : * mut spdk_json_write_ctx ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Output bdev-specific configuration to a JSON stream.
///
/// If supported, the object with following keys will be written:
/// method - name of the constructor method
/// params - parameters necessary to recreate this \c bdev
///
/// If \c bdev does not support writing JSON configuration then object will be written
/// with only one key - the name of this bdev.
///
/// \param bdev block device to query configuration.
/// \param w pointer to a JSON write context where \c bdev the configuration will be written. 
 # [ link_name = "\u{1}_Z21spdk_bdev_config_json" ] pub fn spdk_bdev_config_json ( bdev : * mut spdk_bdev , w : * mut spdk_json_write_ctx ) ; } extern "C" { 
 /// Get block device name.
///
/// \param bdev Block device to query.
/// \return Name of bdev as a null-terminated string. 
 # [ link_name = "\u{1}_Z18spdk_bdev_get_name" ] pub fn spdk_bdev_get_name ( bdev : * const spdk_bdev ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { 
 /// Get block device product name.
///
/// \param bdev Block device to query.
/// \return Product name of bdev as a null-terminated string. 
 # [ link_name = "\u{1}_Z26spdk_bdev_get_product_name" ] pub fn spdk_bdev_get_product_name ( bdev : * const spdk_bdev ) -> * const :: std :: os :: raw :: c_char ; } extern "C" { 
 /// Get block device logical block size.
///
/// \param bdev Block device to query.
/// \return Size of logical block for this bdev in bytes. 
 # [ link_name = "\u{1}_Z24spdk_bdev_get_block_size" ] pub fn spdk_bdev_get_block_size ( bdev : * const spdk_bdev ) -> u32 ; } extern "C" { 
 /// Get size of block device in logical blocks.
///
/// \param bdev Block device to query.
/// \return Size of bdev in logical blocks.
///
/// Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive. 
 # [ link_name = "\u{1}_Z24spdk_bdev_get_num_blocks" ] pub fn spdk_bdev_get_num_blocks ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Get IOs per second of block device for the QoS rate limiting.
///
/// \param bdev Block device to query.
/// \return IOs per second.
///
/// Return 0 for no QoS enforced on the queried block device. 
 # [ link_name = "\u{1}_Z29spdk_bdev_get_qos_ios_per_sec" ] pub fn spdk_bdev_get_qos_ios_per_sec ( bdev : * const spdk_bdev ) -> u64 ; } extern "C" { 
 /// Get minimum I/O buffer address alignment for a bdev.
///
/// \param bdev Block device to query.
/// \return Required alignment of I/O buffers in bytes. 
 # [ link_name = "\u{1}_Z23spdk_bdev_get_buf_align" ] pub fn spdk_bdev_get_buf_align ( bdev : * const spdk_bdev ) -> usize ; } extern "C" { 
 /// Get optimal I/O boundary for a bdev.
///
/// \param bdev Block device to query.
/// \return Optimal I/O boundary in blocks that should not be crossed for best performance, or 0 if
/// no optimal boundary is reported. 
 # [ link_name = "\u{1}_Z33spdk_bdev_get_optimal_io_boundary" ] pub fn spdk_bdev_get_optimal_io_boundary ( bdev : * const spdk_bdev ) -> u32 ; } extern "C" { 
 /// Query whether block device has an enabled write cache.
///
/// \param bdev Block device to query.
/// \return true if block device has a volatile write cache enabled.
///
/// If this function returns true, written data may not be persistent until a flush command
/// is issued. 
 # [ link_name = "\u{1}_Z25spdk_bdev_has_write_cache" ] pub fn spdk_bdev_has_write_cache ( bdev : * const spdk_bdev ) -> bool ; } extern "C" { 
 /// Get a bdev's UUID.
///
/// \param bdev Block device to query.
/// \return Pointer to UUID.
///
/// Not all bdevs will have a UUID; in this case, the returned UUID will be
/// the nil UUID (all bytes zero). 
 # [ link_name = "\u{1}_Z18spdk_bdev_get_uuid" ] pub fn spdk_bdev_get_uuid ( bdev : * const spdk_bdev ) -> * const spdk_uuid ; } extern "C" { 
 /// Obtain an I/O channel for the block device opened by the specified
/// descriptor. I/O channels are bound to threads, so the resulting I/O
/// channel may only be used from the thread it was originally obtained
/// from.
///
/// \param desc Block device descriptor.
///
/// \return A handle to the I/O channel or NULL on failure. 
 # [ link_name = "\u{1}_Z24spdk_bdev_get_io_channel" ] pub fn spdk_bdev_get_io_channel ( desc : * mut spdk_bdev_desc ) -> * mut spdk_io_channel ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to read into.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z14spdk_bdev_read" ] pub fn spdk_bdev_read ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut :: std :: os :: raw :: c_void , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to read into.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z21spdk_bdev_read_blocks" ] pub fn spdk_bdev_read_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut :: std :: os :: raw :: c_void , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel. This differs from
/// spdk_bdev_read by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer into the buffers provided. In
/// this case, the request may fail.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be read into.
/// \param iovcnt The number of elements in iov.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z15spdk_bdev_readv" ] pub fn spdk_bdev_readv ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : :: std :: os :: raw :: c_int , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a read request to the bdev on the given channel. This differs from
/// spdk_bdev_read by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer into the buffers provided. In
/// this case, the request may fail.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be read into.
/// \param iovcnt The number of elements in iov.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to read.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z22spdk_bdev_readv_blocks" ] pub fn spdk_bdev_readv_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : :: std :: os :: raw :: c_int , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to written from.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to write. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z15spdk_bdev_write" ] pub fn spdk_bdev_write ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut :: std :: os :: raw :: c_void , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param buf Data buffer to written from.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to write. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z22spdk_bdev_write_blocks" ] pub fn spdk_bdev_write_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , buf : * mut :: std :: os :: raw :: c_void , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel. This differs from
/// spdk_bdev_write by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer out of the buffers provided. In
/// this case, the request may fail.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be written from.
/// \param iovcnt The number of elements in iov.
/// \param offset The offset, in bytes, from the start of the block device.
/// \param len The size of data to write.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z16spdk_bdev_writev" ] pub fn spdk_bdev_writev ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : :: std :: os :: raw :: c_int , offset : u64 , len : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a write request to the bdev on the given channel. This differs from
/// spdk_bdev_write by allowing the data buffer to be described in a scatter
/// gather list. Some physical devices place memory alignment requirements on
/// data and may not be able to directly transfer out of the buffers provided. In
/// this case, the request may fail.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param iov A scatter gather list of buffers to be written from.
/// \param iovcnt The number of elements in iov.
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to write.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z23spdk_bdev_writev_blocks" ] pub fn spdk_bdev_writev_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , iov : * mut iovec , iovcnt : :: std :: os :: raw :: c_int , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a write zeroes request to the bdev on the given channel. This command
/// ensures that all bytes in the specified range are set to 00h
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset The offset, in bytes, from the start of the block device.
/// \param len The size of data to zero.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z22spdk_bdev_write_zeroes" ] pub fn spdk_bdev_write_zeroes ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , len : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a write zeroes request to the bdev on the given channel. This command
/// ensures that all bytes in the specified range are set to 00h
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to zero.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z29spdk_bdev_write_zeroes_blocks" ] pub fn spdk_bdev_write_zeroes_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit an unmap request to the block device. Unmap is sometimes also called trim or
/// deallocate. This notifies the device that the data in the blocks described is no
/// longer valid. Reading blocks that have been unmapped results in indeterminate data.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset The offset, in bytes, from the start of the block device.
/// \param nbytes The number of bytes to unmap. Must be a multiple of the block size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z15spdk_bdev_unmap" ] pub fn spdk_bdev_unmap ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , nbytes : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit an unmap request to the block device. Unmap is sometimes also called trim or
/// deallocate. This notifies the device that the data in the blocks described is no
/// longer valid. Reading blocks that have been unmapped results in indeterminate data.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks to unmap.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z22spdk_bdev_unmap_blocks" ] pub fn spdk_bdev_unmap_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a flush request to the bdev on the given channel. For devices with volatile
/// caches, data is not guaranteed to be persistent until the completion of a flush
/// request. Call spdk_bdev_has_write_cache() to check if the bdev has a volatile cache.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset The offset, in bytes, from the start of the block device.
/// \param length The number of bytes.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z15spdk_bdev_flush" ] pub fn spdk_bdev_flush ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset : u64 , length : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a flush request to the bdev on the given channel. For devices with volatile
/// caches, data is not guaranteed to be persistent until the completion of a flush
/// request. Call spdk_bdev_has_write_cache() to check if the bdev has a volatile cache.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param offset_blocks The offset, in blocks, from the start of the block device.
/// \param num_blocks The number of blocks.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z22spdk_bdev_flush_blocks" ] pub fn spdk_bdev_flush_blocks ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , offset_blocks : u64 , num_blocks : u64 , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit a reset request to the bdev on the given channel.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z15spdk_bdev_reset" ] pub fn spdk_bdev_reset ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Set an IOPS-based quality of service rate limit on a bdev.
///
/// \param bdev Block device.
/// \param ios_per_sec I/O per second limit.
/// \param cb_fn Callback function to be called when the QoS limit has been updated.
/// \param cb_arg Argument to pass to cb_fn. 
 # [ link_name = "\u{1}_Z28spdk_bdev_set_qos_limit_iops" ] pub fn spdk_bdev_set_qos_limit_iops ( bdev : * mut spdk_bdev , ios_per_sec : u64 , cb_fn : :: std :: option :: Option < unsafe extern "C" fn ( cb_arg : * mut :: std :: os :: raw :: c_void , status : :: std :: os :: raw :: c_int ) > , cb_arg : * mut :: std :: os :: raw :: c_void ) ; } extern "C" { 
 /// Submit an NVMe Admin command to the bdev. This passes directly through
/// the block layer to the device. Support for NVMe passthru is optional,
/// indicated by calling spdk_bdev_io_type_supported().
///
/// The SGL/PRP will be automated generated based on the given buffer,
/// so that portion of the command may be left empty.
///
/// \param desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cmd The raw NVMe command. Must be an admin command.
/// \param buf Data buffer to written from.
/// \param nbytes The number of bytes to transfer. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z29spdk_bdev_nvme_admin_passthru" ] pub fn spdk_bdev_nvme_admin_passthru ( desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut :: std :: os :: raw :: c_void , nbytes : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit an NVMe I/O command to the bdev. This passes directly through
/// the block layer to the device. Support for NVMe passthru is optional,
/// indicated by calling spdk_bdev_io_type_supported().
///
/// The SGL/PRP will be automated generated based on the given buffer,
/// so that portion of the command may be left empty. Also, the namespace
/// id (nsid) will be populated automatically.
///
/// \param bdev_desc Block device descriptor.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cmd The raw NVMe command. Must be in the NVM command set.
/// \param buf Data buffer to written from.
/// \param nbytes The number of bytes to transfer. buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z26spdk_bdev_nvme_io_passthru" ] pub fn spdk_bdev_nvme_io_passthru ( bdev_desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut :: std :: os :: raw :: c_void , nbytes : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Submit an NVMe I/O command to the bdev. This passes directly through
/// the block layer to the device. Support for NVMe passthru is optional,
/// indicated by calling spdk_bdev_io_type_supported().
///
/// The SGL/PRP will be automated generated based on the given buffer,
/// so that portion of the command may be left empty. Also, the namespace
/// id (nsid) will be populated automatically.
///
/// \param bdev Block device
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param cmd The raw NVMe command. Must be in the NVM command set.
/// \param buf Data buffer to written from.
/// \param nbytes The number of bytes to transfer. buf must be greater than or equal to this size.
/// \param md_buf Meta data buffer to written from.
/// \param md_len md_buf size to transfer. md_buf must be greater than or equal to this size.
/// \param cb Called when the request is complete.
/// \param cb_arg Argument passed to cb.
///
/// \return 0 on success. On success, the callback will always
/// be called (even if the request ultimately failed). Return
/// negated errno on failure, in which case the callback will not be called. 
 # [ link_name = "\u{1}_Z29spdk_bdev_nvme_io_passthru_md" ] pub fn spdk_bdev_nvme_io_passthru_md ( bdev_desc : * mut spdk_bdev_desc , ch : * mut spdk_io_channel , cmd : * const spdk_nvme_cmd , buf : * mut :: std :: os :: raw :: c_void , nbytes : usize , md_buf : * mut :: std :: os :: raw :: c_void , md_len : usize , cb : spdk_bdev_io_completion_cb , cb_arg : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Free an I/O request. This should be called after the callback for the I/O has
/// been called and notifies the bdev layer that memory may now be released.
///
/// \param bdev_io I/O request.
///
/// \return -1 on failure, 0 on success. 
 # [ link_name = "\u{1}_Z17spdk_bdev_free_io" ] pub fn spdk_bdev_free_io ( bdev_io : * mut spdk_bdev_io ) -> :: std :: os :: raw :: c_int ; } extern "C" { 
 /// Return I/O statistics for this channel. After returning stats, zero out
/// the current state of the statistics.
///
/// \param bdev Block device.
/// \param ch I/O channel. Obtained by calling spdk_bdev_get_io_channel().
/// \param stat The per-channel statistics.
/// 
 # [ link_name = "\u{1}_Z21spdk_bdev_get_io_stat" ] pub fn spdk_bdev_get_io_stat ( bdev : * mut spdk_bdev , ch : * mut spdk_io_channel , stat : * mut spdk_bdev_io_stat ) ; } extern "C" { 
 /// Get the status of bdev_io as an NVMe status code.
///
/// \param bdev_io I/O to get the status from.
/// \param sct Status Code Type return value, as defined by the NVMe specification.
/// \param sc Status Code return value, as defined by the NVMe specification. 
 # [ link_name = "\u{1}_Z28spdk_bdev_io_get_nvme_status" ] pub fn spdk_bdev_io_get_nvme_status ( bdev_io : * const spdk_bdev_io , sct : * mut :: std :: os :: raw :: c_int , sc : * mut :: std :: os :: raw :: c_int ) ; } extern "C" { 
 /// Get the status of bdev_io as a SCSI status code.
///
/// \param bdev_io I/O to get the status from.
/// \param sc SCSI Status Code.
/// \param sk SCSI Sense Key.
/// \param asc SCSI Additional Sense Code.
/// \param ascq SCSI Additional Sense Code Qualifier. 
 # [ link_name = "\u{1}_Z28spdk_bdev_io_get_scsi_status" ] pub fn spdk_bdev_io_get_scsi_status ( bdev_io : * const spdk_bdev_io , sc : * mut :: std :: os :: raw :: c_int , sk : * mut :: std :: os :: raw :: c_int , asc : * mut :: std :: os :: raw :: c_int , ascq : * mut :: std :: os :: raw :: c_int ) ; } extern "C" { 
 /// Get the iovec describing the data buffer of a bdev_io.
///
/// \param bdev_io I/O to describe with iovec.
/// \param iovp Pointer to be filled with iovec.
/// \param iovcntp Pointer to be filled with number of iovec entries. 
 # [ link_name = "\u{1}_Z22spdk_bdev_io_get_iovec" ] pub fn spdk_bdev_io_get_iovec ( bdev_io : * mut spdk_bdev_io , iovp : * mut * mut iovec , iovcntp : * mut :: std :: os :: raw :: c_int ) ; } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct __locale_data { pub _address : u8 , } pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; } impl Default for __va_list_tag { fn default ( ) -> Self { unsafe { :: std :: mem :: zeroed ( ) } } } # [ repr ( C ) ] # [ derive ( Debug , Default , Copy , Clone ) ] pub struct iface { pub _address : u8 , }